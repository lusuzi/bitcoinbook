{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 郎咸平说过：比特币白给我都不要 巴菲特：比特币是泡沫，不是一种能够生产价值的资产 紫色的股：为什么说比特币是典型的泡沫 ...... 也有人说，区块链是最伟大的发明，堪比互联网。 到底比特币是什么？如何判断？难道我们能做的就是人云亦云？ 如何能有自己的独立判断？ 每个人都有自己的“全知遮蔽”，就像每个人都看不见自己的后脑勺一样。在自己的视野内，在自己的舒适区，如鱼得水，但是就是这种感觉最容易让自己以为“自己以为的”就是客观事实。 正确的态度是研究搞懂，之后才有资格做判断。 这本书就能帮助您全面了解比特币，而且有助于理解其他数字货币。 本书翻译过程中得到了higer（区块链研习社社长）的支持和鼓励，特此致谢。 本书部分段落内容参考摘录了《精通比特币》知笔墨版本，在此特别声明并致谢。 本书附录A比特币白皮书，其中附录A-1全文引自【巴比特】 ，附录A-2全文引自【李笑来英中文对照版】。在此特别声明并致谢。 以下朋友对本书做出巨大贡献： 菜菜子：翻译了英文版序言，第二版更新说明，词汇表，附录2交易脚本语言操作符，常量和符号等章节 柴春燕和格林怪物：联合翻译附录隔离见证部分 Robbie_英语翻译：第4章审核校对 吴迪：第5章，第9章审核校对 格林怪物：第6章审核校对 阿龙：第7章，第11章审核校对 阮立志和冯锦炜：第10章审核校对 琳：第12章审核校对 黄豆：封面封底扉页以及其他内容设计 特别感谢赵斌锋，在本书最后出版前校对过程中付出了巨大的努力，修正了一些瑕疵。 由于时间原因和个人水平能力原因，初稿中有许多格式和理解翻译错误。以上各位朋友在审核校过程中修正了初稿中许多错误，甚至部分章节兼职了翻译工作，在此表示致歉和感谢。 即便如此，当前版本还可能存在部分错误，欢迎读者在github上提交勘误，也可以发至邮箱：yuntianming@aliyun.com 乔延宏 2017.11.11 正版书购买链接 本书经过多方努力，历时一年，终于付梓，欢迎购买正版图书。京东购买链接： https://item.jd.com/12620946.html 2019年下半年校对说明 2019年10月开始到2019年12月底，对github上的第二版进行了一次全面的校对，更新了下面的内容： 1、格式方面：增加章节名称。所有“提示”，“警告”，“注意”等全部改为引用。引用章节增加链接和中文括号。 2、图片：图片未做翻译，链接全部改用英文版链接。 3、与英文版内容同步更新至2019年9月。修正部分章节的明确错误，翻译不准确，表达琐碎之处。增加了可执行文件的源代码。 4、增加比特币白皮书的李笑来翻译版本，附其他版本链接。 乔延宏 2019.12.22 2020年上半年校对说明 2020年7月跟随原版进行了更新。主要内容有： 1、删除失效链接； 2、增加2020年5月减半相关内容； 3、删除染色币（Colored Coin）相关内容; 4、更新附录部分内容； 5、更新目录。 乔延宏 2020.7.30 鸣谢: 区块链研习社 Mastering Bitcoin - Second Edition 版权说明 The tags, second_edition_print_1 and second_edition_print2, correspond to the first (June 8th, 2017) and second (July 20th, 2017) print of Mastering Bitcoin (Second Edition), as published by O'Reilly Media. Mastering Bitcoin - Second Edition by Andreas M. Antonopoulos LLC is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. "},"preface.html":{"url":"preface.html","title":"原版序言","keywords":"","body":"关于本书 我第一次偶遇比特币是在2011年年中，当时的反应大概是“哈！书呆子的钱嘛！”因为没能领会它的重要性，我忽视它长达六个月之久，而让我稍感宽慰的是，许多我认识的一些聪明绝顶的人也是这种反应。在一次邮件列表讨论时，我再次接触到了比特币，于是决定阅读中本聪（Satoshi Nakamoto）写的白皮书，研究比特币的权威解释，看看到底是怎么一回事。我仍记得刚刚读完那九页内容的那一刻，那时我才终于明白了：比特币不单单是一种数字货币，还是一种给货币及其他很多东西提供基础的信任网络。对“不是货币，而是去中心化信任网络”的领悟，让我开启了为期四个月的比特币沉醉之旅。我如饥似渴地寻找任何关于比特币的点滴信息，变得越来越着迷，每天都花上12 个小时以上紧盯屏幕，竭尽所能地不断阅读、写作、学习和编程。从这段着魔的状态中走出来的时候，我的体重由于前期没有规律饮食轻了20 多磅，同时我也坚定了要全心投入比特币事业的决心。 随后的两年，我创立了一系列开发比特币相关服务和产品的公司，之后我决定写我的第一本书。书的主题就是激发了我疯狂的创造力并让我冥思苦想的比特币，它是我在继互联网之后遇到的最为振奋人心的技术。现在是时候跟更广大的读者分享我对这项惊人技术的热情了。 阅读对象 本书主要面向程序员。如果你能使用一门编程语言，本书将会告诉你加密货币的原理、使用方法，以及如何开发与之相关的软件。对希望理解比特币及加密货币内在工作机制的非程序员读者们，本书前几章作为对比特币的深入介绍依然适用。 封面故事 在群居生物物种中，切叶蚁表现出了高度复杂行为的物种特征。但是，群落中的每一只蚂蚁个体仅仅遵循一些社会互动和化学气味（即信息素）交换的简单规则。维基百科提到：“切叶蚁形成地球上仅次于人类的最为庞大且复杂的动物社会。”实际上，切叶蚁不吃叶子，而是使用叶子制造一种真菌来充当蚁群主要食物来源。意识到了吗？它们在耕作！ 虽然切叶蚁形成的是阶级社会，且依靠蚁后繁衍后代，但是在蚁群中不存在中央集权体制或领导人。通过切叶蚁我们可以看到，群落中数百万成员所展现的高度智能且复杂的行为是社会网络中的个体互动这一性质的凸显。 大自然向我们证明，去中心化体制具有弹性并能创造出意想不到的复杂性和难以想象的精妙，而不需要中央集权体制、等级制度或复杂的组织结构。 比特币网络正是这样一个高度复杂的去中心化的可信网络，能够支撑无数财务流程。然而，比特币网络的每一个节点都遵循着一些简单的数学准则。节点间的相互作用促成了组织的复杂行为，而并不是任何某个单一节点自身具有复杂性和可信性。就像蚁群一样，比特币的弹性网络是一个由众多遵循简单准则的简单节点所组成的弹性网络，这些简单的节点准则聚合在一起可以完成惊人的事情，而不需要任何中枢协调。 本书惯例 本书采用以下排版上的约定: 斜体:指示新的术语、URL链接、email地址、文件名和文件扩展名 等宽字:用于程序清单的显示，也用于段落中涉及的程序要素，如变量或函数名、数据库、数据类型、环境变量、语句和关键字。 等宽粗体:显示需要由用户输入的命令和其他文字。 等宽斜体:显示需要由用户提供的或根据上下文环境修改的值。 [TIP]这个标志表示提示或建议。 [NOTE]这个标志表示通用注释。 [WARNING]这个标志表示警告或提醒。 代码示例 本书示例是基于类Unix 操作系统（例如Linux 或Mac OS X）的命令行，用Python，C++编程语言来说明的。全部代码段均可在Github 主代码库中的code 子目录获得。读者可以通过GitHub 创建自己的代码分支，尝试书中示例，或者提交代码更正。 所有代码段在大多数操作系统上都可以通过最小化安装对应语言的编译器和解释器来重现。在必要的地方，本书还提供了基本的安装指令以及每步指令输出的结果。 为了便于打印，本书重新格式化了部分代码段和代码输出。在所有此类例子中，每行代码以反斜杠（\\）字符和换行符分开。当你需要尝试这些示例时，请删除这两个字符，把被分隔的两行重连起来，就可以看到与例子中一致的结果了。 本书所有代码段尽可能地采用实值计算，因此你可以通过重复构建本书提供的代码示例，用你自己写的代码计算出相同的结果。譬如，书中出现的私钥和对应的公钥及地址也都是真实存在的。示例中的所有交易、区块和区块链均被记录在实际的比特币区块链中，是公共账目的一部分，因而你可以在任何比特币系统中检查它们。 使用代码示例 本书的目的是帮助你完成工作。总的来说，你可以在你的程序和文档中使用本书的代码示例。除非你要复制代码的关键部分，否则不需要联系我们获得许可。例如，使用程序中的几段代码，或者引用本书及代码来回答问题是不需要获准的；而售卖或分发包含O'Reilly书中代码示例的光盘，或者将大量书中代码合并于你的产品或文档则必须获得我们的许可。 我们鼓励、但不强制要求您在引用本书时表明出处。书目引用格式通常包括书名、作者、出版商、ISBN。例如:“精通比特币，Andreas•M•Antonopoulos(O'Reilly)。版权2017 Andreas•M•Antonopoulos, 978-1-491-95438-6.” 本书某些版本提供了开源许可，如CC-BY-NC，这种情况下,开源许可条款适用。如果你觉得你对本书代码示例的使用超出了合理范围或上述许可，请随时与我们联系:permissions@oreilly.com。 书中涉及的比特币地址与交易 书中的比特币地址、交易、密钥、二维码、区块链数据大部分都是真实的。这就意味着你可以通过脚本或程序等方式在比特币区块链中查看示例中给出的交易。 然而，需要注意的是创建地址的这些私钥要么写入书中，要么已经被“焚毁”。这就意味着如果你往这些地址中转入比特币的话，这些比特币要么永远丢失，要么被本书的其他读者通过书中给出的私钥拿走。 [警告] 不要给书中给出的任何地址转比特币。否则你的钱将永远消失或被本书其他读者拿走。 O'Reilly Safari(正式名称为Safari在线书店) 是一个为企业、政府、教育家以及个人提供会员制的培训与参考的平台。 会员可以在该平台获取来自超过250家出版社提供的成千上万的书籍、培训视频、学习路径、交互教程、策划播放列表，这些公司包括：Prentice Hall Professional, Addison-Wesley Professional, MicrosoftPress, Sams, Que, Peachpit Press, Adobe, Focal Press, Cisco Press, John Wiley& Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FTPress, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett以及CourseTechnology，除此之外还有其他很多公司。 要获取更多信息，请访问:http://oreilly.com/safari 要想更多了解我们书籍、课程、会议和新闻的信息，可以登录我们的官网:http://www.oreilly.com 我们Facebook账号: http://facebook.com/oreilly 关注我们的Twitter账号: http://twitter.com/oreillymedia 我们在YouTube上的视频🔗http://www.youtube.com/oreillymedia 联系作者 你可以在我的个人网站联系我（Andreas M. Antonopoulos）: https://antonopoulos.com/ 《精通比特币》的信息以及开放版本与翻译的信息可以在此网址获取: https://bitcoinbook.info/ 请关注我Facebook账号: https://facebook.com/AndreasMAntonopoulos 请关注我Twitter账号: https://twitter.com/aantonop 请关注我领英账号: https://linkedin.com/company/aantonop 特别感谢所有的赞助人，是他们支持我了数月的工作。你可以访问我的赞助人网站： https://patreon.com/aantonop 鸣谢 这本书的出版浓缩了很多人的努力与付出。在写书的过程中，我很感激来自从朋友、同事、甚至陌生人的帮助，是他们的加入与努力帮助我完成了这本关于数字货币和比特币的纯技术类书籍。 我们不可能将比特币技术与比特币社区区分开，因为这本书不仅是社区的产品，也是比特币技术。我写这本书的工作从始至终都得到了整个社区的鼓励、欢呼、支持与奖励。最重要的是，这本书让我2年来成为这个极好社区的一部分，我无法用言语表达你们接纳我成为社区成员的感谢之情。这写书的过程中有太多的人需要感谢，以至无法一一列举，这些人包括我在会议、重大事件、研讨会、聚会、比萨聚会以及小型私人集会遇到的，同时还有那些在Twitter、reddit、bitcointalk.org以及GitHub上与我联系，并对本书成稿有影响的人。你在本书中找到的每个想法、类比、问题、回答以及解释，都是在我与社区人员沟通交流时产生的，并得到验证和优化的结果。谢谢所有支持过我的人，没有你们的支持将不会有这本书的存在。对此，我将永远心存感激。 当然，我是经过了很长一段时间才成为作家并编写了第一本书。我的第一语言是（学校教育）希腊语，因此我需要在大学一年级时接受英语写作补习课程。我要感谢我的英语写作老师Diana Kordas，那年是他帮助我建立了自信和写作技能。随后，作为教授，在为《NetworkWorld》杂志撰稿时，我提升了自己在数据中心方面的写作技能。我要感谢John Dix and John Gallant，他们给了我第一份写作方面的工作，让我成为《Network World》杂志的专栏作者，还要感谢我的编辑Michael Cooney和我的同事Johna Till Johnson，是他们帮我编辑我的专栏文章，让它们得以发表。四年每周500字的写作经验最终给了我足够的信心成为一名作家。 还要感谢那些在我提交本书稿件至 O’Reilly出版社时那些帮助过我的人，他们为我提供参考和稿件审阅。特别要感谢JohnGallant、Gregory Ness、Richard Stiennon、Joel Snyder、Adam B. Levine、Sandra Gittlen、John Dix、Johna Till Johnson、Roger Ver以及Jon Matonis。特别感谢Richard Kagan、Tymon Mattoszko和Matthew Taylor，Richard Kagan、Tymon Mattoszko帮我审阅了本书早期稿件，MatthewTaylor帮我修改了稿件。 感谢《DNS and BIND》的作者Cricket Liu，是他将我介绍给了O’Reilly出版社。还要感谢O’Reilly 的Michael Loukides和Allyson MacDonald，是他们花费数月时间帮助出版本书。当最终稿件因为种种原因未按计划提交而错过出版截止日期时，Allyson表现地特别耐心。对于第2版，我要感谢Timothy McGovern的全程指导、Kim Cofer的耐心编辑以及 RebeccaPanzer帮助插入了许多新图表。 最初的一些章节的草稿是最难写的部分，因为比特币一个很难说清楚的主题。每次我研究比特币中某个主题时，我还得考虑整体的技术内容。当我努力想将主题说得简单易懂，围绕这样一个密集型技术主题展开叙述时，我不断地被卡住并有点沮丧。最终，我决定以讲述人们使用比特币的故事为主线来编写本书，从而让我可以轻松地编写本书。我要感谢我的导师兼朋友，Richard Kagan，是他帮助我想到了以故事方式来编写此书，让我跨过了编者的阻碍。我要感谢PamelaMorgan，他审阅了本书第一版与第二版的早期草稿的每个章节，并且提出了很好的改进意见，让本书内容质量更高。同时，还要感谢San Francisco比特币开发者组织小组，还要感谢帮助测试早期材料的TaariqLewis和Denise Terry。感谢Andrew Naugler帮助设计信息图标。 在本书编写的过程中，我在GitHub上制作了早期草稿，然后邀请公众对其进行评论。收到了100多条评论、建议、修改和捐赠等方面的回应。那些捐助者在文末的早期发布草稿的GitHub捐助者中进行了公布，并表达了我的感谢之情。真诚地感谢我的GiuHub自愿者编辑Ming T. Nguyen (第1版编辑) and Will Binns (第2版编辑)，他们不辞辛劳地组织、管理和解决GitHub上的pull requests、issue reports，并且执行bug修复工作。 当完成草稿撰写后，本书经历了多轮技术审阅与修改。感谢Cricket Liu和Lorne Lantz的全程审阅、评论和支持。 许多比特币开发者贡献了示例代码、审阅、评论和鼓励。感谢Amir Taaki和Eric Voskuil提供了示例代码片段和许多很好的评论。Chris Kleeschulte编写了BitCore附录部分；Vitalik Buterin和Richard Kiss帮助提供椭圆曲线数学解析和实现代码；感谢GavinAndresen对本书的修订、评论和支持；感谢 Michalis Kargakis的评论、捐赠和btcd简介；感谢Robin Inge对本书的勘误，改进了第2版的印刷效果。在第2版中，我再次收到了很多比特币核心开发人员的帮助，包括让隔离见证通俗易懂的Eric Lombrozo，帮助改进交易章节的Luke-Jr，帮助审阅隔离见证和其他章节的JohnsonLau，还有其他很多要感谢的开发者。我深深地感谢帮助解释闪电网络的Joseph Poon、Tadge Dryja和Olaoluwa Osuntokun，他们还帮助我审阅了我的文章，帮助我解答了我无法回答的问题。 我将我的书和深爱之词献给我亲爱的母亲Theresa，她在我们住的房子中的每面墙上放满了书籍。尽管自认为是科技产品排斥着，我母亲还在1982年给我买了第一台电脑。我的父亲Menelaos是一名土木工程师，刚在80岁时出版了他的第一本书，我的父亲是一名科技和工程技术爱好者，他教会了我逻辑思考与分析。 感谢在写书过程中所有支持我的人。 "},"cn-preface.html":{"url":"cn-preface.html","title":"中文版序言","keywords":"","body":"中文版序言 送你一把打开区块链世界大门的钥匙——《精通比特币第二版》序言 2008年比特币诞生，原本只是一个密码学极客之间的玩物，没想到犹如打开的潘多拉盒子，慢慢席卷全球。在08年以前还没有人能成功地研发出一个运行良好的数字货币出来，直到比特币问世；另外，区块链作为比特币的底层技术，在此之前也是闻所未闻。那么区块链到底有什么魔力，让整个世界为之疯狂呢？ 相信很多初学者都有这样的疑问。我也曾带着这样的困惑翻阅了大量的书籍，然后才有了一个比较全面的认识。2010年从中科院毕业以来我一直在农行软件开发中心工作，平时做的主要是一些传统银行核心系统的研发，有时候会觉得枯燥。特别是，13年互联网金融爆发，直接冲击到银行的传统业务，也冲击着我们这些处于体制内一份子的心灵。我并非觉得压力大，而是看到了机会，因为以前在我脑海深处我一直觉得进入体制内之后便很难再有机会进入一个新领域了，没想到我当时所从事的金融行业竟然是当下的香饽饽，所以有时候我也会关注一下外面的机会。 那个时候银行业正处于变革的关口，大量的员工和我一样看到了这样的机会，选择出走寻求更好的待遇，年薪百万也是有的。当我犹豫不决是否要像他们一样选择离开的时候，我关注到单位内部的一封邮件里提到了关于研究区块链技术方面的文字。加之我自身对新技术的狂热，经过一番思量，在2016年6月份的时候我给总经理去了一封邮件，正式决定从当前枯燥的工作岗位上“出走”，选择进入一个全新的领域，虽然我仍在体制内，但我觉得在一个大的平台上，或许有更好更多的资源让我学习这些新东西。 这是故事的开始，也是区块链研习社成立的发端。因为正是得益于这样的一个机会，我当时有幸参加了大量的区块链会议，并接触到业内顶尖的区块链专家，从而耳濡目染地慢慢深入到这个行业里。我当时意识到这个群体还很小，整个社会对区块链的了解还远远不够，虽然以前有很多布道者也曾尝试推动区块链技术在国内的发展，但是我决定做一个不太一样的事情，建立一个区块链的学习社群，让所有的爱好者们能够在这里获得最贴心的区块链知识服务，并形成一个强有力的群体，创造更大的价值和影响力。因此，2017年1月份，区块链研习社成立，这是国内最早的区块链学习社群，目前整个群体人数近3000，相信也是国内最大并且看起来质量最高的社群了。对于这个社群，我把它当成一份事业来做，至少做20年。 在带着大家学习的过程中，很多人都问到我一个问题，“从何入手？”，我深知理论的学习总是非常必要的，武装了大脑之后才能更好地践行，于是我推荐大家去看书，去学习。而这里首推的就是《精通比特币》这本电子书籍（英文为《Mastering Bitcoin》），它可以说是学习区块链的入门首选，是宝典级的区块链书籍。只不过，比特币经历了几年的发展，也开始出现一些变化，比如比特币进行了隔离见证升级，也分叉出了一个全新的币种BCC，因此第一版的书籍很多地方可能需要更新，目前国外虽然有《Matering Bitcoin 2.0》版本的英文书籍，但是在互联网上还没有看到中文版的翻译。 乔延宏，也就是《Matering Bitcoin 2.0》的中文翻译版本《精通比特币第二版》的发起者和编译者，正是我们区块链研习社的核心成员，他多年都在打磨一个叫做“认知学习法”的学习方法，并尝试将其应用到各种新领域知识的学习当中，效果颇为显著。这从他快速掌握区块链知识，并在网络撰写超30万字的文章，以及担任本电子书籍的主要翻译上的功力，可见一斑。为此，他还专门成立了一个品牌，叫做“云天明”，希望将此方法传递给更多的人。 刚开始的时候他只是一味地进行翻译，在有限的渠道进行推广，为了坚持，他基本上每天都在进行着翻译工作，从而形成了翻译的初稿，对于他这种过人的毅力，我非常佩服。不过我觉得，我们应该做一件更有价值的事情——将这些翻译进行充分校订并形成中文阅读良好的电子书籍，免费供应给全国的区块链爱好者们，为我们国家，为这个世界，更好地普及区块链知识。 为了全力促成这个事情，我又从人才济济的区块链研习社内部挑选了大量的精英配合乔延宏的翻译和校订工作，这个团队历经多个日夜的苦思琢磨和仔细推敲，最终促成了本版中文翻译书籍的问世。 相信《精通比特币第二版》会成为你最好的入门书籍，即便你有了一定的基础，偶尔翻一翻都会有不一样的收获。 现在将这把钥匙送给你，一起打开区块链世界的大门，共创美好的未来吧！ ​ higer （区块链研习社社长） ​ 2017.11.12 "},"trans-preface.html":{"url":"trans-preface.html","title":"译者序","keywords":"","body":"郎咸平说过：比特币白给我都不要 巴菲特：比特币是泡沫，不是一种能够生产价值的资产 紫色的股：为什么说比特币是典型的泡沫 ...... 也有人说，区块链是最伟大的发明，堪比互联网。 到底比特币是什么？如何判断？难道我们能做的就是人云亦云？ 如何能有自己的独立判断？ 每个人都有自己的“全知遮蔽”，就像每个人都看不见自己的后脑勺一样。在自己的视野内，在自己的舒适区，如鱼得水，但是就是这种感觉最容易让自己以为“自己以为的”就是客观事实。 正确的态度是研究搞懂，之后才有资格做判断。 这本书就能帮助您全面了解比特币，而且有助于理解其他数字货币。 本书翻译过程中得到了higer（区块链研究社社长）的支持和鼓励，特此致谢。 本书部分段落内容参考摘录了《精通比特币》知笔墨版本，在此特别声明并致谢。 本书附录1比特币白皮书全文摘自巴比特 《比特币白皮书：一种点对点的电子现金系统》，在此特别声明并致谢。 以下朋友对本书做出巨大贡献： 菜菜子：翻译了英文版序言，第二版更新说明，词汇表，附录2交易脚本语言操作符，常量和符号等章节 柴春燕和格林怪物：联合翻译附录隔离见证部分 Robbie_英语翻译：第4章审核校对 吴迪：第5章，第9章审核校对 格林怪物：第6章审核校对 阿龙：第7章，第11章审核校对 阮立志和冯锦炜：第10章审核校对 琳：第12章审核校对 黄豆：封面封底扉页以及其他内容设计 由于时间原因和个人水平能力原因，初稿中有许多格式和理解翻译错误。以上各位朋友在审核校过程中修正了初稿中许多错误，甚至部分章节兼职了翻译工作，在此表示致歉和感谢。 即便如此，当前版本还可能存在部分错误，欢迎读者在github上提交勘误，也可以发至邮箱：yuntianming@aliyun.com 乔延宏 2017.11.12 本书电子版链接： 《master bitcoin 2nd》英文原版链接 https://github.com/bitcoinbook/bitcoinbook 第二版中文翻译版初稿链接： https://github.com/tianmingyun/MasterBitcoin2CN "},"second_edition_changes.html":{"url":"second_edition_changes.html","title":"第二版更新内容","keywords":"","body":" 第1章 –什么是比特币 更新了比特币的发展历史 更多的使用者案例和更新 更多比特币用户和客户端的示例 更新了如何获取、使用和花费比特币的教程 第2章 – 比特币的原理 很多小的改变、更新和改进 第3章 – 比特币客户端 改进并更新了示例与代码 配置选项和示例 运行比特币节点 更新的库文件 第4章 – 密钥和地址 很多小的改进 改进与新增图表 第5章 – 钱包 更多关于BIP39助记的详细信息 BIP39密码短语和使用案例 商用服务器上使用公共扩展密钥 改进与新增图表 第6章 – 交易 交易数据结构 更多关于输入和输出的信息 交易序列化/反序列化 交易手续费 动态手续费 手续费估计 第三方手续费估算服务 数字签名 数字签名创建与验证 签名序列化 (DER编码) 签名哈希标志 ECDSA算法概述 第7章高级交易和脚本 时间锁 交易级别绝对 (锁定时间) UTXO脚本级别绝对(锁定时间验证确认) 输入级别相对 (序列) UTXO脚本级别相对(序列验证确认 中位过去时间 时间锁定防范手续费狙击 脚本流控制 验证守护语句 时间锁守护语句 复杂脚本 (示例和分析) 第8章比特币网络 传播网络 简单支付验证节点改进 Bloom过滤器与简单支付验证 简单支付验证节点和隐私 加密认证连接(BIP150151) 第9章区块链 默克尔树和简单支付验证 区块链测试 测试网 使用测试网 隔离网 私有网 使用私有网 区块链测试网中的开发 第10章挖矿和共识 硬分叉、软分叉和信号发送 硬分叉分歧 软分叉的功能升级 在区块版本中发送软分叉消息 BIP-9 (版本信息) 信号发送与激活 共识软件开发 第11章比特币安全 安全规范 第12章 比特币应用(全新章节) 区块链应用 可信平台的区块构建 构建区块链应用 染色币 交易对方 支付通道 视频流示例 时间锁支付通道 不对称可撤销的承诺 哈希时间按锁定合约(HTLC) 闪电网络 路由支付通道 传输和匿名路由 闪电网络的好处 附录 – 隔离见证 (全新章节) 隔离见证介绍 为什么要隔离见证 隔离见证交易、输出和脚本 P2WPKH P2WSH 嵌套隔离见证 向后兼容的考虑 P2SH(P2WPKH) P2SH(P2WSH) 交易标识符 (txid)与可展性修复 新签名算法 隔离见证的经济刺激 "},"glossary.html":{"url":"glossary.html","title":"词汇表","keywords":"","body":"该部分包含了大部分与比特币相关的术语。这些术语的使用贯穿于全书，所以对其进行标注以提供快速参考。 地址: 比特币地址（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成。它其实是通过对160位二进制公钥哈希值进行base58check编码后的信息。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。 bip: 比特币改进提议 （Bitcoin Improvement Proposals的缩写），指比特币社区成员所提交的一系列改进比特币的提议。例如，BIP0021是一项改进比特币统一资源标识符（URI）计划的提议。 比特币: “比特币”既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。 区块: 一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。 区块链: ​ 区块链是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。 拜占庭将军问题: ​ 一个可靠的计算机系统必须能够处理一个或多个组件产生的失败。一个失败的组件可能表现出通常被忽略的行为类型，即发送矛盾的信息到系统的不同部分。处理这类失败类型的问题抽象地被表达为拜占庭将军问题。 coinbase: ​ 一个用于为创币交易提供唯一输入的特殊字段。coinbase允许声明区块奖励，并为任意数据提供多达100字节。不要与创币交易混淆。 Coinbase交易: ​ 区块中的第一个交易。该交易是由矿工创建的，它包含单个coinbase。不要与Coinbase混淆 冷存储: ​ 该术语指的是离线保存比特币。当比特币的私钥被创建，同时将该私钥存储在安全的离线环境时，就实现了冷存储。冷存储对于任何比特币持有者来说是重要的。在线计算机在黑客面前是脆弱的，不应该被用于存储大量的比特币。 染色币: ​ 比特币2.0开源协议允许开发者在比特币区块链之上，利用它的超越货币的功能创建数字资产。 确认: 当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到6及以上时，通常认为这笔交易比较安全并难以逆转。 共识: ​ 当网络中的许多节点，通常是大部分节点，在其本地验证的最长区块链中都具有相同的区块时，称为共识。不要与共识规则混淆。 共识规则: ​ 全节点与其他节点保持共识的区块验证规则。不要与共识混淆。 难度: ​ 整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。 难度重定: ​ 全网中每新增2016个区块，全网难度将重新计算，该新难度值将依据前2016个区块的哈希算力而定。 难度目标: ​ 使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。 双重支付: ​ 双重支付是成功支付了1次以上的情况。比特币通过对添加到区块中的每笔交易进行验证来防止双重支付，确保交易的输入没有被支付过。 ECDSA: ​ 椭圆曲线数字签名算法（ECDSA）是比特币使用的加密算法，以确保资金只能被其正确拥有者花费。 超额随机数: ​ 随着难度增加，矿工通常在循环遍历4亿次随机数值后仍未找到区块。因为coinbase脚本可以存储2到100字节的数据，矿工开始使用这个存储空间作为超额nonce空间，允许他们利用一个更大范围的区块头哈希值来寻找有效的区块。 矿工费: ​ 交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。 分叉: ​ 分叉也被称为意外分叉，是在两个或多个区块拥有同一区块高度时发生的，此时使区块链产生了分叉。典型情况是两个或多个区块矿工几乎在同一时刻发现了区块。共识攻击的情况下也会出现分叉。 创世块: ​ 创世区块指区块链上的第一个区块，用来初始化相应的加密货币。 硬分叉: ​ 硬分叉，也叫硬分叉改变，是区块链中一个永久分歧。通常在已按照新的共识规则进行了版本升级的节点产生了新区块时，那些未升级节点无法验证这些新区块时产生硬分叉。不要与分叉、软分叉或者Git分叉混淆。 硬件钱包: ​ 硬件钱包是一种特殊的比特币钱包，硬件钱包可以将用户的私钥存储在安全的硬件设备中。 哈希: ​ 二进制输入数据的一种数字指纹。 哈希锁: ​ 哈希锁是限制一个输出花费的限制对象，其作用一直持续到指定数据片段公开透露。哈希锁有一个有用的属性，那就是一旦任意一个哈希锁被公开打开，任何其他使用相同密钥保护的哈希锁也可以被打开。这使得可能创建多个被同一哈希锁限制的输出，这些输出将在同一时间被花费。 HD协议: ​ 层级确定性（HD）密钥创建和传输协议（BIP32），该协议允许按层级方式从父密钥创建子密钥。 HD钱包: ​ 使用层级确定性（HD）密钥创建和传输协议（BIP32）的钱包。 HD钱包种子: ​ HD钱包种子或根种子是一个潜在简短的值，用于作为种子为HD钱包生成主私钥和主链码。 哈希时间锁定合约: ​ 哈希时间锁定合约（HTLC）是一类支付方式，其使用哈希锁和时间锁来锁定交易。解锁需要接收方通过加密支付证明确认在截止日期之前收到了支付，或者接收方丧失了认领支付的能力，此时支付金额将返回给支付方。 KYC: ​ 充分了解你的客户（KYC，Know yourcustomer）是一个商业过程，用于认证和验证顾客的身份信息。也指银行对这些活动的监管。 LevelDB: ​ LevelDB是一个开源的磁盘键值对数据库。LevelDB是一个重量轻、功能单一的持久性库，可以绑定到许多平台。 闪电网络: ​ 闪电网络是哈希时间锁定合约（HTLCs）的一种推荐实现方式。闪电网络通过双向支付通道方式允许支付方通过多个点对点支付通道安全地路由支付。这样就可以形成一个网络，该网络中的一方可以支付给其他任何一方，即使在他们双方没有直接建立支付通道的情况。 锁定时间: ​ 锁定时间（技术上来说是nLockTime）是交易的一部分，其表明该交易被添加至区块链中的最早时间或区块。 交易池: ​ 比特币内存池是区块中所有交易数据的集合，这些交易已经被比特币节点验证，但未被确认。 默克尔根: ​ 默克尔树的根是树的根节点，该节点为树中所有节点对的多次哈希计算结果。区块头必须包括区块中所有交易哈希计算得到的有效默克尔根。 默克尔树: ​ 生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。在比特币中，叶子节点来自于单个区块中的交易。 矿工: ​ 一个为新区块通过重复哈希计算来寻找有效工作量证明的网络节点。 多重签名: ​ 多重签名指的是需要多于一个密钥来验证一个比特币交易。 网络: ​ 传播交易和区块至网络中每个比特币节点的点对点网络。 随机数: 随机数是比特币区块中一个32位（4字节）的字段，在设定了该值后，才能计算区块的哈希值，其哈希值是以多个0开头的。区块中的其他字段值是不变的，因为他们有确定的含义。 离线交易: ​ 离线交易是区块链外的价值转移。当在链交易（通常简单来说就是一个交易）修改区块链并依赖区块来决定它的有效性时，离线交易则依赖其他方法来来记录和验证该交易。 操作码: ​ 操作码来源于比特币脚本语言，通过操作码可以在公钥脚本或签名脚本中实现压入数据或执行函数的操作。 开放资产协议: ​ 开放资产协议是一个建立在比特币区块链之上简单有效的协议。它允许用户创建资产的发行和传输。开放资产协议是颜色币概念的一个进化。 OP_RETURN: ​ 一个用在OP_RETURN交易中的一种输出操作码。不要与OP_RETURN交易混淆。 OP_RETURN交易: ​ OP_RETURN在比特币核心0.9.0中默认的一种被传播和挖出的交易类型，在随后的版本中添加任意数据至可证明的未花费公钥脚本中，全节点中无需将该脚本存储至他们的UTXO数据库中。不要与OP_RETURN操作码混淆。 孤块: ​ 孤块由于父区块未被本地节点处理的区块，所以他们还不能被完全验证。 孤立交易: ​ 孤立交易是指那些因为缺少一个或多个输入交易而无法进入交易池的交易。 交易输出: ​ 交易输出（TxOut）是交易中的输出，交易输出中包含两个字段：1.输出值字段：用于传输0或更多聪；2.公钥脚本：用于确定这些聪需在满足什么条件的情况下才可花费。 P2PKH: ​ 支付到比特币地址的交易包含支付公钥哈希脚本（P2PKH）。由P2PKH脚本锁定的交易输出可以通过给出由相应私钥创建的公钥和数字签名来解锁（消费）。 P2SH: ​ P2SH是一种强大的、新型的、且能大大简化复杂交易脚本的交易类型。通过使用P2SH，详细描述花费输出条件的复杂脚本（赎回脚本）将不会出现在锁定脚本中。相反，只有赎回脚本哈希包含在锁定脚本中。 P2SH地址: ​ P2SH地址是基于Base58编码的一个含有20个字节哈希的脚本。P2SH地址采用“5”前缀。这导致基于Base58编码的地址以“3”开头。P2SH 地址隐藏了所有的复杂性，因此，运用其进行支付的人将不会看到脚本。 P2WPKH: ​ P2WPKH签名包含了与P2PKH花费相同的信息。但是签名信息放置于见证字段，而不是签名脚本字段中。公钥脚本也被修改了。 P2WSH: ​ P2WSH与P2SH的不同之处在于加密证据存放位置从脚本签名字段转变至见证字段，公钥脚本字段也被改变。 纸钱包: ​ 在大多数特定含义下，纸钱包是一个包含所有必要数据的文件，这些数据用于生成比特币私钥，形成密钥钱包。然而，人们通常使用该术语来表达以物理文件形式离线存储比特币的方式。第二个定义也包括纸密钥和可赎回编码。 支付通道: ​ 微支付通道和支付通道是设计用于允许用户生成多个比特币交易，且无需提交所有交易至比特币区块链中。在一个典型的支付通道中，只有两个交易被添加至区块链中，但参与双方可以生成无限制或接近无限制数量的支付。 矿池: ​ 矿池一种挖矿方式，在矿池中多个客户端共同贡献算力来产生区块，然后根据贡献算力大小来分配区块奖励。 权益证明: ​ 权益证明（POS）是一种方法，加密货币区块链网络获得分发共识。POS会让用户证明其拥有的资产总量(他们在数字货币中的权益)。 工作量证明: ​ 工作量证明指通过有效计算得到的一小块数据。具体到比特币，矿工必须要在满足全网目标难度的情况下求解SHA256算法。 奖励: ​ 每一个新区块中都有一定量新创造的比特币用来奖励算出工作量证明的矿工。现阶段每一区块有12.5比特币的奖励。 RIPEMD-160: ​ RIPEMD-160是一个160位的加密哈希函数。RIPEMD-160是RIPEMD的加强版，其哈希计算后的结果是160位哈希值。通过RIPEMD-160加密期望能实现在未来的10年或更长时间都是安全的。 中本聪: ​ 中本聪有可能是一个人或一群人的名字。中本聪是比特币的设计者，同时也创建了比特币的最初实现，比特币核心。作为实现的一部分，他们还发明了第一个区块链数据库。在这个过程中，他们是第一个为数字货币解决了双花问题的人或组织。但他们的真实身份仍然未知。 脚本: ​ 比特币使用脚本系统来处理交易。脚本有着类Forth语言、简单、基于堆栈以及从左向右处理的特点。脚本故意限定为非图灵完备的，没有循环计算功能。 ScriptPubKey (公钥脚本): ​ 脚本公钥或者公钥脚本是包含在交易输出中的脚本。该脚本设置了比特币花费需满足的条件。满足条件的数据可以由签名脚本提供。 ScriptSig (签名脚本): ​ 签名脚本是由支付端生成的数据，该数据几乎总是被用作满足公钥脚本的变量。 秘钥 (私钥): ​ 用来解锁对应（钱包）地址的一串字符，例如5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh+。 隔离见证: ​ 隔离见证是比特币协议的一个升级建议，该建议技术创新性地将签名数据从比特币交易中分离出来。隔离见证是一个推荐的软分叉方案；该变化将从技术上使得比特币协议规则更严谨。 SHA: 安全哈希是有NIST（国家标准技术研究所）发布的加密哈希函数族。 软分叉: ​ 软分叉是区块链中的一个短暂分叉，通常是由于矿工在不知道新共识规则的情况下，未对其使用节点进行升级而产生的。不要与分叉、硬分叉、软分叉或者Git分叉混淆。 SPV (简化支付验证): ​ 简化支付验证是在无需下载所有区块的情况对特定交易进行验证的方法。该方法被用在一些比特币轻量级客户端中。 旧块: ​ 旧块是那些被成功挖出，但是没有包含在当前主链上的区块，很有可能是同一高度的其他区块优先扩展了区块链长度导致的。 时间锁: ​ 时间锁是一种阻碍类型，用于严格控制一些比特币只能在将来某个特定时间和区块才能被支出。时间锁在很多比特币合约中起到了显著的作用，包括支付通道和哈希时间锁合约。 交易: ​ 简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并打包至区块中，永久保存在区块链某处。 交易池: 一个无序的交易集合，该集合未在主链的区块中，但其有输入交易。 图灵完备: ​ 在给定足够时间与内存的情况下，如果一个编程语言开发的程序能运行在图灵机上，该编程语言就被称为“图灵完备”的编程语言， UTXO (未花费交易输出): ​ UTXO是未花费交易输出，UTXO可以作为新交易的输入。 钱包: ​ 钱包指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。 WIF (钱包导入格式): ​ 钱包导入格式是一个数据交换格式，设计用于允许导出和导入单个私钥，该私钥通过标志标明是否使用压缩公钥。 "},"ch01.html":{"url":"ch01.html","title":"第一章 介绍","keywords":"","body":"第一章 介绍 1.1什么是比特币？ 比特币一是构成数字货币生态系统基础的概念和技术的总称，二是货币单位，用于在比特币网络中的参与者之间存储和传递价值。比特币用户主要通过在互联网上使用比特币协议进行通信，也可以使用其他传输网络。比特币协议栈是开源软件，可以在各种计算设备（包括笔记本电脑和智能手机）上运行，易于被人接受。 用户通过网络转账比特币，就可以完成常规货币做到的任何事情，包括买卖商品，汇款给别人或组织，或者进行借贷。比特币可以在专门的数字货币交易所购买，出售和兑换其他货币。比特币在某种意义上是互联网货币的完美形式，因为它快速，安全和无地域限制。 与传统货币不同，比特币完全是虚拟的。没有物理硬币，甚至也没有数字货币本身。这种币隐含在从发送方到接收方转账交易中。 在比特币网络中，比特币用户用自己的密钥，证明自己的比特币所有权。凭借这些密钥，他们可以对交易进行签名以解锁自己的比特币，并将其转账给新的所有者实现了消费。密钥通常存储在每个用户的计算机或智能手机上的数字钱包中。拥有可以签署交易的密钥是消费比特币的唯一先决条件，将凭此密钥，用户可以完全控制自己的比特币。 比特币是分布式的点对点系统。因此，没有“中央”服务器或控制节点。比特币是通过称为“挖矿”的过程实现发行的，在处理比特币交易的过程中引入一种竞争机制，这种竞争机制就是参与者都来寻找一个特定数学问题的答案。比特币网络中的任何参与者（即，使用运行完整比特币协议栈的设备的任何人）都可以作为矿工使用其计算机的处理能力来验证和记账交易。平均每隔10分钟，一个比特币矿工如果打包并验证了过去10分钟的交易（即挖出一个新的区块），就能获得这个区块全新的比特币奖励。比特币挖矿从根本上解决了中央银行的货币发行和结算功能，取代了任何中央银行的功能。 比特币协议包括内置的算法，用于调整整个网络的挖矿能力。平均而言，任何时候，无论多少矿工（以及多大处理能力）参与竞争，矿工挖矿的难度都是动态调整的，这样来保证每10分钟都有人可以挖矿成功。比特币协议还规定每4年发行新比特币的比例减少一半，最终实现将发行的比特币的总数限制在2100万个这样的的固定总量。结果是，流通的比特币数量是一个可以预测的曲线，到2140年将达到2100万。由于比特币的发行率是递减的下降，长期来看，比特币货币是通货紧缩。此外，比特币不能通过“印刷”（增发）超过预期发行率的新货币来膨胀。 换句话说，比特币（bitcoin）也是汇集比特币协议，点对点对等网络和分布式计算创新出来的的代名词。比特币货币真的只是这项创新的第一个应用实践。 比特币代表了数十年密码学和分布式系统研究的结果，包括了四个关键创新，比特币将这四个创新以独特和强大的方式组合在一起。 比特币这四个创新包括： 去中心化的点对点对等网络（比特币协议） 公开交易总帐（区块链） 独立验证交易和发行货币的一套规则（共识规则） 通过区块链有效实现全球去中心化共识的机制（工作量证明算法） 作为一名开发人员，我将比特币视为货币互联网，这是一个通过分布式计算传播价值，确保数字资产所有权的网络。比特币还有很多一眼看不到的更多的内容。在本章中，我们将介绍一些主要的概念和术语，必要的软件，并使用比特币进行简单的交易。在接下来的章节中，我们将开始逐级展开比特币中重要的技术层次，并进一步了解比特币网络和协议的内部机制。 比特币之前的数字货币 可行的数字货币的出现与密码学的发展密切相关。使用数字进行交换商品和服务对所有人来说都是一场真正的挑战，这一点都不奇怪。面对数字货币，人们都要问三个基本问题： 我能相信钱是真实的，不是伪造的吗？ 我如何知道数字货币只能花一次（即“双重支付”）吗？ 我如何确定这笔钱属于我，而同时没有人声称这笔钱属于他们？ 纸币发行者通过使用越来越复杂的纸张和印刷技术不断打击假钱。实体纸币很容易解决双重支付问题，因为同一纸币不能同时在两个地方。当然，传统的钱也经常以数字方式存储和传送。在这些情况下，中央权威机构拥有流通货币的全局信息，因此，可以通过清算所有电子交易来处理假币和双重支付问题。对于不能利用秘制油墨技术或全息条码的数字货币，密码学为保障用户财产价值的合法性提供了依据。具体来说，加密数字签名使用户通过对数字资产签名证明该资产的所有权。通过适当的构造，数字签名也可用于解决双重支出问题。 当密码学技术在20世纪80年代末开始变得更广泛理解并被使用时，许多研究人员开始尝试使用密码学技术构建数字货币。这些早期的数字货币项目发行的数字货币，通常由国家法定货币或贵金属（如黄金）来背书。 虽然这些早期的数字货币能够有效运行，但它们是中心化的，因此很容易被政府和黑客攻击。早期的数字货币使用中心化的票据交易所定期处理所有交易，就像传统的银行系统一样。不幸的是，在大多数情况下，这些新兴的数字货币成为了政府担忧的目标，有些是由于诉讼消失了。有些由于母公司突然清盘就失败了。为了防止来自不同方面的干越，无论这些方面是合法的政府或是犯罪分子，数字货币都需要去中心化来避免单节点攻击导致失败。比特币就是一种这样一个去中心化的系统，不受制于任何可能被攻击或损坏的节点或控制节点。 1.2 比特币历史 Bitcoin是在2008年由署名Satoshi Nakamoto的牛人发明的，他出版了一篇题为“Bitcoin：A Peer-to-Peer Electronic Cash System”的文章[1]。 Nakamoto结合了诸如b-money和HashCash等先前的发明，创建了一个完全去中心化的电子现金系统，它不依赖中央机构进行货币发行、结算和验证交易。关键的创新是使用分布式计算系统（称为“工作量证明”算法），每10分钟进行一次全球性的“选举”，从而实现分布式网络达成全网交易状态的共识。这优雅地解决了双重支付的问题，就是避免一个货币单位可以花费两次。以前，双重支付问题是数字货币的弱点，这个问题都是通过中心化的票据交换所清算所有交易来解决的。【比特币矿工打包清算的这一时刻，是中心化的，但其他时候是去中心化的】 比特币网络始于2009年，基于中本聪发布的参考实施指南，之后由许多其他程序员进行修订。为比特币提供安全性和弹性的工作量证明算法（挖矿）的算力以指数级增长，现在已经超过了世界顶级超级计算机的整体处理能力。比特币的总市值有时超过200亿美元，这取决于比特币兑美元的汇率。到目前为止，网络处理最大的交易额是1.5亿美元，可以实现即时传输，无需任何费用处理（只需要少许矿工费）。 Satoshi Nakamoto于2011年4月退出公众视线，将代码和网络的责任托付到一个蓬勃发展的志愿者小组身上。比特币背后的这个人身份仍然未知。然而，中本聪和任何人都没有对比特币系统进行个人控制，这个系统基于完全透明的数学原理，开放源代码和参与者之间的共识持续运行。这项发明本身具有开创性，这种开创性已经延伸到分布式计算，经济学和计量经济学领域。 分布式计算问题的解决方案 Satoshi Nakamoto的发明也是对分布式计算当中一个古老问题的实用和新颖的解决方案，这就是 “拜占庭式将军”问题。这个问题简而言之，就是在不可靠和不可信的网络上，如何通过交换信息协商一个行动方案或一个系统的状态。 Satoshi Nakamoto的解决方案是使用工作量证明，在没有中央信任机构的情况下实现共识，标志着分布式计算的突破，这一方案具有数字货币范围之外的广泛适用性。可以用来在分布式网络上达成一致，比如彩票，资产登记，数字公证等等实现保证公平。 1.3 比特币使用，用户和他们的故事 比特币是古老的“钱”的技术创新。其核心在于方便了人与人之间的价值交换。因此，为了充分了解比特币及其用途，我们将从使用它的人的角度审视它。这里列出的每个人和他们的故事都说明了一个或多个具体的场景。我们将在整本书中看到他们： 北美小额零售店 Alice住在北加州湾区。她听从事技术工作的朋友说过比特币，因此想要尝试使用它。我们将跟随她的故事，了解她学习比特币，购买，以及在帕洛阿尔托的Bob咖啡厅用比特币买一杯咖啡的经过。这个故事将从普通消费者的角度向我们介绍软件，交易所和基本交易。 北美高端零售店 Carol是旧金山的艺术画廊老板。她卖昂贵的绘画换取比特币。这个故事将介绍高端商品店面临的“51％”共识攻击的风险。 离岸合同服务 Bob，帕洛阿尔托的咖啡店老板，正在建立一个新的网站。他与印度的网络开发商Gopesh签约，后者在印度班加罗尔居住。 Gopesh同意使用比特币中支付。这个故事将研究使用比特币进行外包，合同服务和国际电汇。 网上商店 Gabriel是里约热内卢的一个有进取心的小伙，经营着一家小型网店，销售比特币品牌的T恤，咖啡杯和贴纸。Gabriel太年轻了，还没有银行账户，但他的父母鼓励他的创业精神。 慈善捐款 Eugenia是菲律宾儿童慈善机构的负责人。最近她已经知道了比特币，并希望利用它来接触新的国内外捐助者，为她的慈善筹款。她还在学习使用比特币快速将资金分配给被救助者地区的方法。这个故事将展示使用比特币实现跨币种和跨国界的全球筹款活动，以及在慈善组织中使用开放透明的分类账簿。 进出口 Mohammed是迪拜的电子进口商。他正在尝试使用比特币从美国和中国购买电子产品，进口到阿联酋，以加速付款过程。这个故事将展示如何将比特币用于与实体商品相关的大型企业之间的跨国支付。 比特币挖矿 Jing是上海的计算机工程专业学生。他已经使用学习到的工程技术来建立一个“挖矿”矿机，通过挖比特币来提高收入。这个故事将研究比特币的“工业”基础：用于确保比特币网络和发行新货币的专门挖矿设备。 这些故事中的每一个都是基于目前使用比特币的真实人物和实际行业，为解决全球经济问题，创造出新的市场，新的行业和创新的解决方案。 1.4 入门 比特币是一种协议，访问协议的方法是使用同样协议的客户端应用程序。 “比特币钱包”是比特币系统最常见的用户界面，就像Web浏览器是HTTP协议最常用的用户界面一样。有不同形式和品牌的比特币钱包，就像有许多品牌的网络浏览器（例如，Chrome，Safari，Firefox和Internet Explorer）。正如我们最喜欢的浏览器（Mozilla Firefox，Yay！）和我们不喜欢的（Internet Explorer，Yuck！），比特币钱包的质量，性能，安全性，隐私和可靠性也各不相同。还有一个比特币协议的参考实现，其包括被称为“Satoshi客户端”或“Bitcoin Core”的钱包，该钱包是由Satoshi Nakamoto最初编写的客户端衍变而来的。 1.4.1 选择比特币钱包 比特币钱包是比特币生态系统中最活跃的开发的应用之一。这里竞争激烈，有正在开发推出的新的钱包，也有一些钱包已不再积极维护。许多钱包专注于特定的平台或具体用途，还有些更适合初学者，而另外一些钱包则为高级用户提供了更多功能。选择钱包是非常主观的，取决于使用场景和用户的专业知识。因此，不可能推荐一个特定的钱包适合所有人。然而，我们可以根据平台和功能对比特币钱包进行分类，并提供针对不同类型的钱包的一些建议。更好的是，在比特币钱包之间转账是容易，便宜和快速的，所以值得尝试几种不同的钱包，直到找到符合自己需求的钱包。 根据平台，比特币钱包可以分类如下： 桌面钱包 桌面钱包是作为参考实现创建的第一种类型的比特币钱包，许多用户使用桌面钱包为的是实现比特币的基本功能，自主性和控制权。在通用操作系统（如Windows和Mac OS）上运行具有一定的安全隐患，因为这些平台如果配置不当往往不安全。 手机钱包 手机钱包是比特币钱包最常见的类型。在智能手机操作系统（如Apple iOS和Android）上运行，这些钱包通常是新用户的绝佳选择。许多都是为了简单易用而设计的，但也有功能强大的全功能移动钱包。【手机端遭入侵的几率一般更小】 web钱包 Web钱包通过网络浏览器访问，并将用户的钱包存储在由第三方的服务器上。这类似于webmail，因为它完全依赖于第三方服务器。其中一些服务使用在浏览器中运行的客户端（插件）代码进行操作，该代码可以控制用户手中的比特币密钥。然而，大多数人需要在安全和方便性之间进行妥协。在第三方系统上存储大量的比特币是不合适的。 硬件钱包 硬件钱包是在专用硬件上独立操作比特币钱包的设备。它们通过USB与桌面网络浏览器或通过移动设备上的NFC进行操作。通过专用硬件进行所有比特币相关操作，这些钱包被认为是非常安全的，适合存储大量的比特币。 纸钱包 控制比特币的密钥也可以打印出来长期存储。即使可以使用其他材料（木材，金属等），这些也被称为纸钱包。纸钱包提供低技术但高度安全的长期存储比特币的方法。脱机存储也经常被称为冷存储。 对比特币钱包进行分类的另一种方法是通过他们的自主程度以及它们如何与比特币网络进行交互： 全节点客户端 完整客户端或“全节点”是存储比特币交易的全部历史（每个用户每次交易）的客户端，管理用户的钱包，并且可以直接在比特币网络上启动交易。全节点处理协议的所有方面，并可以独立地验证整个区块链和任何交易。全节点客户端消耗大量计算机资源（例如，超过250 GB的磁盘，2 GB的RAM），但可以提供完全自主和独立的交易验证。 轻量级客户端 一个轻量级的客户端，也称为简单支付验证（SPV）客户端，连接到比特币完整节点（前面提到过的），用于访问比特币交易信息，可以在本地存储用户钱包，并独立地创建，验证和传输交易。轻量级客户端与比特币网络直接交互，无需中介。 第三方API客户端 第三方API客户端是通过应用程序编程接口（API）的第三方系统与比特币交互的API客户端，而不是直接连接到比特币网络。 这时钱包可能由用户或第三方服务器存储，但所有交易都需要通过第三方。 结合这些分类，比特币钱包可以分为几个小组，三个最常见的划分是桌面全客户端，移动轻巧钱包和网络第三方钱包。不同类别之间的界限通常是模糊的，许多钱包在多个平台上运行，并且可以以不同的方式与网络进行交互。 为了本书的目的，我们将演示使用各种可下载的比特币客户端，从参考实现（Bitcoin Core）到移动和网络钱包。一些示例将需要使用Bitcoin Core，除了作为完整的客户端，还可以将API暴露给钱包，网络和交易服务。如果您计划探索比特币系统中的编程接口，则需要运行Bitcoin Core或其他客户端（参见第三章）。 1.4.2 快速开始 我们在上一节的故事中介绍的Alice不是技术行家，只听到她的朋友Joe提到过比特币。在聚会上，Joe再次热烈地向周围的人解释了比特币，并提供演示。有趣的是，Alice问她如何开始使用比特币。Joe说，手机钱包最适合新用户，他推荐了他最喜欢的几款钱包。Alice下载Android的“Mycelium”，并将其安装在手机上。 当Alice首次运行Mycelium时，与许多比特币钱包一样，应用程序会为她自动创建一个新的钱包。Alice在她的屏幕上看到钱包，如“Mycelium手机钱包”如下图1-1所示（注意：不要将比特币发送到此示例地址，它将永远丢失）。 图1-1 Mycelium移动钱包 这个屏幕最重要的部分是Alice的比特币地址。 在屏幕上，它显示为一长串字母和数字：1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK。 钱包的比特币地址旁边是一个二维码，这是一种条形码，可由智能手机的相机扫描出同一格式的相同信息。二维码是具有黑色和白色点的图案的正方形。 Alice可以通过点击二维码或接收按钮将比特币地址或二维码复制到剪贴板上。 在大多数钱包中，点击二维码也会放大，以便更容易通过智能手机相机进行扫描。 提示 比特币地址以1、3或bc1开头。像电子邮件地址一样，可以分享给其他比特币用户，然后别人直接将比特币发送到您的钱包。 从安全角度看，比特币地址没有任何敏感信息。 它可以发布到任何地方，而不会危及帐户的安全。 与电子邮件地址不同，可以随意创建新的地址，所有这些地址都会将资金归集到您的钱包。 事实上，现在许多钱包为每个交易自动创建一个新地址，以最大限度地提高隐私。 钱包只是一个地址和解锁资金的密钥的集合。 Alice现在准备好接收资金了。她的钱包应用程序随机生成一个私钥（在第四章中更详细地描述）及其相应的比特币地址。这时，她的比特币地址对于比特币网络来说还是是不知道的，或者说还未注册到比特币系统中。她的比特币地址只是一个数字，对应于一个可以用来控制资金访问的密钥，是由她的钱包独立生成的，不需要调用或注册任何服务。事实上，在大多数钱包中，比特币地址和任何外部可识别的信息（包括用户的身份）之间没有关联。在该地址被引用到比特币总帐的交易中作为接收者之前，这个比特币地址只是在比特币网络中有效的大量可能的地址的一个。一旦与交易相关联，这个地址就成为网络中已知地址的一个。 Alice现在可以开始使用她新的比特币钱包了。 1.4.3 得到你的第一个比特币 新用户的第一个也是最困难的任务是获取一些比特币。与其他外币不同，您还不能在银行或自助机购买比特币。 比特币交易是不可逆转的。大多数电子支付网络（如信用卡，借记卡，PayPal和银行帐户转帐）都是可逆的。对于销售比特币的人来说，这种差异引起了很高的风险，买方在收到比特币后有可能会撤销电子支付，实际上欺骗了卖家。为了减轻这种风险，接受传统电子支付公司通常要求买方进行身份验证和信用验证（可能需要几天或几周时间）。作为新用户，这意味着您不能立即使用信用卡购买比特币。需要有一点耐心和其他思路，但是不要着急。 以下是作为新用户得到比特币的一些方法： 找一个有比特币的朋友，直接从他或她那里买一些。许多比特币用户都是以这种方式开始的。这种方法是最简单的。找到比特币持有者的好办法是参加Meetup.com上列出的本地比特币会议。（在中国根本无需这么麻烦，加微信群，在线支付就可以） 使用分类服务，如localbitcoins.com来查找您所在地区的卖家，场外交易购买比特币。 通过出售产品或服务赚取比特币。如果你是程序员，出售你的编程技巧。如果你是美发师，理发只收比特币。 在你的城市使用比特币ATM。比特币自动取款机是接受现金并将比特币发送到智能手机比特币钱包的机器。使用Coin ATM Radar的在线地图找到靠近您的比特币ATM。【目前中国只有香港有，目前63台（21.01.02）】 使用与您的银行帐户相关联的比特币交易所。现在有很多国家都有数字货币交易所，为买卖双方交易使用当地法币进行交易。实时行情服务（如BitcoinAverage）通常会显示支持法币兑换的比特币交易所列表。 提示 比特币与其他支付系统相比的优点之一是，使用得当，它为用户提供了更多的隐私保护。 单纯获取，持有和支付比特币不要求您向第三方泄露敏感个人身份信息。 但是，如果涉及法币兑换的交易所，那么就需要遵守当地的国家法律和国际法规。 为了用法币兑换比特币，您通常需要提供身份证明和银行信息。 大家有必要知道，一旦比特币地址附加到一个身份，所有与此关联的比特币交易也很容易识别和跟踪。 这是许多用户选择将专用交易账户与其钱包进行分离的一个原因。 Alice听朋友介绍比特币，所以她有一个简单的方法来获得她的第一个比特币。接下来，我们将看看她如何从她的朋友Joe 购买比特币，以及Joe 如何将比特币发送到她的钱包。 1.4.4 查找比特币当前价格 在Alice可以从Joe 购买比特币之前，他们必须同意比特币和美元之间的汇率。这给比特币新人带来了一个共同的问题：“谁设定比特币价格？”简单的答案是价格是由市场决定的。【价格由市场决定，又传递供需信息指导市场。价格与市场是一体的】 比特币与大多数其他货币一样，有浮动汇率。这意味着比特币与任何其他货币的兑换汇率都会根据各个交易市场的供求情况而波动。例如，以美元计算的比特币的“价格”是根据各个市场最近的比特币和美元交易计算的。因此，价格往往每秒钟都会有几次波动。定价服务将汇总来自多个市场的价格，并根据各个市场的交易量加权计算该货币对（例如BTC / USD）的汇率平均数。【加权的价格更合理】 有数百个应用程序和网站可以提供当前的市场汇率。这里有一些最受欢迎的： Bitcoin Average该网站提供每种货币的成交量加权平均数的简单视图。 CoinCap列出了数百种加密货币（包括比特币）的市值和汇率。 Chicago Mercantile Exchange Bitcoin Reference Rate可用于机构和合同的参考汇率，作为CME投资数据的一部分。 除了这些不同的网站和应用程序，大多数比特币钱包都将自动转换比特币和其他货币之间的兑换价格。 在将比特币发送给Alice之前，Joe将使用自己的钱包自动转换价格。 1.4.5 发送和接收比特币 Alice不愿意太冒险，只决定将10美元转换成比特币。她给Joe 10美元现金，打开她的Mycelium钱包应用程序，并选择Receive。这将显示一个二维码与Alice的第一个比特币地址。 Joe然后在他的智能手机钱包上选择发送，并显示一个包含两个输入的屏幕： 收款方的比特币地址 以比特币（BTC）或其当地法币（USD）计价的发送金额 在比特币地址的输入字段中，有一个看起来像二维码的小图标。Joe用他的智能手机相机来扫描条形码，这样就不必输入Alice的比特币收款地址，手动输入费时，而且容易出错。 Joe点击二维码图标并激活智能手机相机，扫描Alice智能手机上显示的二维码。 Joe现在将Alice的比特币地址设置为收件人，输入金额为10美元，他的钱包通过访问在线服务转换为最新汇率。当时的汇率是每个比特币$100美元，所以如Joe的钱包（见图1-2Airbitz移动比特币钱包发送屏幕）截图所示，10美元的价值是0.10比特币（BTC）或100毫比特币（mBTC）。 图1-2. Airbitz移动比特币钱包发送屏幕 Joe然后仔细检查，确保输入了正确的金额，因为转账错误是不可撤销的。经过仔细检查地址和金额后，他按发送（send）键进行转账。 Joe的移动比特币钱包构建了一个交易，从Joe的钱包将0.10 BTC发送给Alice提供的地址，并用Joe的私钥对该交易签名。这就告诉比特币网络，Joe已经授权将这笔钱转移给Alice的新地址。当交易通过点对点网络传输时，它会在比特币网络快速传播。在不到一秒钟内，网络中大多数连接良好的节点都会接收到这笔交易，并且首次看到Alice的地址。 同时，Alice的钱包不断地“倾听”在比特币网络上发布的交易，寻找与她的钱包中的地址相匹配的任何内容。在Joe的钱包发送交易几秒钟后，Alice的钱包将显示它正在接收0.10 BTC。 确认交易 起初，Alice的钱包把与Joe的这笔交易显示为“未确认”。这意味着交易已传播到网络，但尚未记录在比特币交易账簿即区块链中。确认，就是一个交易必须包含在一个区块中，并被添加到区块链，这样的情况平均每10分钟发生一次。在传统的财务术语中，这被称为清算。有关比特币交易的传播，验证和清算（确认）的详细信息，请参阅挖矿章节第十章。 Alice现在可以自豪地称自己拥有了0.10BTC了，她有权花费这些钱了。在下一章中，我们将首先用比特币进行买卖，并更详细地研究交易和传播的底层技术。 参考内容： \"Bitcoin: A Peer-to-Peer Electronic Cash System,\" Satoshi Nakamoto (https://bitcoin.org/bitcoin.pdf). "},"ch02.html":{"url":"ch02.html","title":"第二章 比特币原理","keywords":"","body":"第2章 比特币工作原理 2.1 交易，区块，挖矿和区块链 比特币系统与传统的银行和支付系统不同，是基于去中心化的信任。在比特币中，信任不是通过中央权威机构授权而来，而是通过比特币系统中不同用户相互交互自发达成，这是比特币的一个显著特性。 在本章中，我们将通过较高层面跟踪比特币系统中的一笔交易，观察交易如何通过比特币分布式共识机制变得“可信”，被接受，并且最终记录在区块链，这个区块链就是所有交易的分布式账簿。 随后的章节将深入探讨交易，网络和挖矿背后的技术。 2.1.1 比特币概述 如图2-1所示的概览图中，我们可以看到比特币系统由用户、交易和矿工组成，其中用户主要使用密钥控制钱包，交易会被广播到整个比特币网络，矿工通过算力竞争生产出具备所有节点共识的区块链，这个区块链是一个分布式的公开权威账簿， 包含了比特币网络发生的所有的交易。 本章中的每个示例都基于在比特币网络上进行的实际交易，通过将资金从一个钱包发送到另一个钱包来模拟用户（Joe，Alice，Bob和Gopesh）之间的交互。 我们将使用一个区块链浏览器来显示比特币网络中交易进入区块链的每个步骤。 区块链浏览器是一个类似比特币搜索引擎的Web应用程序，它允许您搜索地址，交易和区块，并查看它们之间的关系和流程。 图2-1 比特币网络概览 常见的区块链数据查询网站包括： ▷Bitcoin Block Explorer ▷BlockCypher Explorer ▷blockchain.info ▷BitPay Insight 以上每一个查询网站都有搜索功能，可以在比特币网络和区块链中通过地址，交易哈希值或区块号，搜索到对应的数据。针对每个交易和区块都会提供一个URL链接，方便做深入研究。 2.1.2 买一杯咖啡 在之前章节里，Alice是一名刚刚获得第一枚比特币的新用户。在【1.4.3 得到你的第一个比特币】中，Alice和她的朋友Joe会面时，用现金换取了比特币。由Joe产生的这笔交易使得Alice的钱包拥有了0.10比特币。现在Alice将第一次使用比特币在加利福尼亚州帕罗奥图的Bob咖啡店买一杯咖啡。 Bob咖啡店刚开始接受比特币支付，销售系统新增加了一个比特币支付选项，价格单上列的是当地货币（美元）的售价，在收银台，顾客可以选择用美元或比特币支付。此时，Alice点了杯咖啡，然后Bob将交易输入到收银机，销售系统按照当前市场汇率把美元总价转换为比特币，然后同时显示两种货币的价格： 总价: $1.50 USD 0.015 BTC Bob说，“总共1.50美元，或0.015 BTC比特币” Bob的销售系统还自动创建一个包含付款请求的二维码。 与简单包含目的比特币地址的二维码不同，当前支付请求是一个包含URL的二维码，它包含有收款地址，付款金额，和像“Bob咖啡”这样的交易描述。这使比特币钱包应用可以预先填好一些特定信息，方便用户识别。你可以用比特币钱包扫描这个二维码来看Alice看到的信息。 图2-2支付请求二维码 提示 尝试用你的钱包扫描这个，看看地址和金额，但不要发送货币。 根据BIP-21的定义，这个付款二维码包括的URL的意思是： bitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA? amount=0.015& label=Bob%27s%20Cafe& message=Purchase%20at%20Bob%27s%20Cafe Components of the URL A bitcoin address: \"1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA\" The payment amount: \"0.015\" A label for the recipient address: \"Bob's Cafe\" A description for the payment: \"Purchase at Bob's Cafe\" Alice用她的智能手机扫描了这个二维码，显示有一笔给Bob咖啡店的0.0150比特币的支付请求，然后她按下发送键授权了这笔支付。在几秒钟时间内（大约与信用卡授权所需时间相同）Bob将会在收银台看到这笔交易，并完成交易。在接下来的章节中，我们将更详细地观察这笔交易，观察Alice的钱包是怎样构建交易，交易又是怎样在网络中广播、怎样被验证，以及Bob在后续交易中怎样消费那笔钱。 注意 从千分之一比特币(1毫比特币）到一亿分之一比特币（1聪比特币），比特币网络可以处理任意小额交易。在本书中，我们将用“比特币”这个术语来表示任意数量的比特币货币，从最小单元（1聪）到可被挖出的所有比特币总数 （21,000,000）。 你可以像下面例1那样使用区块链浏览器站点来检查Alice与Bob's Cafe的交易: 例1-1 查看Alice的交易 点击查看Alice的交易 2.2 比特币交易 简单来说，一笔交易就是告知全网：比特币的持有者已授权把它转帐给其他人。而新持有者可以通过产生另一笔交易，转账给另外的人，依此类推形成一条所有权的链。 2.2.1 交易输入输出 交易就像复式记账法账簿中的行。简单来说，每一笔交易包含一个或多个“输入”，就像比特币账户的借方。这笔交易的另一面，有一个或多个“输出”，就像比特币账户的贷方。这些输入和输出的总额（借方和贷方）不需要相等。相反，当输出加起来略少于输入数量时，两者的差额就代表了一笔隐含的“矿工费”，这笔矿工费由成功打包交易到区块链账簿的矿工收取。如图2-3描述的是一笔比特币交易作为账簿中的一个条目。 交易也包含了每一笔被转账的比特币（输入）的所有权证明，它以所有者的数字签名形式存在，并可以被任何人独立验证。在比特币术语中，“消费”指的是签名一笔交易：将以前交易的比特币转账给比特币地址所标识的新所有者。 图2-3交易就像复式记账 2.2.2 交易链 Alice支付Bob咖啡时使用一笔之前的交易作为输入。在以前的章节中，Alice从她朋友Joe那里用现金换了点比特币。那笔交易创建了被Alice的密钥锁定的比特币。在她支付Bob咖啡店的新交易中使用了之前的交易作为输入，输出是支付咖啡的金额和多余部分的找零。交易形成了一条链，最近交易的输入对应以前交易的输出。Alice用密钥签名解锁了之前交易的输出，从而向比特币网络证明她拥有这笔钱。她将买咖啡的这笔支付到Bob的地址上，明确指明要求是Bob签名才能消费这笔钱，否则就“阻止”那笔输出。这就实现了在Alice和Bob之间价值转移。下图展示了从Joe到Alice再到Bob的交易链。 图2-4 交易链中一笔交易输出就是另一笔交易的输入 2.2.3 找零 许多比特币交易都会包括新所有者的地址（买方地址）和当前所有者的地址（称为找零地址）的输出。这是因为交易输入，就像纸币那样能够不能被再分割。如果您在商店购买了5美元的商品，但是使用20美元的美金来支付商品，会收到15美元的找零。相同的概念适用于比特币交易输入。如果您购买了一个价格为5比特币的商品，但是你的输入中只有20比特币这一项，那么您需要产生两个输出：一个5个比特币的输出发送给店主，另一个15比特币的输出返回自己作为找零（减去任何适用的交易费用）。重要的是，出于隐私的原因，找零地址不必与输入时提供的地址相同，通常是所有者钱包中的新地址。 不同的钱包可以在合并所有输入，用来匹配自己的付款金额时使用不同的策略。它们可能会聚合许多小输入，或者使用等于或大于所需付款的输入。除非钱包中的输入，刚好汇总起来与所需付款（加上交易费用）完全相等，否则钱包一定会产生一些找零。这与人们如何处理现金非常相似。如果你总是用钱包中的最大面额支付时，那么钱包中的零钱就会越来越多。如果你只使用零钱，整钱就会越来越多。人们总是无意识地在这两个极端之间找到平衡，而比特币钱包开发商也力图实现这种平衡。 总的来讲，交易是将钱从交易输入移至输出。输入通常是前一笔交易的输出的引用，表示价值从何而来。交易输出将约定金额发送到新的所有者的比特币地址，并将找零输出返回原来所有者的地址。 一笔交易的输出可以被当做另一笔新交易的输入，这样随着钱从一个地址被移动到另一个地址，就形成了一条所有权链（如图2-4）。 2.2.4 常见的交易形式 最常见的交易形式是从一个地址到另一个地址的简单支付，还包含给支付者的“找零”。这类交易有一个输入和两个输出，如图2-5所示: 图2-5 最常见的交易 另一种常见的交易形式是归集多个输入到一个输出（如图2-6）的模式。这相当于现实生活中将很多硬币和纸币零钱兑换为一个大额面钞。像这样的交易由钱包应用产生，来整理在支付过程收到的许多小额的找零。 图2-6 归集资金的交易 最后，另一种在比特币账簿中常见的交易形式是将一个输入分配给多个输出，即多个接收者（如图2-7）的交易。这类交易有时被商业机构用作分配资金，例如给多个雇员发工资的情形。 图2-7 分散资金的交易 2.3 交易的构建 Alice的钱包应用知道如何选取合适的输入匹配Alice所创建的交易金额。Alice只需要指定目标地址和金额，其余的细节钱包应用会在后台自动完成。很重要的一点是，钱包应用甚至可以在完全离线时建立交易。就像在家里写张支票， 之后放到信封发给银行一样，比特币交易建立和签名时不用连接比特币网络。只有在执行交易时才需要将交易发送到网络。 2.3.1 获取正确的输入 Alice的钱包应用首先会找到一些足够支付给Bob所需金额的输入。大多数钱包应用都会跟踪着的属于钱包的地址的所有可用输出。因此Alice的钱包会包含她用现金从Joe那里购买的比特币的交易输出副本（参见【1.4.3 得到你的第一个比特币】）。全节点客户端含有整个区块链中所有交易的所有未消费输出副本。这使得钱包既能拿这些输出构建交易，又能在收到新交易时很快地验证其输入是否正确。但是，全节点客户端占太大的硬盘空间，所以大多数钱包使用轻量级客户端，只保存用户自己的未消费输出。 如果钱包客户端没有未花费交易输出的副本，它可以使用不同的服务商提供的各种API从比特币网络中拿到这一交易信息，或者通过全节点的API调用查询这些信息。例2-1展示了一个API的请求，对特定URL发起HTTP GET命令。这个URL会返回一个地址的所有未花费交易输出，提供给需要这些信息的任何应用。 我们用简单的HTTP命令行客户端 cURL来获得这个响应数据。 例2-1 查找Alice的比特币地址所有的未消费的输出 $ curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK { \"unspent_outputs\":[ { \"tx_hash\":\"186f9f998a5...2836dd734d2804fe65fa35779\", \"tx_index\":104810202, \"tx_output_n\": 0, \"script\":\"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac\", \"value\": 10000000, \"value_hex\": \"00989680\", \"confirmations\":0 } ] } 例2-2的响应数据显示了Alice的地址 1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK 上面有一个未花费输出（还未被消费）。这个响应包含对这笔交易的引用，从Joe那里转过来的未消费输出就包含在这个交易里面，它的价值是一千万聪 （satoshi），即 0.10比特币。有了这个信息，Alice的钱包应用就可以创建新的交易将钱转账到新地址。 提示 点击这里 查看Joe和Alice间的交易信息。 如你所见，Alice的钱包中的未花费交易输出中有足够的比特币支付一杯咖啡。假如不够的话，Alice的钱包应用就不得不搜寻一些小的未花费输出，像是从一个存钱罐里找硬币一样，直到找到足够支付咖啡的金额。在两种情境下，可能都需要找回零钱，而这些找零也会是钱包所创建的交易的输出的组成部分。会在下一节有所描述。 2.3.2 创建交易输出 交易的输出是以脚本的形式创建的，这个脚本设置了对兑换金额的“产权限制”，只能引入这个脚本的一个解后才能解除预置实现提款。简单点说就是，Alice的交易输出会包含一个脚本，这个脚本说 “谁能出示一个对应Bob地址对应密钥的签名，这个输出就支付给谁”。因为只有Bob的钱包的私钥可以匹配这个地址，所以只有Bob的钱包可以提供这个签名以兑换这笔输出。因此Alice 会需要Bob的签名来限制输出的使用。 这个交易还会包含第二个输出。因为Alice的未花费交易输出金额是0.10比特币，对0.015 比特币一杯的咖啡来说太多了，需要找零给Alice 0.085比特币。Alice钱包创建给她的找零与付给Bob的支付在同一个交易里面。可以说，Alice的钱包将她的金额分成了两个支付：一个给Bob，一个给自己。她可以在以后的交易里继续消费这笔找零输出。 最后，为了让这笔交易尽快地被网络处理，Alice的钱包会多付一小笔费用。这个不是明显地包含在交易中的；而是通过输入和输出的差值所隐含的。如果Alice创建找零时只找 0.0845比特币，而不是 0.085比特币的话，就会有 0.0005比特币（50万聪） 。两笔输出加起来小于 0.10，所以这个 0.10 比特币的输入就没有被完整的消费了。这个差值会就被矿工收取当作交易费，作为矿工将交易放到区块里，最终打包到区块链帐薄中的费用。 这个交易的结果信息可以用区块链数据查询站点看到，如图2-8所示。 图2-8 Alice和Bob咖啡店的交易 提示点击这里查看Alice支付Bob咖啡的交易的信息 2.3.3 将交易加入到总账簿 这个被Alice钱包应用创建的交易大小为258字节，包含了确认资金所有权和分配给新所有者所需要的全部信息。现在，这个交易必须要被传送到比特币网络中，最终成为分布式账簿（区块链）的一部分。在下一节里，我们来看下一个交易如何成为新区块的一部分， 以及区块是如何被挖矿构建的。最后，我们会看看新区块被加进区块链后，随着更多区块的添加，信任度如何也随之增加的。 2.3.3.1 交易的传送 因为这个交易包含处理所需的所有信息，所以这个交易传送到比特币网络的位置和方式就无关紧要了。比特币网络是由参与的比特币客户端联接其他更多比特币客户端组成的P2P网络。比特币网络的目的是将交易和区块传播给所有参与者。 2.3.3.2 如何传播 任何遵守比特币协议，参与比特币网络的任何系统（例如服务器，桌面应用程序或钱包）都称为比特币节点。Alice的钱包应用可以发送新的交易给任意一个已联接到互联网的比特币客户端，不论其是由有线网络、WiFi、还是通过手机联接的。她的钱包不必直接连着Bob的比特币钱包，她也不必使用咖啡厅提供的网络，虽然这两者都是可能的。任何比特币网络节点（其它客户端）收到一个之前没见过的有效交易时会立刻将它转发给它连接的其它节点。 因此，这个交易迅速地从P2P网络中传播开来，几秒内就能到达大多数节点。 2.3.3.3 Bob的视角 如果Bob的比特币钱包应用是直接连接Alice的钱包应用的话，Bob的钱包应用也许就是第一个收到这个交易的节点。然而，即使Alice的交易是从通过其它节点发过来的，一样可以在几秒钟内到达Bob钱包应用。Bob的钱包会立即确认 Alice的交易是一笔收入，因为它包含能用Bob的私钥兑换的输出。Bob的钱包应用也能够独立地用之前未消费输入来确认这个交易是正确构建的，并且由于包含足够交易费，因此会被下一个区块包含进去。这时Bob风险非常小，因为这个交易会很快被加到区块且被确认。 提示 一个对比特币交易的常见误解是它们必须要等10分钟后新区块产生才被确认，或等60分钟以得到六次确认后才是有效的。虽然这些确认可以确保交易已被整个网络接受，但对于像一杯咖啡这样的小额商品来说就没有必要等待那么长时间了。一个商家可以免确认来接受比特币小额支付。这样做的风险不比没有身份证或签名的信用卡付款的风险更大，而后者是现在商家常做的事情。 2.4 比特币挖矿 Alice的这笔交易现在已经在比特币网络上传播开来。但只有被挖矿节点验证且加到一个区块中之后，这个交易才会成为这个共享账簿（区块链）的一部分。关于挖矿的详细描述请见第10章。比特币系统的信任是建立在计算的基础上的。交易被打包在一起放进区块中时需要极大的计算量来证明，但是验证这个证明只需少量计算就可以。 挖矿在比特币系统中有两个重要作用： ▷ 挖矿节点依据比特币的共识规则验证所有交易。 因此，挖矿过程会拒绝无效或不合规交易，以此保障比特币交易的安全性。 ▷ 挖矿在构建区块时会创造新的比特币，就像中央银行发行新的纸币一样。每个区块创造的比特币数量是固定的，并且会逐渐减少。 挖矿在成本和报酬之间取得了良好的平衡。 挖矿耗费电力来解决数学问题。 矿工挖矿成功将会获得新的比特币和交易费作为奖励。 但是，只有其他矿工正确验证了所有的交易，符合共识规则的要求，才能拿到奖励。 这种微妙的平衡为没有中央权威机构的比特币提供安全保障。 描述挖矿最好将其类比为一个巨大的多人数独游戏。一旦有人发现正解之后，这个数独游戏会自动重置，并调整难度，使得游戏每次都需要大约10分钟才能解决。想象一个有好几千行和列的大型数独游戏。如果给你一个已经完成的数独谜底，你可以很快地验证它。然而，如果这个数独只有几个方格里有数字其余方格都为空，就会花费非常长的时间才能解决。这个数独游戏的困难度可以通过改变其大小（更多或更少行列）来调整，但即使非常大时验证结果也是相当容易的。比特币中的 \"谜题\" 是基于哈希算法的，有类似的特点：不对称，解起来困难而验证很容易，而且它的困难度可以调整。 在【1.3 比特币使用，用户和他们的故事】中，我们提到了一个叫Jing的上海创业者。Jing在比特币网络中扮演了一个矿工的角色。大概每10分钟，Jing和其他上千个矿工一起开始一场全球竞赛，目的就是对一个区块的交易寻找正解。寻找这个解，也被称为工作量证明，整个网络需要进行每秒亿万次哈希计算。这个工作量证明算法指的用SHA256算法重复不断对区块头和一个随机数字进行哈希计算，直到出现一个和预设目标值相匹配的解。第一个找到这个解的矿工就是赢得这局竞赛，并会将此区块发布到区块链中。 Jing从2010年开始挖矿，当时他使用一个非常快的桌面电脑来为新区块寻找正解。随着更多的矿工加入比特币网络中， 寻找谜题正解的难度迅速增大。不久，Jing和其他矿工升级成更专业的硬件，比如游戏桌面电脑或更专业的高端独立图像处理单元芯片（即显卡GPU）。在写这本书的时候，解题已经变得极其困难，只有使用专用集成电路（ASIC），就是几百种挖矿算法集成在一个单硅芯片上并行计算进行挖矿才会盈利。Jing的公司同时加入了一个矿池，这类似彩票奖池，能够让多个矿工共享算力和回报。Jing现在运行一个矿场，有几千个ASIC矿机每天24小时不间断地挖矿。他卖掉一些挖矿得到的比特币来支付电费，赚取利润获得收益。 2.5 区块中的挖矿交易记录 新交易不断地从用户钱包和其他应用流入比特币网络。当比特币网络上的节点看到这些交易时，会先将它们放到节点自行维护的一个临时的未经验证的交易池中。当矿工构建一个新区块时， 会将这些交易从这个交易池中拿出来放到一个新区块中，然后通过尝试解决一个难题（也叫工作量证明）以证明这个新区块的有效性。挖矿过程的细节会在【第10章 挖矿和共识】中详加描述。 这些交易被加进新区块时，以交易费用和其它的一些规则进行排序。矿工一旦从网络上收到一个新区块， 就知道自己在这个区块上的解题竞赛已经输掉了，然后马上开始下一个新区块的挖矿。它会立刻将一些交易和最新那个区块的数字指纹放在一起开始构建下一个新区块，并开始工作量证明计算。每个矿工会在他的区块中包含一个特殊的交易，将新生成的比特币（当前每区块为6.25比特币）作为矿工费支付到他自己的比特币地址，再加上块中所有交易的交易费用的总和作为自己的报酬。如果他找到了使得新区块有效的解法，他就会得到这笔报酬，因为这个新区块被加入到了区块链总账中，他添加的这笔报酬交易也会变成可消费的。 参与矿池挖矿的Jing设置了他的软件，构建新区块时会将报酬地址设为整个矿池的地址。然后根据各自上一轮贡献的工作量将所得的报酬分给Jing和其他参与矿池挖矿的矿工。 Alice的交易被网络拿到后放进未验证交易池中。一旦被挖矿软件验证，它就被包含在由Jing的矿池生成的新区块（称为候选块）中。参与该矿池的所有矿工立即开始计算候选块的工作证明。大约在Alice的钱包将这个交易发送出来五分钟后，Jing的ASIC矿机发现了新区块的正解并将这个新区块发布到网络上，一旦结果被其它矿机验证成功，它们就会立即开始下一个新区块的竞赛。 Jing的ASIC矿机发现了新区块的正解并将之发布为第277,316号区块，包含420个交易，包括Alice的交易。将Alice交易包含在区块中就算做对该交易的一次\"确认\"。 提示 你可以查看包含Alice交易记录的这个区块的信息。 大约19分钟后，第277,317号新区块诞生在另一个挖矿节点中。因为这个新区块是在包含Alice交易的第277,316号区块的上层（栈），在这个区块的基础上增加了更多的计算，因此就加强了这些交易的可信度。基于这个区块每产生一个新区块，对Alice这个交易来说就会增加了一次\"确认\"。当区块一个个堆上来时，这个交易被推翻的难度就会指数级增加，因此它在网络中越来越被信任。 在图2-9中，我们可以看到包含Alice的交易的第277,316号区块。在它之下有277,316个区块（包括0号区块），像链子 一样一个连着一个（区块链），一直连到0号区块，即创世区块。随着时间变长，这个区块链的高度也随之增长，每个区块和整个区块链的计算难度也随之增加。包含Alice的交易的区块后面形成的新区块使得信任度进一步增加，因为他们叠加了更多的计算在这个越来越长的链上。按惯例来说，一个区块获得六次以上“确认”时就被认为是不可撤销的了，因为要撤销和重建六个区块需要巨量的计算。在第10章我们会详细描述挖矿和信任建立的过程。 图2-9 Alice的交易包括在区块277316中 2.6 花费这笔交易 既然Alice的这笔交易已经成为区块的一部分被嵌入到了区块链中，它就成为了整个分布式比特币账簿的一部分，并对所有比特币客户端应用可见。每个比特币客户端都能独立地验证这笔交易是有效且可消费的。全节点客户端可以追溯钱款的来源，从第一次有比特币在区块里生成的那一刻开始，按交易与交易间的关系顺藤摸瓜，直到Bob的交易地址。轻量级客户端通过确认一个交易在区块链中，且在它后面有几个新区块来判定一个支付是否有效。这种方式叫做简易支付验证（参 见“简易支付验证（SPV）节点”）。 Bob现在可以将此交易和其它交易的结果信息作为输入，创建新的所有权为其他人的交易。这样就实现了对此交易的消费。举个例子，Bob可以用Alice支付咖啡的比特币转账给承包商或供应商以支付相应费用。大多数情况下，Bob用的比特币客户端会将多个小额支付聚合成一个大的支付，也许会将一整天的比特币收入归集成一个交易。这样会将多个支付合成到咖啡店财务账户的一个单独地址。图2-10为归集交易示例。 当Bob花费从Alice和其他顾客那里赚得的比特币时，他就扩展了比特币的交易链条。而这个链条会被加到整个区块链账簿，使所有人知晓并信任。我们假定Bob向在邦加罗尔的网站设计师Gopesh支付一个新网页的设计费用。那么区块交易链如图2-10所示。 图2-10 Alice的交易成为 Joe 和 Gopesh交易的一部分 在本章中，我们看到了交易如何被构建为一个链，并将价值从一个所有者转移到另一个所有者。 我们还追踪了Alice的交易，从她的钱包中创建交易，通过比特币网络被传输，以及最终被矿工记录在区块链。 在本书的其余部分，我们将研究钱包，地址，签名，交易，网络和挖矿等背后的具体技术。 "},"ch03.html":{"url":"ch03.html","title":"第三章 比特币核心","keywords":"","body":"第三章 Bitcoin Core客户端：参考实现 Bitcoin是一个开源项目，源代码使用开放（MIT）授权，可免费下载使用。 开源不仅意味着可自由使用，还意味着比特币是由一个开源社区志愿者开发的。 最初这个社区只有中本聪，到2016年，比特币的源代码贡献者超过400个，大约十几位开发人员几乎全职工作，还有几十名兼职开发人员。任何人都可以为代码做出贡献 - 包括你！ 当初中本聪是先开发了比特币软件，之后才完成了大名鼎鼎的[satoshi_whitepaper]白皮书。 中本聪考虑是发布白皮书之前先确保系统能够正常工作。比特币的第一个软件，就叫做“比特币（Bitcoin）”或者“Satoshi客户端”，到现在已经进行了大量的修改和改进了。为了与其他软件区别，这个软件后来演变成所谓的Bitcoin Core（比特币核心）。Bitcoin Core是比特币系统的参考实现，这意味着它是所有技术实现的权威参考。Bitcoin Core实现了比特币的所有方面，包括钱包，交易和区块验证引擎，以及P2P网络中的全节点。 警示 即使Bitcoin Core包含钱包的参考实现，但并不建议作为用户或应用程序的生产钱包。建议应用程序开发人员使用现代标准（如BIP-39和BIP-32）开发钱包（请参阅【5.1.4 种子和助记词（BIP-39）】和【5.1.3 分层确定性钱包（HD Wallets (BIP-32/BIP-44)）】章节）。BIP就是比特币改进提案（Bitcoin Improvement Proposal）。 下图为Bitcoin Core的架构。 图3-1 比特币核心架构（来源Eric Lombrozo） 3.1 比特币开发环境 对于开发人员，需要使用所有工具，库和支持软件来配置开发环境，编写比特币应用程序。 这一章涉及的技术细节较深，我们将逐步介绍该过程。 如果你觉得过于繁琐（并且缺乏开发环境），建议你跳到下一章，技术性会浅显一些。 3.2 从源码编译比特币核心 Bitcoin Core的源代码可以下载ZIP格式，也可以从GitHub克隆官方的源代码库。 在GitHub比特币页面GitHub bitcoin page上，选择“下载ZIP”。 或者，使用git命令行在系统上创建源代码的本地副本。 提示 在本章的许多例子中，我们将使用操作系统的命令行界面（也称为“shell”），通过“terminal”应用程序访问。 shell将显示一个提示符，需要输入命令，并且shell会响应一些文本和一个新的提示符。 提示符可能在不同系统上看起来不同，但在以下示例中，都用符号$表示。在后面的示例中，看到$符号紧跟着有文本时，不要键入$符号，而是直接输入后面的命令，然后按ENTER键执行该命令。在示例中，每个命令下面的行是操作系统对该命令的响应。当你看到下一个$符号作为前缀时，应该继续输入之后的命令，一直重复这个过程。 在本例中，我们使用git命令来创建源代码的本地副本（“clone”）： $ git clone https://github.com/bitcoin/bitcoin.git Cloning into 'bitcoin'... remote: Counting objects: 66193, done. remote: Total 66193 (delta 0), reused 0 (delta 0), pack-reused 66193 Receiving objects: 100% (66193/66193), 63.39 MiB | 574.00 KiB/s, done. Resolving deltas: 100% (48395/48395), done. Checking connectivity... done. $ 提示 Git是最广泛使用的分布式版本控制系统，是软件开发人员最重要的工具之一。 如果操作系统还未安装，需要先安装git命令行或git的图形界面。 当git克隆操作完成后，当前目录（如果是bitcoin）就有源代码存储库的完整本地副本。 在提示符下键入“cd bitcoin”，进入此目录： $ cd bitcoin 3.2.1 选择Bitcoin Core版本 默认情况下，本地副本将与最新的代码同步，但是最新版本可能是不稳定的或者是Beta版。 所以在编译代码前，先查看发布标签tag，选择一个特定的版本。 这将使本地副本与关键字标签所标识的代码库的特定快照同步。 开发人员使用标签tag来标记特定版本号的代码。 首先，要找到可用的标签，我们使用git tag命令： $ git tag v0.1.5 v0.1.6test1 v0.10.0 ... v0.11.2 v0.11.2rc1 v0.12.0rc1 v0.12.0rc2 ... tag列表显示所有发布的比特币版本。根据惯例，用于测试的发布候选版本具有后缀“rc”。可以在生产系统上运行的稳定版本没有后缀。从上面的列表中，选择最高版本的版本，在编写时是v0.11.2。要使本地代码与此版本同步，请使用git checkout命令： $ git checkout v0.11.2 HEAD is now at 7e27892... Merge pull request #6975 输入命令git status来确认检查到了选定的版本： $ git status HEAD detached at v0.11.2 nothing to commit, working directory clean 3.2.2 配置构建Bitcoin Core 源代码中包括帮助文档，可以在许多文件中找到。在提示符下输入“more README.md”，可以查看bitcoin目录中最主要的文档README.md的内容，使用空格键可翻页。在本章中，我们将在Linux上部署命令行比特币客户端，也称为bitcoind。在系统中查看编译bitcoind命令行客户端的说明，方法是输入“more doc / build-unix.md” 。doc目录中还有macOS和Windows的文档，分别为build-osx.md或build-windows.md。 仔细查看文档第一部分提到的依赖库，在开始构建比特币客户端之前这些库必须存在。如果缺少这些库，构建过程会提示出错，并失败。如果构建失败提示是缺少这些依赖库，那么就必须再安装它，然后从刚才提示出错的地方重新开始构建。这些依赖库都安装之后，可以使用autogen.sh脚本生成一组脚本来启动构建过程。 注意 Bitcoin Core 构建过程已经从0.9开始更改为使用autogen / configure / make系统。 0.9之前的旧版本使用简单的Makefile，与以下示例的方法略有不同。 建议按照版本的说明进行操作。 在0.9中引入的autogen / configure / make用于之后的版本构建过程，下面演示的示例就是这个过程。 $ ./autogen.sh ... glibtoolize: copying file 'build-aux/m4/libtool.m4' glibtoolize: copying file 'build-aux/m4/ltoptions.m4' glibtoolize: copying file 'build-aux/m4/ltsugar.m4' glibtoolize: copying file 'build-aux/m4/ltversion.m4' ... configure.ac:10: installing 'build-aux/compile' configure.ac:5: installing 'build-aux/config.guess' configure.ac:5: installing 'build-aux/config.sub' configure.ac:9: installing 'build-aux/install-sh' configure.ac:9: installing 'build-aux/missing' Makefile.am: installing 'build-aux/depcomp' ... autogen.sh脚本创建一组自动配置脚本，它会询问系统以发现正确的设置，并确保依赖库已经完整。 其中最重要的是配置脚本，它提供了许多自定义构建过程的可选选项。输入“./configure --help”查看各种选项： $ ./configure --help `configure' configures Bitcoin Core 0.11.2 to adapt to many kinds of systems. Usage: ./configure [OPTION]... [VAR=VALUE]... ... Optional Features: --disable-option-checking ignore unrecognized --enable/--with options --disable-FEATURE do not include FEATURE (same as --enable-FEATURE=no) --enable-FEATURE[=ARG] include FEATURE [ARG=yes] --enable-wallet enable wallet (default is yes) --with-gui[=no|qt4|qt5|auto] ... 帮助文档中可以看到，配置脚本允许使用--enable-FEATURE和--disable-FEATURE标志来启用或禁用bitcoind的某些功能，使用该命令是把FEATURE替换为功能名称。 在本章中，我们将构建所有默认功能的bitcoind客户端。 我们不会使用配置标志调整功能，但是需要了解客户端是能够实现可选功能的。如果您处于学术环境中，计算机实验室的限制可能需要把应用程序安装在当前账户的主目录中（例如，使用--prefix = $ HOME）。 以下这些选项，可以覆盖configure脚本的默认行为： --prefix=$HOME 这将覆盖生成的可执行文件的默认安装位置（默认是/ usr / local /）。 使用$HOME将所有内容放在主目录，也可以放在其他路径。 --disable-wallet 这用于禁用钱包功能。 --with-incompatible-bdb 如果您正在构建钱包，允许使用不兼容的Berkeley DB库版本。 --with-gui=no 不构建图形用户界面，图形界面是需要Qt库的。 这只生成服务器和命令行客户端。 接下来，运行configure脚本来自动发现所有必需的库，并创建一个自定义的构建脚本： $ ./configure checking build system type... x86_64-unknown-linux-gnu checking host system type... x86_64-unknown-linux-gnu checking for a BSD-compatible install... /usr/bin/install -c checking whether build environment is sane... yes checking for a thread-safe mkdir -p... /bin/mkdir -p checking for gawk... gawk checking whether make sets $(MAKE)... yes ... [many pages of configuration tests follow] ... $ 如果一切顺利，configure命令运行完成后，会自动一个创建可定制的构建脚本。可以使用构建脚本编译bitcoind。如果有缺失的库或是错误，configure命令将会提示出错。出现错误，一般都是缺少库或是有不兼容的库。这需要重新查看文档，确认是否安装所有依赖库。然后再次运行configure，看看错误是否消失。 3.2.3 构建Bitcoin Core可执行文件 下一步，开始编译源代码，这个过程根据CPU处理能力和内存大小，但一般可能需要1个小时完成。编译的过程中，应该过几秒或是几分钟看一下输出结果。如果出现了问题，就会看到错误。如果中断了，编译的过程可以在任何时候恢复。输入make命令就可以开始编译了： $ make Making all in src CXX crypto/libbitcoinconsensus_la-hmac_sha512.lo CXX crypto/libbitcoinconsensus_la-ripemd160.lo CXX crypto/libbitcoinconsensus_la-sha1.lo CXX crypto/libbitcoinconsensus_la-sha256.lo CXX crypto/libbitcoinconsensus_la-sha512.lo CXX libbitcoinconsensus_la-hash.lo CXX primitives/libbitcoinconsensus_la-transaction.lo CXX libbitcoinconsensus_la-pubkey.lo CXX script/libbitcoinconsensus_la-bitcoinconsensus.lo CXX script/libbitcoinconsensus_la-interpreter.lo [... many more compilation messages follow ...] $ 如果CPU是多核，那么需要设置并行编译作业需要的核数，比如输入make -j 2会使用两个核。如果一切顺利，bitcoind就编译完成了。可以使用make check命令运行单元测试包，检查链接的库没有发生中断。最后一步就是sudo make install 命令，安装 bitcoind 可执行文件，可能会提示您输入用户密码，因为这一步需要管理员权限： $ make check && sudo make install Password: Making install in src ../build-aux/install-sh -c -d '/usr/local/lib' libtool: install: /usr/bin/install -c bitcoind /usr/local/bin/bitcoind libtool: install: /usr/bin/install -c bitcoin-cli /usr/local/bin/bitcoin-cli libtool: install: /usr/bin/install -c bitcoin-tx /usr/local/bin/bitcoin-tx ... $ bitcoind 默认的安装位置是/usr/local/bin。查询下面这两个可执行文件的路径，可以确认bitcoin是否安装成功。 $ which bitcoind /usr/local/bin/bitcoind $ which bitcoin-cli /usr/local/bin/bitcoin-cli 3.3 运行Bitcoin Core节点 比特币的点对点网络由网络中的“节点”组成，主要由志愿者和一些构建比特币应用程序的商业机构运行。 那些运行的比特币节点具有直接和权威的比特币区块链视图，并且具有所有交易的本地副本，自己可以独立验证。 自己运行节点，就不必依赖任何第三方来验证交易。 此外，自己运行比特币节点，也可以使比特币网络更加健壮，为比特币网络做出贡献。 但是，运行节点需要足够资源来处理所有比特币交易，而且不能停机断网。 如果选择索引所有交易并保留完整区块链副本，还需要足够的磁盘空间和RAM。 2018年初，全索引节点需要2 GB的RAM和160 GB的磁盘空间，才能满足空间增长需求（参考 https://blockchain.info/charts/blocks-size)。 比特币节点还传输和接收比特币交易和区块，消耗互联网带宽。 如果互联网连接有带宽上限或按流量计费，建议就不要运行比特币全节点，或者用限制其带宽的方式运行（请参阅例3-2)。 提示 Bitcoin Core默认情况下保留区块链的完整副本，包括从2009年比特币成立以来发生的每一笔交易。此数据集的大小为几百GB，下载可能需要几天或几周，具体取决于 CPU和互联网带宽。完整区块链数据集被下载完成之前，Bitcoin Core将无法处理交易或更新帐户余额。 因此确保足够的磁盘空间，带宽和时间来完成初始同步。 也可以配置Bitcoin Core通过丢弃旧区块来减少区块链的大小（请参阅例3-2），但是在丢弃数据之前仍将下载整个数据集。 尽管有这些资源需求，但仍有成千上万的志愿者运行比特币节点。 有些节点在简单的系统上运行，就像树莓派Raspberry Pi（35美元的计算机，一副扑克牌大小）。 许多志愿者在租用的服务器类Linux系统上运行比特币节点。 虚拟专用服务器（VPS）或云计算服务器实例也可用于运行比特币节点。 这些服务器每月租金大约25至50美元。 为什么要运行节点？ 以下是一些最常见的原因： 如果是开发比特币软件，需要比特币节点进行可编程接口（API）访问网络和区块链。 如果是开发根据比特币共识规则验证交易的应用程序。 比特币软件公司通常运行多个节点。 如果只是想支持比特币。 那么运行节点可以使网络更加健壮，提供更多的钱包，更多的用户和更多的交易。 如果不想依赖任何第三方来处理或验证自己的交易。 如果阅读本书并对开发比特币软件感兴趣，那么也应该运行自己的节点。 3.3.1 配置Bitcoin Core节点 Bitcoin Core每次启动都会在查找数据文件目录下的配置文件（文件名一般是bitcoin.conf）。这一部分先了解配置文件的不同选项，建立配置文件。要找到配置文件的位置，在“terminal”中运行bitcoind -printtoconsole命令，命令输出的前几行就能看到。 $ bitcoind -printtoconsole Bitcoin version v0.15.0 Using the 'standard' SHA256 implementation Using data directory /home/ubuntu/.bitcoin/ Using config file /home/ubuntu/.bitcoin/bitcoin.conf ... [a lot more debug output] ... 找到配置文件的位置后，可以使用Ctrl-C退出程序。一般来说，配置文件位于当前用户的主目录的.bitcoin数据目录下。系统不会自动创建这个文件的，需要手动从下面例3的内容复制粘贴过来。也可以使用自己的默认编辑器手动创建进行修改。 Bitcoin Core还提供了100多个配置选项，可以修改网络节点的行为，区块链的存储以及操作的其他方面。 要查看这些选项的列表，运行bitcoind --help命令： $ bitcoind --help Bitcoin Core Daemon version v0.15.0 Usage: bitcoind [options] Start Bitcoin Core Daemon Options: -? Print this help message and exit -version Print version and exit -alertnotify= Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message) ... [many more options] ... -rpcthreads= Set the number of threads to service RPC calls (default: 4) 以下是您可以在配置文件中设置的一些最重要的选项，也可以作为bitcoind的命令行参数： alertnotify 运行指定的命令或脚本，通常通过电子邮件将紧急警报发送给该节点的所有者。 conf 配置文件的替代位置。 只作为bitcoind的命令行参数有意义，不能在配置文件中起作用。 datadir 选择存放区块链数据的目录和文件系统。 默认情况下，在账户主目录的.bitcoin子目录。 确保该文件系统最少有几GB的可用空间。 prune 启用修剪模式，通过删除旧区块，将磁盘空间要求降低到几百MB。供空间有限的节点使用。 txindex 维护所有交易的索引。 这意味着可以通过ID以编程方式在区块链的完整副本中检索任何交易。 dbcache 设置UTXO cache大小。默认是300MB。配置高的系统上可以增加一些，配置低的话就减少一些，可以减少内存消耗，但是需要更多的磁盘IO开销。 maxconnections 设置最连接多少个节点。 从默认值减少该值将减少带宽消耗。 如果网络是带宽受限或者按照流量计费，可以设置这个参数。 maxmempool 将交易内存池限制在几兆字节。 使用它来减少节点的内存使用。 maxreceivebuffer/maxsendbuffer 将每个连接的内存缓冲区限制为多少个KB。 在内存受限节点上使用。 minrelaytxfee 设置发送的交易的的最低费用。 低于此值，交易被视为不规范的，会被交易池拒绝，也不会被发送。 交易数据库索引和txindex选项 默认情况下，Bitcoin Core会创建一个数据库，这个数据库只包含与用户钱包有关的交易。 如果您想要使用诸如getrawtransaction（参见3.4.2)之类的命令解读任何交易，则需要修改配置文件中的txindex选项设置txindex = 1来构建完整的交易索引。 如果不是一开始设置此选项，后期再想开启完全索引，需要使用-reindex选项重新启动bitcoind，并等待它重建索引。 下面的配置文件显示了前面提到的选项与完全索引节点组合起来的示例，可以作为比特币应用程序的API后端运行。 例3-1完整索引节点的例子 alertnotify=myemailscript.sh \"Alert: %s\" datadir=/lotsofspace/bitcoin txindex=1 例3-2是小型服务器资源不足的配置示例。 alertnotify=myemailscript.sh \"Alert: %s\" maxconnections=15 prune=5000 dbcache=150 maxmempool=150 maxreceivebuffer=2500 maxsendbuffer=500 配置文件修改完成之后，可以使用printtoconsole选项测试 bitcoind，查看输出的结果： $ bitcoind -printtoconsole Bitcoin version v0.15.0 InitParameterInteraction: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1 Assuming ancestors of block 0000000000000000003b9ce759c2a087d52abc4266f8f4ebd6d768b89defa50a have valid signatures. Using the 'standard' SHA256 implementation Default data directory /home/ubuntu/.bitcoin Using data directory /lotsofspace/.bitcoin Using config file /home/ubuntu/.bitcoin/bitcoin.conf Using at most 125 automatic connections (1048576 file descriptors available) Using 16 MiB out of 32/2 requested for signature cache, able to store 524288 elements Using 16 MiB out of 32/2 requested for script execution cache, able to store 524288 elements Using 2 threads for script verification HTTP: creating work queue of depth 16 No rpcpassword set - using random cookie authentication Generated RPC authentication cookie /lotsofspace/.bitcoin/.cookie HTTP: starting 4 worker threads init message: Verifying wallet(s)... Using BerkeleyDB version Berkeley DB 4.8.30: (April 9, 2010) Using wallet wallet.dat CDBEnv::Open: LogDir=/lotsofspace/.bitcoin/database ErrorFile=/lotsofspace/.bitcoin/db.log scheduler thread start Cache configuration: * Using 250.0MiB for block index database * Using 8.0MiB for chain state database * Using 1742.0MiB for in-memory UTXO set (plus up to 286.1MiB of unused mempool space) init message: Loading block index... Opening LevelDB in /lotsofspace/.bitcoin/blocks/index Opened LevelDB successfully [... more startup messages ...] 一确认配置显示正常，可以按Ctrl-C中断进程。 如果不想在前台运行Bitcoin Core，可以使用守护进程选项启动：bitcoind -daemon，在后台运行。 要监视比特币节点的进度和运行状态，使用命令bitcoin-cli getblockchaininfo： $ bitcoin-cli getblockchaininfo { \"chain\": \"main\", \"blocks\": 0, \"headers\": 83999, \"bestblockhash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\", \"difficulty\": 1, \"mediantime\": 1231006505, \"verificationprogress\": 3.783041623201835e-09, \"chainwork\": \"0000000000000000000000000000000000000000000000000000000100010001\", \"pruned\": false, [...] } 上面输出内容显示了这个节点当前更新的数据是区块高度为0，区块头为83999，意思是只获取到了最佳链的区块头，完整的区块数据之后才会开始下载。 配置选项确定好之后，应该将bitcoin命令添加到操作系统中的启动脚本中，让它随系统重启自动启动。 可以在contrib / init下的bitcoin目录查看README.md文件，找到不同操作系统对应的示例启动脚本。 3.4 通过命令行使用Bitcoin Core的JSON-RPC API接口 Bitcoin Core客户端实现了JSON-RPC接口，这个接口也可以通过命令行工具bitcoin-cli访问。命令行可以使用API进行编程，方便进行交互方式测试。开始前，使用help命令查看可用的比特币RPC命令列表： $ bitcoin-cli help addmultisigaddress nrequired [\"key\",...] ( \"account\" ) addnode \"node\" \"add|remove|onetry\" backupwallet \"destination\" createmultisig nrequired [\"key\",...] createrawtransaction [{\"txid\":\"id\",\"vout\":n},...] {\"address\":amount,...} decoderawtransaction \"hexstring\" ... ... verifymessage \"bitcoinaddress\" \"signature\" \"message\" walletlock walletpassphrase \"passphrase\" timeout walletpassphrasechange \"oldpassphrase\" \"newpassphrase\" 这些命令中的每一个可能都有多个参数。 要获得更多帮助，查看详细说明和参数信息，可以在help之后添加命令名称。 例如，要查看getblockhash RPC命令使用详情： $ bitcoin-cli help getblockhash getblockhash height Returns hash of block in best-block-chain at height provided. Arguments: 1. height (numeric, required) The height index Result: \"hash\" (string) The block hash Examples: > bitcoin-cli getblockhash 1000 > curl --user myusername --data-binary '{\"jsonrpc\": \"1.0\", \"id\":\"curltest\", \"method\": \"getblockhash\", \"params\": [1000] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/ 在帮助信息的最后，可以看到RPC命令的两个示例，使用bitcoin-cli或HTTP客户端的curl。 这些例子演示如何调用命令。 复制第一个示例并查看结果： $ bitcoin-cli getblockhash 1000 00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09 输出结果是一个区块哈希值，下面的章节中对此有更详细的描述。 这个命令的输出应该与你的输出一致，这才表明你自己的Bitcoin Core节点运行正常，可以接受命令，能够正确返回关于区块1000的信息。 在下一节中，将演示一些非常有用的RPC命令及其预期输出。 3.4.1 获得Bitcoin Core客户端状态的信息 Bitcoin Core通过JSON-RPC提供了不同模块的状态信息。其中最重要的命令有getblockchaininfo, getmempoolinfo, getnetworkinfo and getwalletinfo。 getblockchaininfo RPC命令之前介绍过了。getnetworkinfo显示比特币网络节点状态的基本信息。用bitcoin-cli运行这个命令示例如下： $ bitcoin-cli getnetworkinfo \"version\": 150000, \"subversion\": \"/Satoshi:0.15.0/\", \"protocolversion\": 70015, \"localservices\": \"000000000000000d\", \"localrelay\": true, \"timeoffset\": 0, \"networkactive\": true, \"connections\": 8, \"networks\": [ ... detailed information about all networks (ipv4, ipv6 or onion) ... ], \"relayfee\": 0.00001000, \"incrementalfee\": 0.00001000, \"localaddresses\": [ ], \"warnings\": \"\" } 数据返回的是JavaScript Object Notation (JSON)格式，这种格式很容易被所有编程语言“识别”，同时也方便人阅读。在上面数据中，我们看到比特币软件客户端版本号（150000）和比特币协议版本号（70015）。 还看到当前的连接数（8）。 后面还看到比特币网络和客户端设置的相关信息。 提示 比特币客户端“赶上”当前的blockchain高度需要一些时间，因为它要从其他比特币客户端下载区块。 可以使用getblockchaininfo检查进度，查看已已同步的区块的数量。 3.4.2 查看和解码交易 命令：getrawtransaction，decodeawtransaction 在买咖啡的故事中，Alice从Bob咖啡厅买了一杯咖啡。 她的交易ID（txid）0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2，已经被记录在区块链上。 使用API把交易ID作为参数可以进行检索和检查该交易： $ bitcoin-cli getrawtransaction 0627052b6f28912f2703066a912ea577f2ce4da4caa5a↵ 5fbd8a57286c345c2f2 0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd734d2804fe65fa35779000↵ 000008b483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4↵ ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813014↵ 10484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc54123363767↵ 89d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adfffffffff0260e3160000000↵ 0001976a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef8000000000001976a9↵ 147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000000 提示 交易ID在交易被确认之前是没有意义的。 在区块链中缺少交易哈希并不意味着交易未被处理。 这被称为“交易延展性”，因为区块中的交易被确认之前是可以修改交易哈希的。 交易被确认后，txid是就是不可改变的和权威的。 命令getrawtransaction以十六进制形式返回序列化交易。 为了解码，使用decodeawtransaction命令，将十六进制数据作为参数。 可以复制getrawtransaction返回的十六进制，并将其作为参数粘贴到decodeawtransaction中： $ bitcoin-cli decoderawtransaction 0100000001186f9f998a5aa6f048e51dd8419a14d8↵ a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba474↵ 6ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298↵ cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fd↵ e0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa↵ 336a8d752adfffffffff0260e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5↵ d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8↵ 88ac00000000 { \"txid\": \"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2\", \"size\": 258, \"version\": 1, \"locktime\": 0, \"vin\": [ { \"txid\": \"7957a35fe64f80d234d76d83a2...8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\": { \"asm\":\"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1decc...\", \"hex\":\"483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1de...\" }, \"sequence\": 4294967295 } ], \"vout\": [ { \"value\": 0.01500000, \"n\": 0, \"scriptPubKey\": { \"asm\": \"OP_DUP OP_HASH160 ab68...5f654e7 OP_EQUALVERIFY OP_CHECKSIG\", \"hex\": \"76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac\", \"reqSigs\": 1, \"type\": \"pubkeyhash\", \"addresses\": [ \"1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA\" ] } }, { \"value\": 0.08450000, \"n\": 1, \"scriptPubKey\": { \"asm\": \"OP_DUP OP_HASH160 7f9b1a...025a8 OP_EQUALVERIFY OP_CHECKSIG\", \"hex\": \"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac\", \"reqSigs\": 1, \"type\": \"pubkeyhash\", \"addresses\": [ \"1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK\" ] } } ] } 交易解码展示这笔交易的所有成分，包括交易的输入及输出。在这个例子中，可以看到这笔给我们新地址存入15mBTC的交易使用了一个输入并且产生两个输出。这笔交易的输入是前一笔确认交易的输出（以7957a35fe开头的 vin txid）。两个输出则是15mBTC转账金额和返回的找零金额。 可以使用相同命令（例如 gettransaction ）检查本次交易txid前一笔交易，进一步探索区块链。通过从一笔交易跳到另外一笔交易，我们可以追溯一连串的交易，因为币一定是从一个拥有者的地址传送到另一个拥有者的地址。 3.4.3 探索区块 命令： getblock 、 getblockhash 探索区块类似于探索交易。不同之处是区块可以由区块高度或区块哈希引用。首先，我们找一个区块的高度。在买咖啡故事中，我们看到Alice的交易已被包含在277316区块中。 使用getblockhash命令，该命令用区块高度作为参数，并返回该区块的区块哈希值： $ bitcoin-cli getblockhash 277316 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 既然知道要找的交易在这个区块中，我们可以使用getblock命令，把区块哈希值作为参数： $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 { \"hash\": \"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4\", \"confirmations\": 37371, \"size\": 218629, \"height\": 277316, \"version\": 2, \"merkleroot\": \"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e\", \"tx\": [ \"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f\", \"b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe\", \"04905ff987ddd4cfe603b03cfb7ca50ee81d89d1f8f5f265c38f763eea4a21fd\", \"32467aab5d04f51940075055c2f20bbd1195727c961431bf0aff8443f9710f81\", \"561c5216944e21fa29dd12aaa1a45e3397f9c0d888359cb05e1f79fe73da37bd\", [... hundreds of transactions ...] \"78b300b2a1d2d9449b58db7bc71c3884d6e0579617e0da4991b9734cef7ab23a\", \"6c87130ec283ab4c2c493b190c20de4b28ff3caf72d16ffa1ce3e96f2069aca9\", \"6f423dbc3636ef193fd8898dfdf7621dcade1bbe509e963ffbff91f696d81a62\", \"802ba8b2adabc5796a9471f25b02ae6aeee2439c679a5c33c4bbcee97e081196\", \"eaaf6a048588d9ad4d1c092539bd571dd8af30635c152a3b0e8b611e67d1a1af\", \"e67abc6bd5e2cac169821afc51b207127f42b92a841e976f9b752157879ba8bd\", \"d38985a6a1bfd35037cb7776b2dc86797abbb7a06630f5d03df2785d50d5a2ac\", \"45ea0a3f6016d2bb90ab92c34a7aac9767671a8a84b9bcce6c019e60197c134b\", \"c098445d748ced5f178ef2ff96f2758cbec9eb32cb0fc65db313bcac1d3bc98f\" ], \"time\": 1388185914, \"mediantime\": 1388183675, \"nonce\": 924591752, \"bits\": \"1903a30c\", \"difficulty\": 1180923195.258026, \"chainwork\": \"000000000000000000000000000000000000000000000934695e92aaf53afa1a\", \"previousblockhash\": \"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569\", \"nextblockhash\": \"000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7\" } 该区块包含419笔交易，列出的第64笔交易（0627052b ...）是Alice的咖啡付款。高度条目告诉我们这是区块链中的第277316区块。 3.4.4 使用Bitcoin Core的编程接口 bitcoin-cli 助手工具对于探索Bitcoin Core API和测试功能非常有用。 应用编程接口的全部要点是以编程方式访问软件功能。 在本节中，我们将演示从另一个程序访问Bitcoin Core的过程。 Bitcoin Core的API是一个JSON-RPC接口。 JSON代表JavaScript Object Notation，它可以很方便地呈现出人类和程序都可以轻松阅读的数据格式。 RPC代表远程过程调用，这意味着我们通过网络协议调用远程（位于Bitcoin Core节点）的程序（函数）。 这里的网络协议是HTTP或HTTPS（加密连接）。 当我们使用bitcoin-cli助手获取命令的帮助时，它给了我们一个使用curl的例子，这是一个常用的JSON-RPC调用命令行HTTP客户端： $ curl --user myusername --data-binary '{\"jsonrpc\": \"1.0\", \"id\":\"curltest\", \"method\": \"getinfo\", \"params\": [] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/ 此命令显示curl向本地主机（127.0.0.1）提交HTTP请求，连接到默认比特币端口（8332），并使用text / plain编码向getinfo方法提交jsonrpc请求。 你会注意到curl随同请求会发出一个凭证。Bitcoin Core每次启动时会创建一个随机口令，放在数据目录下的.cookie文件中。bitcoin-cli助手会读取数据目录下的这个口令文件。同样你也可以复制这个口令发送给curl（或更高级别的Bitcoin Core RPC封装）。你还可以使用Bitcoin Core源码目录下的./share/rpcauth/rpcauth.py助手脚本创建一个静态口令。 如果您在自己的程序中部署JSON-RPC调用，可以使用通用的HTTP库构建调用，类似于前面的curl示例所示。 然而，大多数编程语言中都有“包装”在Bitcoin Core API中的库，这样使用起来更简单。 使用python-bitcoinlib库可以简化API访问。 记住，这需要一个正在运行的Bitcoin Core实例，用于JSON-RPC调用。 下面的例子中的Python脚本使用简单的getblockchaininfo调用，从Bitcoin Core返回的数据中显示了区块参数。 例3-3通过Bitcoin Core的JSON-RPC API运行getblockchaininfo from bitcoin.rpc import RawProxy # Create a connection to local Bitcoin Core node p = RawProxy() # Run the getblockchaininfo command, store the resulting data in info info = p.getblockchaininfo() # Retrieve the 'blocks' element from the info print(info['blocks']) 运行结果如下： $ python rpc_example.py 394075 它告诉我们，我们的本地Bitcoin Core节点存储的区块链中有394075个区块。 虽然这个结果很简单，但它演示了使用库作为Bitcoin Core的JSON-RPC API的简化接口的基本用法。 接下来，我们使用getrawtransaction和decodetransaction调用来检索Alice咖啡付款的详细信息。 在下面的例子中，我们检索Alice的交易并列出交易的输出。 对于每个输出，我们显示收款地址和金额。 回忆一下，Alice的交易有一个输出支付Bob的咖啡馆，另一个输出是给Alice自己的找零。 例3-4检索交易并遍历输出 from bitcoin.rpc import RawProxy p = RawProxy() # Alice's transaction ID txid = \"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2\" # First, retrieve the raw transaction in hex raw_tx = p.getrawtransaction(txid) # Decode the transaction hex into a JSON object decoded_tx = p.decoderawtransaction(raw_tx) # Retrieve each of the outputs from the transaction for output in decoded_tx['vout']: print(output['scriptPubKey']['addresses'], output['value']) 运行结果如下： $ python rpc_transaction.py ([u'1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA'], Decimal('0.01500000')) ([u'1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK'], Decimal('0.08450000')) 上述两个例子都比较简单。 你真的不需要一个程序来运行它们; 你可以很容易地使用bitcoin-cli 助手。 不过，下一个示例需要数百个RPC调用，并更清楚地说明了使用编程接口的方便。 在例5中，我们首先检索区块277316，然后通过引用每个交易ID来检索所有的419个交易。 接下来，我们遍历每个交易的输出累加起来。 例3-5 检索区块并累加所有交易的输出 rpc_block.py文件中的代码如下： from bitcoin.rpc import RawProxy p = RawProxy() # The block height where Alice's transaction was recorded blockheight = 277316 # Get the block hash of block with height 277316 blockhash = p.getblockhash(blockheight) # Retrieve the block by its hash block = p.getblock(blockhash) # Element tx contains the list of all transaction IDs in the block transactions = block['tx'] block_value = 0 # Iterate through each transaction ID in the block for txid in transactions: tx_value = 0 # Retrieve the raw transaction by ID raw_tx = p.getrawtransaction(txid) # Decode the transaction decoded_tx = p.decoderawtransaction(raw_tx) # Iterate through each output in the transaction for output in decoded_tx['vout']: # Add up the value of each output tx_value = tx_value + output['value'] # Add the value of this transaction to the total block_value = block_value + tx_value print(\"Total value in block: \", block_value) 运行结果如下： $ python rpc_block.py ('Total value in block: ', Decimal('10322.07722534')) 我们的示例代码计算出，此区块中交易的总价值为10,322.07722534 个BTC（包括25 BTC矿工费奖励和0.0909 BTC交易费）。 可以将这个结果与使用区块浏览器搜索区块哈希或高度的结果进行比较。 有些区块浏览器不包括矿工费奖励和交易费。 看看是否有不同。 3.5 其他可选的客户端、库、工具包 比特币生态中还有许多可选的客户端，库，工具包，甚至还有全节点的实现。这些工具都由各自的编程语言实现，为程序员提供其首选语言的本地接口。 以下按照编程语言分类列出了推荐的一些库，客户端和工具包： 3.5.1 C/C++ Bitcoin Core 比特币的参考实现 libbitcoin 跨平台C++开发工具包，节点和共识库 bitcoin explorer Libbitcoin的命令行工具 picocoin Jeff Garzik提供的比特币c语言轻量级客户端库 3.5.2 JavaScript bcoin 带API的模块化可扩展的全节点实现 Bitcore Bitpay提供的全节点,API和库 BitcoinJS 用于node.js和浏览器的纯JavaScript比特币库 3.5.3 Java bitcoinj Java全节点客户端库 Bits of Proof (BOP) 比特币JAVA企业级实现 3.5.4 PHP bitwasp \\/bitcoin PHP比特币库和相关项目 3.5.5 Python python-bitcoinlib Peter Todd提供的Python比特币库，共识库和节点 pycoin Richard Kiss提供的Python比特币库 pybitcointools Vitalik Buterin提供的Python比特币库 3.5.6 Ruby bitcoin-client Ruby封装的JSON-RPC API 3.5.7 Go btcd Go语言全节点比特币客户端 3.5.8 Rust rust-bitcoin 用于序列化，解析和API调用的Rust比特币库 3.5.9 C\\ NBitcoin .NET框架的综合比特币库 3.5.10 Objective-C CoreBitcoin ObjC和Swift比特币工具包 还有许多其他编程语言的库，在不断开发中。 "},"ch04.html":{"url":"ch04.html","title":"第四章 密钥和地址","keywords":"","body":"第4章 密钥和地址 你可能听说过比特币基于密码学的，密码学是由数学分支出来的，在计算机安全领域被广泛使用。密码学在希腊语中是“秘密写作”的意思，但密码学这门学科不仅仅只有秘密写作，还包括加密技术。密码学可以用于不泄露秘密（数字签名），就能证明知晓加密的内容，或证明数据的真实性（数字指纹）。这些类型的密码学证明是比特币中至关重要的数学工具，并被广泛用于比特币应用。有趣的是，加密不是比特币的重要组成部分，因为它的通信和交易数据没有加密，也不需要加密来保护资金。在本章中，我们将介绍一些在比特币中用来控制资金所有权的密码学技术，包括密钥，地址和钱包。 4.1 简介 比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。数字密钥实际上并不存储在网络中，而是由用户生成之后，存储在一个叫做钱包的文件或简单的数据库中。用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问互联网。密钥实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。 大多数比特币交易都需要在区块链中存储一个有效的数字签名。该数字签名只能由密钥产生，因此拥有密钥副本就等于拥有了该帐户中比特币的控制权。用于支出资金的数字签名也称为见证（witness），这是密码学中的术语。比特币交易中的见证数据证明了资金的真正所有权。 密钥是成对出现的，由私钥和公钥所组成。公钥就像银行的帐号，而私钥就像PIN码或支票的签名。比特币的用户很少会直接看到数字密钥。一般情况下，它们存储在钱包文件内，由比特币钱包软件进行管理。 在比特币交易的支付环节，收款人的公钥由数字指纹表示，称为比特币地址，就像支票上收款人名称 （即“付给谁的账户”）。一般情况下，比特币地址由公钥生成并与之对应。然而，并非所有比特币地址都代表公钥； 也可以代表其他支付对象，譬如脚本，我们将在本章后面提及。这样一来，比特币地址就可以抽象成资金接收者，使得交易更灵活，就像纸质支票：可以支付到个人账户、公司账户，支付账单和现金。比特币地址是密钥被用户能够看到的唯一形式，因为这个地址就是需要告诉别人的。 首先，我们将介绍密码学，并解释在比特币中使用的数学知识。然后我们将了解密钥的产生、存储和管理方式。我们将检查私钥和公钥、地址和脚本地址的各种编码格式。最后，我们将讲解密钥和地址的高级用途：比特币靓号地址，多重签名以及脚本地址和纸钱包。 4.1.1 公钥密码学和密码货币 公钥密码学发明于20世纪70年代，它是计算机和信息安全的数学基础。 公钥密码学被发明之后，一些合适的数学函数被发现，譬如：素数幂运算和椭圆曲线乘法。这些数学函数都是不可逆的， 就是说很容易向一个方向计算，但不可以向相反方向倒推。基于这些数学函数的密码学，使得生成数字密钥和不可伪造的数字签名成为可能。比特币正是使用椭圆曲线乘法作为其密码学的基础。 在比特币系统中，我们用公钥密码学技术创建一个密钥对，用于控制对比特币的访问。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于支付时进行交易签名。 公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。公钥则可以在不显示私钥的情况下验证这些签名。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但都由同一个私钥生成）。针对展示的公钥和签名，比特币网络中的所有人都可以验证该交易有效并予以接受，从而确认支付者对该交易中的比特币的所有权。 提示 大多数比特币钱包工为了方便会将私钥和公钥以密钥对的形式存储在一起。然而，公钥可以由私钥计算得到， 所以只存储私钥也是可以的。 4.1.2 私钥和公钥 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。基于私钥，我们就可以使用椭圆曲线乘法这个单向密码函数产生一个公钥（K）。基于公钥（K），我们就可以使用一个单向密码哈希函数生成比特币地址（A）。在本节中，我们将从生成私钥开始，讲述如何使用椭圆曲线运算将私钥生成公钥，并最终由公钥生成比特币地址。私钥、公钥和比特币地址之间的关系如下图所示。 图4-1 私钥、公钥和比特币地址之间的关系 为什么使用非对称密码技术（公钥/私钥）？ 为什么在比特币中使用非对称密码技术？它不是用于对交易进行“加密”（保密）的。 相反，非对称密码技术的最有用特性是生成数字签名。可以将私钥用作交易的数字指纹来产生数字签名。 该签名只能由知晓私钥的人生成。 但是，任何访问公钥和交易指纹的人都可以验证签名。 这种非对称密码学的适用性使得任何人都可以验证每笔交易的每个签名，并且确保只有私钥的所有者可以生成有效的签名。 4.1.3 私钥 私钥就是一个随机选出的数字而已。拥有和控制了私钥，就相当于控制了该私钥对应的比特币地址中的所有资金。通过证明比特币交易中资金的所有权，私钥可以生成花费该笔资金的签名。私钥任何情况下都必须保密，因为一旦被泄露给第三方，相当于该私钥保护之下的比特币也拱手相让了。私钥还必须进行备份，以防意外丢失，因为私钥一旦丢失就无法恢复，其所保护的比特币也将永远丢失。 提示 比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。该私钥可进一步生成公钥。 从一个随机数生成私钥 生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。生成一个比特币私钥在本质上与“在1到2256之间选一个数字”无异。只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。通常情况下，操作系统随机数生成器由人工的随机源进行初始化，这就是为什么也可能需要不停晃动鼠标几秒钟。 更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158 * 1077，略小于2256），并被定义为由比特币所使用的椭圆曲线的阶（见下面的椭圆曲线密码学解释这一节）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。 警告 不要自己写代码来生成随机数，也不要使用编程语言提供的简易随机数生成器来获得一个随机数。使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个熵源值足够的的种子。使用随机数发生器的程序库时，需仔细研读其文档，以确保它是密码学安全的。正确实施CSPRNG是密钥安全性的关键所在。 以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，转变为十六进制是64位，每个十六进制数占4位）： 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD 提示 比特币私钥空间的大小是2256，这是一个非常大的数字。用十进制表示的话，大约是1077，而可见宇宙被估计只含有1080个原子。 要使用Bitcoin Core客户端生成一个新的密钥（参见第三章内容），可使用 getnewaddress 命令。出于安全考虑，命令运行后只显示生成的公钥，而不显示私钥。如果要bitcoind显示私钥，可以使用 dumpprivkey 命令。 dumpprivkey 命令会把私钥以 Base58校验和编码格式显示，这种私钥格式被称为钱包导入格式（WIF，Wallet Import Format），在“私钥的格式”一节有详细讲解。下面给出了使用这两个命令生成和显示私钥的例子： $ bitcoin-cli getnewaddress 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy $ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ dumpprivkey 命令打开钱包提取由 getnewaddress 命令生成的私钥。除非密钥对都存储在钱包里，否则bitcoind并不能从公钥得知私钥。 提示 dumpprivkey命令无法从公钥生成私钥，因为这是不可能的。这个命令只是显示钱包中已有也就是由getnewaddress命令生成的私钥。 还可以使用Bitcoin Explorer命令行工具（请参阅附录中的[appdx_bx]）使用命令seed，ec-new和ec-to-wif生成和显示私钥： $ bx seed | bx ec-new | bx ec-to-wif 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 4.1.4 公钥 通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k G 。其中 k 是私钥，G 是被称为生成点的常数点，而 K 是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去尝试所有可能的k*值，即暴力搜索。在演示如何从私钥生成公钥之前，我们先稍微详细学习下椭圆曲线密码算法。 提示 椭圆曲线乘法是密码学家称之为“陷阱门”的一种函数：在一个方向（乘法）很容易计算，而在相反的方向（除法）是不可能计算出来的。私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥反转该函数计算出私钥。 这个数学技巧成为证明比特币资金所有权不可伪造和安全的数字签名的基础。 4.1.5 椭圆曲线密码学（Elliptic Curve Cryptography）解释 椭圆曲线密码学算法是一种基于离散对数问题的非对称或者公钥密码学算法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 下图是一个椭圆曲线的示例，类似于比特币所用的曲线。 图4-2椭圆曲线的示例 比特币使用了secp256k1标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）建立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1， 这是个非常大的素数。 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像二维的离散的点，因此很难可视化。不过，该公式与实数的椭圆曲线数学公式是相似的。为了举例，下图显示了在一个小了很多的素数阶17的有限域内的椭圆曲线，其形式为网格上的一系列散点。而secp256k1的比特币椭圆曲线可以被想象成一个更大的网格上一系列更为复杂的散点。 图4-3 椭圆曲线密码学F(p)上的椭圆曲线，其中p = 17 比如，下面是 secp256k1 曲线上的点P，其坐标为(x，y)。 `P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)` 下面的例1显示了如何使用Python对其检验： 例1：使用pyhton确认这个点在椭圆曲线上 Python 3.4.0 (default, Mar 30 2014, 19:23:13) [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663 >>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240 >>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424 >>> (x ** 3 + 7 - y**2) % p 0 在椭圆曲线数学中，有一个点被称为“无穷远点”，这大致相当于0的作用。计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但这是一个可以单独检查的例子）。 还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3 = P1 + P2。 从几何学上说，该第三点P3可以在P1和P2之间画一条线来计算出来的。这条直线恰好与椭圆曲线相交于另外一个地方。此点记为 P3'= (x，y)。然后，基于x轴的对称点就是 P3=(x，-y)。 下面是几个解释为何需要“无穷远点”的特殊例子。 若 P1和 P2是同一点，那么P1和P2之间的连线延长就会与曲线相切于p1处。该切线将会与曲线相交于一个新的点。该切线的斜率可用微积分求得。尽管我们只局限在曲线上两个整数坐标的那个点，但这个机制是没问题的。 在某些情况下（即，如果P1和P2具有相同的x值，不同的y值），则切线会完全垂直，在这种情况下，P3 = “无穷远点”。 若P1就是“无穷远点”，那么其和 P1 + P2= P2。类似地，当P2是无穷远点，则P1+ P2 = P1。这表明无穷远点类似于0的角色。 事实证明，在这里 + 运算符遵守结合律，即(A+B)+C = A+(B+C)。这就是说我们可以书写成 A + B + C，不加括号也可以，而不至于混淆。 至此，我们已经定义了椭圆加法，我们可以用标准方法对加法进行扩展，来定义乘法。给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + …+ P（k次）。注意，在这种情况下k有时被混淆了称为“指数”。 4.1.6 生成公钥 以一个随机生成的私钥k为起点，将其乘以曲线上一个预定的点，叫做生成点G得到曲线上的另一点，这就是相应的公钥 K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的： {K = k * G} 其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。因为所有比特币用户的生成点是相同的，一个私钥k乘以G将得到相同的公钥K。k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生） 与任何人共享而不会泄露私钥（k）的原因。 提示 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。 实现了椭圆曲线乘法，我们用之前产生的私钥k和与生成点G相乘得到公钥K： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G 公钥K 被定义为一个点 K = (x, y)： K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 为了可视化展示整数与点的乘积，我们使用实数范围的简化的椭圆曲线。请记住，其中的数学原理是相同的。我们的目标是找到生成点G的倍数kG。也就是将G相加k次。在椭圆曲线中，点的相加等于该点的切线与曲线相交的那个点，该点基于x轴的对称点。 下图显示了在曲线上得到 G、2G、4G 的几何做法。 图4-4 曲线上 G、2G、4G 的几何做法 提示 比特币使用【secp256k1 optimized C library】 进行椭圆曲线计算。 4.2 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以展示给任何给你转账比特币的人。由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。下面是一个比特币地址的例子： 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在交易中，比特币地址通常作为资金接受者地址。如果把比特币交易比作一张支票，比特币地址就是收益人，也就是写入“支付给谁”一栏的内容。一张支票的收款人可能是某个银行账户，也可能是某个公司、机构，甚至是现金支票。由于支票不需要指定一个特定的账户，而是用一个抽象的名字作为收款人，这就使它成为一种相当灵活的支付工具。与此类似，比特币交易使用类似的抽象：比特币地址，这就使比特币交易变得很灵活。比特币地址代表一对公钥和私钥的所有者，也可以代表其它东西，比如会在后面的“P2SH (Pay-to-Script-Hash)”一节讲到的付款脚本。现在，让我们来看一个简单的例子，比特币地址代表公钥，并由公钥生成。 比特币地址可由公钥经过单向哈希算法得到。密码学哈希算法是一种单向函数，接收任意长度的输入产生指纹或哈希。哈希函数在比特币中被广泛使用 ：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integ rity Primitives Evaluation Message Digest (RIPEMD)，具体来说是SHA256和RIPEMD160。 以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160位（20字节）的数字： A = RIPEMD160(SHA256(K)) 公式中，K是公钥，A是生成的比特币地址。 提示 比特币地址与公钥并不不同。比特币地址是公钥经过单向的哈希函数生成的。 通常用户见到的比特币地址是经过“Base58Check”编码的（参见下面的“Base58和Base58Check编码”一节），这种编码使用了58个字符（Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。下一节中我们会详细解释Base58Check的编码和解码机制，以及它产生的结果。 下图描述了如何从公钥生成比特币地址。 图4-5从公钥生成比特币地址] 4.2.1 Base58和Base58Check编码 为了更简洁方便地表示长串的数字，使用更少的符号，许多计算机系统在表示大于十进制时，会使用数字和字母混合组成。例如，传统的十进制计数系统使用0-9十个数字，而十六进制系统使用了16个，增加了 A-F 六个字母来表示0-9额外的符号。一个同样的数字，它的十六进制表示就会比等值得十进制表示更短。更为简洁的是，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例 如“+”和“/”），用于在像电子邮件这样的文本媒介中传输二进制数据。Base64通常用于邮件中添加二进制附件。Base58 是一种基于文本的二进制编码格式，用在比特币和其它的密码货币中。这种编码格式提供了紧凑表示，易读性，错误检测预防这几方面彼此之间的平衡。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易读错和在特定字体中外观容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。下面的例4-2是完整的Base58字母表。 例4-2 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz 为了增加防止打印和转录错误的安全性，比特币常用的是Base58Check，它是一种内置错误校验代码的Base58编码格式。检验和是额外4个字节，被添加到正在编码的数据末端。校验和是从编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。使用Base58check编码时，解码软件会计算数据的校验和并和编码中自带的校验和进行对比。二者不匹配则表明有错误产生，这个Base58Check的数据就是无效的。这就防止输错的比特币地址被钱包软件认为是有效的地址，造成资金的丢失。 为了将数据（数字）转换成Base58Check格式，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来识别编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而编码私钥的前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。 接下来，我们计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法： checksum = SHA256(SHA256(prefix+data)) 在产生的长度为32个字节的哈希值（两次哈希运算）中，我们只取前4个字节。这4个字节就作为检验错误的代码或者校验码。将校验码添加到最后。 结果由三部分组成：前缀、数据和校验码。这个结果采用之前描述的Base58字母表编码。下图描述了Base58Check编码的过程。 图4-6 Base58Check编码：Base58、版本化和校验码格式，用于对比特币数据进行明确编码 在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，因为它紧凑，易读而且有错误检验。 Base58Check编码中的版本前缀是用来创造易于辨别的格式Base58编码时，该格式在base58check编码的负载的开头包含特定字符。这些字符使人们很容易了解别被编码的数据的类型和使用方法。例如我们很容易看到，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的。表4-1展示了一些版本前缀和他们对应的Base58格式。 表4-1 Base58Check版本前缀和编码后的结果 Type Version prefix (hex) Base58 result prefix Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K, or L BIP-38 Encrypted Private Key 0x0142 6P BIP-32 Extended Public Key 0x0488B21E xpub 4.2.2 密钥的格式 公钥和私钥都可以有多种格式。虽然看起来可能不同，但是所编码的是同样的数字。这些不同的编码格式主要是用来方便人们无误地阅读和抄写。 4.2.2.1私钥的格式 私钥的格式有许多，所有这些都对应于相同的256位的数字。表4-2展示了私钥的三种常见格式。不同的格式用在不同的场景。十六进制和原始的二进制格式用在软件的内部，很少展示给用户看。WIF格式用在钱包之间密钥的输入和输出，也用于代表私钥的二维码（条形码）。 表4-2 私钥形式（编码格式） Type Prefix Description Raw None 32 bytes Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128- and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 下表表4-3显示了三种格式的私钥。 表4-3 示例：相同的私钥，不同的格式 Format Private key Hex 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些格式都表示相同的数字，相同的私钥。虽然编码后的字符串看起来不同，但任何一种格式都能很容易转换为其他格式。请注意，“raw binary”未显示在表4-3 示例中，因为根据定义，此处显示的任何编码的格式，都不是raw binary数据。 我们使用Bitcoin Explorer中的wif-to-ec命令（请参阅[appdx_bx]）来显示两个WIF键代表相同的私钥： $ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd $ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 4.2.2.2 从Base58Check解码 Bitcoin Explorer命令（参见本书附录[appdx_bx]）使我们很容易编写shell脚本和命令行“管道”，处理比特币密钥，地址和交易。 Bitcoin Explorer命令行可以解码Base58Check格式。 我们使用base58check-decode命令解码未压缩的密钥： $ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn wrapper { checksum 4286807748 payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd version 128 } 结果包含密钥有效内容（payload），WIF版本前缀128和校验码。 请注意，压缩密钥的“有效内容”附加了后缀01，表示派生的公钥要被压缩： $ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ wrapper { checksum 2339607926 payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 version 128 } 4.2.2.3 将十六进制转换为Base58Check编码 要转换成Base58Check（与上一个命令相反），使用Bitcoin Explorer的base58check-encode命令（请参阅本书附录[appdx_bx]），需要十六进制私钥，后面跟WIF版本前缀128： bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 4.2.2.4 将十六进制（压缩格式密钥）转换为Base58Check编码 要将压缩格式的私钥（参见“压缩格式私钥”一节）编码为Base58Check，需要在十六进制私钥的后面添加后缀01，然后使用跟上面一样的方法： $ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128 KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 生成的WIF压缩格式的私钥以字母“K”开头，表明被编码的私钥中有一个后缀“01”，且该私钥只能被用于生成压缩格式的公钥（参见“压缩格式公钥”一节）。 4.2.2.5 公钥的格式 公钥也可以用多种不同格式来表示，通常分为非压缩格式或压缩格式公钥这两种形式。 我们从前文可知，公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256位的数字。其中一个256位数字是公钥的x坐标，另一个256位数字是y坐标。前缀04是是非压缩格式公钥， 压缩格式公钥是以02或者03开头。 下面是由前文中的私钥所生成的公钥，其坐标x和y如下： x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 下面是同样的公钥以520位的数字（130个十六进制数字）来表达。这个520位的数字以前缀04开头，紧接着是x坐标及y坐标，格式为：04 x y： K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE 52DDFE2E505BDB 4.2.2.6 压缩格式公钥 比特币引入压缩格式公钥是为了减少交易的大小，从而节省运行区块链数据库的节点磁盘空间。大部分比特币交易包含了公钥，用于验证用户的凭证和支付比特币。每个公钥有520位（包括前缀，x坐标，y坐标）。如果每个区块有数百个交易，每天有成千上万的交易发生，区块链里就会被写入大量的数据。 正如“4.1.4 公钥”一节所述，一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2 mod p = (x3 + 7) mod p得到y坐标。这可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256位。这样每笔交易需要的字节数减少了近一半，随着时间推移，就能保存更多的交易数据。 未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。为什么会有两个前缀：因为椭圆曲线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在x坐标轴的上面或者下面。就像图4-2的椭圆曲线图中可以看出，曲线是对称的，就像是x轴的镜像。因此，如果我们略去y坐标，就必须储存y的符号（正号或者负号）。换句话说，需要知道在x轴的上方还是下方，因为上方下方代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是偶数或者奇数，分别对应前面所讲的y值的正/负符号。因此，为了区分y坐标的两种可能值，在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以让软件能够根据x坐标，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上点的完整坐标。下图阐释了公钥压缩： 图4-7 公钥压缩 下面是前述章节所生成的公钥，使用了264比特（66个十六进制数字）的压缩格式公钥格式，其中前缀03表示y坐标是一个奇数： K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 这个压缩格式公钥对应着同样的一个私钥，意味它是由同样的私钥所生成。但是压缩格式公钥和非压缩格式公钥看起来不同。更重要的是，如果我们使用双哈希函数(RIPEMD160(SHA256(K)))将压缩格式公钥转化成比特币地址，得到的地址将会不同于由非压缩格式公钥产生的地址。这种结果会让人迷惑，一个私钥生成了两种不同格式的公钥——压缩格式和非压缩格式，这两种格式的公钥又生成了两个不同的比特币地址。但是，这两个不同的比特币地址的私钥是一样的。 压缩格式公钥渐渐成为了各种比特币客户端的默认格式，它可以大大减少交易所需的字节数，同时也让存储区块链所需的磁盘空间变小。然而，并非所有的客户端都支持压缩格式公钥，于是那些较新的支持压缩格式公钥的客户端就不得不考虑如何处理那些来自较老的不支持压缩格式公钥的客户端的交易。当一个钱包应用导入另一个钱包应用的私钥的时候就会变得尤其重要，因为新钱包需要扫描区块链并找到所有与这些被导入密钥相关的交易。比特币钱包应该扫描哪个比特币地址呢？到底是压缩的公钥产生的比特币地址，还是通过非压缩的公钥产生的地址？两个都是有效的比特币地址，都可以被私钥签名，但是他们是不同的比特币地址。 为了解决这个问题，当私钥从钱包中被导出时，WIF表示私钥时，在较新的比特币钱包里被处理的方式就会有所不同，表明该私钥已经被用来生成压缩的公钥和压缩的比特币地址。这让导入钱包可以区分私钥来自于老钱包还是新钱包，使用分别对应于压缩格式公钥还是非压缩格式公钥的比特币地址，搜索区块链中对应的交易。我们将在下一节详细解释这种机制是如何工作的。 4.2.2.7 压缩格式私钥 实际上“压缩格式私钥”是一种名称上的误导，因为当私钥使用WIF压缩格式导出时，不但没有压缩，反而比“非压缩格式”私钥长出一个字节。这个多出来的一个字节是私钥被加了后缀01，用以表明该私钥是来自于一个较新的钱包，只能被用来生成压缩公钥。私钥并没有压缩的，也不能被压缩。“压缩私钥”实际上表示“只能生成压缩公钥的私钥”，而“非压缩私钥”用来表明“只能生成非压缩公钥的私钥”。为避免更多误解，应该只可以说导出格式 是“WIF压缩格式”或者“WIF”，而不能说这个私钥是“压缩”的。 表4-4展示了同样的私钥的WIF和WIF压缩格式编码。 表4示例：相同的密钥，不同的格式 Format Private key Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 请注意，十六进制压缩私钥在末尾有一个额外的字节（十六进制为01）。 虽然Base58编码版本前缀对于WIF和WIF压缩格式都是相同的（0x80），但在数字末尾添加一个字节会导致Base58编码的第一个字符从5变为K或 L，Base58这一点有点类似十进制数字100和数字99之间的差别。100比99多一位数字，它的前缀是1，不是9。当长度变化，会影响前缀。与此类似，在Base58中，数字长度增加一个字节，前缀5就会改变为K或L。 要注意的是，这些格式并不是可互换使用的。在实现了压缩格式公钥的较新的钱包中，私钥只能且永远被导出为WIF压缩格式（以K或L为前缀）。对于较老的没有实现压缩格式公钥的钱包，私钥只能被导出为WIF格式（以5为前缀）。这样做的目的就是为了给导入这些私钥的钱包一个信号：是否必须在区块链中搜索压缩或非压缩公钥和地址。 如果一个比特币钱包实现了压缩格式公钥，那么将会用在所有交易中。钱包中的私钥将会被用来在曲线上生成公钥点，就会被压缩。压缩格式公钥被用来生成交易中的比特币地址。当从一个实现了压缩格式公钥的新的比特币钱包导出私钥时，钱包导入格式（WIF）将会被修改为WIF压缩格式，该格式将会在私钥的后面附加一个字节的后缀01。最终的Base58Check编码格式的私钥被称作WIF（“压缩”）私钥，以字母“K”或“L”开头。而以“5”开头的是从较老的钱包中以WIF（非压缩）格式导出的私钥。 提示 “压缩格式私钥”是一个不当用词！私钥是不可压缩的。WIF压缩格式的私钥只是用来表明他们只能被生成压缩公钥和对应的比特币地址。更矛盾的是，“WIF压缩”编码的私钥还多出一个字节，因为这种私钥多了后缀“01”。该后缀是用来区分“非压缩格式”和“压缩格式”。 4.3 用C++实现密钥和地址 我们回顾比特币地址产生的完整过程，从私钥、到公钥（椭圆曲线上某个点）、再到双重哈希地址，到最终的 Base58Check编码。例4-3的C++代码完整详细的展示了从私钥到Base58Check编码后的比特币地址的步骤。代码中使用“3.3 其他客户端、资料库、工具包 ”一节中介绍的libbitcoin库中的助手函数。 例4-3.从私钥中创建Base58Check编码的比特币地址 addr.cpp文件中的代码如下： #include int main() { // Private secret key string as base16 bc::ec_secret decoded; bc::decode_base16(decoded, \"038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776\"); bc::wallet::ec_private secret( decoded, bc::wallet::ec_private::mainnet_p2kh); // Get public key. bc::wallet::ec_public public_key(secret); std::cout 上述代码使用预定义的私钥在每次运行时产生相同的比特币地址，如下例所示 例4-4 编译并运行addr代码 Compile the addr.cpp code $ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin) Run the addr executable $ ./addr Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK 提示 例4-4中的代码从压缩公钥（参见上面的“压缩公钥”一节）生成了一个比特币地址（1PRTT...）。如果使用了未压缩公钥，就会生成另外一个地址(14K1y...)。 4.4 用Python实现密钥和比特币地址 最全面的比特币Python库是 Vitalik Buterin写的 pybitcointools。在例4-5中，我们使用pybitcointools库（导入 为“bitcoin”）来生成和显示不同格式的密钥和比特币地址。 例4-5 使用pybitcointools库的密钥和比特币地址的生成和格式化 key-to-address-ecc-example.py文件中的代码如下： from __future__ import print_function import bitcoin # Generate a random private key valid_private_key = False while not valid_private_key: private_key = bitcoin.random_key() decoded_private_key = bitcoin.decode_privkey(private_key, 'hex') valid_private_key = 0 例4-6是上例代码运行输出的内容。 例4-6 运行key-to-address-ecc-example.py $ python key-to-address-ecc-example.py Private Key (hex) is: 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6 Private Key (decimal) is: 26563230048437957592232553826663696440606756685920117476832299673293013768870 Private Key (WIF) is: 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K Private Key Compressed (hex) is: 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601 Private Key (WIF-Compressed) is: KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S Public Key (x,y) coordinates is: (41637322786646325214887832269588396900663353932545912953362782457239403430124L, 16388935128781238405526710466724741593761085120864331449066658622400339362166L) Public Key (hex) is: 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec↵ 243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176 Compressed Public Key (hex) is: 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec Bitcoin Address (b58check) is: 1thMirt546nngXqyPEz532S8fLwbozud8 Compressed Bitcoin Address (b58check) is: 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3 例4-7是另外一个示例，使用的是Python ECDSA库来做椭圆曲线计算而非bitcoin的库。 例4-7 用于比特币密钥的椭圆曲线算法演示脚本 ec-math.py文件中的代码如下： import ecdsa import os # secp256k1, http://www.oid-info.com/get/1.3.132.0.10 _p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F _r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 _b = 0x0000000000000000000000000000000000000000000000000000000000000007 _a = 0x0000000000000000000000000000000000000000000000000000000000000000 _Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 _Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 curve_secp256k1 = ecdsa.ellipticcurve.CurveFp(_p, _a, _b) generator_secp256k1 = ecdsa.ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r) oid_secp256k1 = (1, 3, 132, 0, 10) SECP256k1 = ecdsa.curves.Curve(\"SECP256k1\", curve_secp256k1, generator_secp256k1, oid_secp256k1) ec_order = _r curve = curve_secp256k1 generator = generator_secp256k1 def random_secret(): # Collect 256 bits of random data from the OS's cryptographically secure # random number generator byte_array = (os.urandom(32)).hex() return int(byte_array,16) def get_point_pubkey(point): if (point.y() % 2) == 1: key = '03' + '%064x' % point.x() else: key = '02' + '%064x' % point.x() return key def get_point_pubkey_uncompressed(point): key = ('04' + '%064x' % point.x() + '%064x' % point.y()) return key # Generate a new private key. secret = random_secret() print(\"Secret: \", secret) # Get the public key point. point = secret * generator print(\"Elliptic Curve point:\", point) print(\"BTC public key:\", get_point_pubkey(point)) # Given the point (x, y) we can create the object using: point1 = ecdsa.ellipticcurve.Point(curve, point.x(), point.y(), ec_order) assert(point1 == point) 例4-8是上述脚本的输出。 警告：例4-7中使用的os.urandom，表明的是底层操作系统的密码学安全随机数生成器（cryptographically secure random number generator (CSRNG) ）。注意：根据操作系统的不同，os.urandom的实现缺乏足够的安全性，也可能没有正确的种子，并且不适合产生高质量的比特币密钥。 例4-8 安装Python ECDSA 库，运行脚本running the ec_math.py $ # Install Python PIP package manager $ sudo apt-get install python-pip $ # Install the Python ECDSA library $ sudo pip install ecdsa $ # Run the script $ python ec-math.py Secret: 38090835015954358862481132628887443905906204995912378278060168703580660294000 EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380) BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873 4.5 高级密钥和地址 在以下部分中，我们将看到密钥和地址的高级形式，诸如脚本和多重签名地址，靓号地址，和纸钱包。 4.5.1 P2SH (Pay-to-Script Hash)支付脚本哈希和多重签名地址 正如我们所知，传统的比特币地址从数字1开头，来源于公钥，而公钥来源于私钥。虽然任何人都可以将比特币发送到 一个1开头的地址，但比特币只有提供相应的私钥签名和公钥哈希值后才能花费。 以数字3开头的比特币地址是P2SH地址，有时被错误的称谓多重签名或多重签名地址。它们指定比特币交易中受益人为脚本哈希，而不是公钥的所有者。这个特性在2012年1月由BIP-16（参见附录appdxbitcoinimpproposals）引进，正是因为BIP-16提供了向地址本身添加功能的机会而被广泛地采纳。不同于P2PKH（pay-to-public-key-hash，支付公钥哈希），交易发送资金到传统1开头的比特币地址，资金被发送到3开头的地址时，要求的不仅仅是公钥的哈希值和私钥签名来证明所有权。这些要求是在创建地址时在脚本中指定的，对这个地址的所有输入都将使用相同的要求。 P2SH地址从交易脚本中创建，后者定义谁能花费这个交易输出（参见【7.3 P2SH（Pay-to-Script-Hash】）。对P2SH地址编码使用的是与创建比特币地址同样的双重哈希函数，只是应用在脚本而不是公钥： script hash = RIPEMD160(SHA256(script)) 得到的\"脚本哈希\"使用Base58Check编码，版本前缀为5，最后生成3开头的编码地址。一个P2SH地址例子是 3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM。可以使用比特币浏览器命令script encode、sha256、ripemd160和base58check encode（参见附录appdx_bx]）导出，举例如下： $ echo \\ 'DUP HASH160 [89abcdefabbaabbaabbaabbaabbaabbaabbaabba] EQUALVERIFY CHECKSIG' > script $ bx script-encode 提示 P2SH不一定就是多重签名的交易。虽然P2SH地址通常都是代表多重签名，但也可能表示编码其他类型交易的脚本。 4.5.1.1 多重签名地址和P2SH 目前，P2SH最常见的实现是多重签名地址脚本。顾名思义，底层脚本需要多个签名来证明所有权，才能花费资金。比特币多重签名功能的设计要求是总共N个密钥中需要M个签名（也称为“阈值”），被称为M-N多重签名，其中M是等于或小于N。例如，第一章中提到的咖啡店主Bob使用的多重签名地址，需要1/2签名，一个是属于他的密钥，另一个是他妻子的密钥，其中任何一方都可以签名花费这个地址锁定的输出。这类似于传统的银行中的一个“联合账户”，其中夫妻任何一方都可以单独签单消费。或就像Bob雇佣的网页设计师Gopesh， 可能需要的是一个2/3的多签名地址，可以确保至少两个合伙人签名了交易才可以继续支付。 我们将会在第五章交易中探讨如何构造P2SH（和多重签名）地址花费资金的交易。 4.5.2 靓号地址 靓号地址也是有效的比特币地址，只不过增加了可读性。例如，1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33就是有效的地址，开头的4个字符Base-58包含了字母love。靓号地址需要生成和测试几十亿个候选私钥，直到一个符合模式要求的比特币地址。虽然有一些优化过的靓号生成算法，但是这些方法必然涉及到随机选择一个私钥，生成公钥，再生成比特币地址，并检查是否与所要的靓号模式相匹配，需要重复数十亿次，直到找到一个匹配。 一旦找到一个与所需模式匹配的靓号地址，那么这个靓号地址的私钥就和其他地址一样被所有者花费比特币。靓号地址不比其他地址具有更多或更少的安全性。它们依靠和其他地址相同的椭圆曲线密码学算法（ECC）和SHA。找一个靓号开头的地址的私钥并不比找其他地址容易。 在第一章中，我们介绍了Eugenia，一位菲律宾的儿童慈善机构负责人。我们假设Eugenia组织了一场比特币募捐活动，并希望使用靓号比特币地址来宣传这个募捐活动。Eugenia将会创造一个以1Kids开头的靓号地址来推广儿童慈善募捐的活动。让我们看看这个靓号地址如何被创建，以及对Eugenia慈善募捐的安全性有什么意义。 4.5.2.1 生成靓号地址 应该意识到，比特币地址不过是由Base58字母表中的符号表示的一组数字。寻找像“1kids”开头的靓号就像从1Kids11111111111111111111111111111到1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz这个区间找一个地址。以“1kid”开头的地址区间大约有5829个地址（大约是1.4 * 1051)）。表4-6显示了这些有“1kids”前缀的地址范围。 表4-6 “1Kids”靓号的范围 From 1Kids11111111111111111111111111111 1Kids11111111111111111111111111112 1Kids11111111111111111111111111113 ... To 1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz 我们把“1Kids”这个前缀当作数字，可以看看比特币地址中这个前缀出现的频率。一台普通台式电脑， 没有任何特殊的硬件，大约每秒搜索大约10万个密钥。 表4-7 靓号（1KidsCharity）的出现的频率以及生成所需时间 Length Pattern Frequency Average search time 1 1Ki 1 in 58 keys 2 1Ki 1 in 3,364 50 milliseconds 3 1Kid 1 in 195,000 4 1Kids 1 in 11 million 1 minute 5 1KidsC 1 in 656 million 1 hour 6 1KidsCh 1 in 38 billion 2 days 7 1KidsCha 1 in 2.2 trillion 3–4 months 8 1KidsChar 1 in 128 trillion 13–18 years 9 1KidsChari 1 in 7 quadrillion 800 years 10 1KidsCharit 1 in 400 quadrillion 46,000 years 11 1KidsCharity 1 in 23 quintillion 2.5 million years 正如你所见，Eugenia并不能很快创造以“1KidsCharity”开头的靓号地址，即使她有数千台电脑同时进行运算。每增加一个字符就会增加58倍的计算难度。超过七个字符的靓号通常需要专用的硬件才能被找到，譬如用户定制的多个GPU的台式机。通常是使用无法继续比特币挖矿的矿机，被赋予了寻找靓号地址的任务。用GPU搜索靓号的速度比通用的CPU要快很多个量级。 另一种寻找靓号地址的方法是外包给一个靓号矿池，如【Vanity Pool】。矿池提供一种服务，把有GPU硬件的人组织起来，通过为他人寻找靓号地址来获得比特币。Eugenia可以将搜索7位字符模式的靓号地址的工作外包出去，只需要很少的金额（本书写作时大概是0.01比特币或者5美元），几个小时内就可以得到结果，而不用自己运行CPU搜索上几个月。 生成一个靓号地址是一项通暴力破解的过程：尝试一个随机密钥，检查生成的地址是否和所需的模式相匹配，重复这个过程直到成功找到为止。例4-9是个靓号挖矿的例子，用C++程序写的来寻找靓号地址的程序。这个例子运用到了我们在“其他替代客户端、资料库、工具包”一节介绍过的libbitcoin库。 例4-9 靓号挖矿程序 vanity-miner.cpp文件中的代码如下： #include #include // The string we are searching for const std::string search = \"1kid\"; // Generate a random secret key. A random 32 bytes. bc::ec_secret random_secret(std::default_random_engine& engine); // Extract the Bitcoin address from an EC secret. std::string bitcoin_address(const bc::ec_secret& secret); // Case insensitive comparison with the search string. bool match_found(const std::string& address); int main() { // random_device on Linux uses \"/dev/urandom\" // CAUTION: Depending on implementation this RNG may not be secure enough! // Do not use vanity keys generated by this example in production std::random_device random; std::default_random_engine engine(random()); // Loop continuously... while (true) { // Generate a random secret. bc::ec_secret secret = random_secret(engine); // Get the address. std::string address = bitcoin_address(secret); // Does it match our search string? (1kid) if (match_found(address)) { // Success! std::cout 注释 下面的例4-10 使用std :: random_device。 根据实施情况，可能会映射到底层操作系统提供的CSRNG。在类Unix的操作系统（如Linux）中，它来自/ dev/urandom。 这里使用的随机数字生成器只用于演示，并不适用于生产级别的比特币密钥，因为它没有足够的安全性。 示例代码需要用C++编译器链接libbitcoin库（此库需要提前安装到系统）进行编译。运行这个例子可以不带参数直接执行vanity-miner的可执行文件 （参见例4-10），它就会尝试找到以“1kid”开头的靓号地址。 例4-10 编译并运行vanity-miner程序示例 $ # Compile the code with g++ $ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the example $ ./vanity-miner Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f $ # Run it again for a different result $ ./vanity-miner Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623 # 使用 \"time\"来看最终需要的时长 $ time ./vanity-miner Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349 real 0m8.868s user 0m8.828s sys 0m0.035s 正如我们运行Unix命令所测出的运行时间所示，示例代码要花几秒钟来找出匹配“kid”三个字符模式的结果。你可以尝试在源代码中改变search pattern，看一看四个字符或者五个字符需要花多久时间！ 4.5.2.2 靓号地址安全性 靓号地址其实就是一把双刃剑，既可能增加安全，也可能削弱安全措施。用于改善安全性时，一个独特的地址使竞争对手难以替换掉你的地址，欺骗你的客户付款给他们。不幸的是，任何人都能创建一个类似的随机地址，甚至另一个靓号地址，欺骗你的客户。 Eugenia可以让捐款人捐款到她的一个随机生成地址（例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy）。 她也可以生成一个独特的以“1Kids”开头的靓号地址。 针对这两种情况，使用单一固定地址（而不是每笔捐款都用一个独立的动态地址）的风险之一是骗子有可能会黑进你的网站，用他自己的地址取代你的地址，从而将捐赠转移给他自己。如果你在不同的地方公布了你的捐款地址，你的用户应该在付款之前认真检查以确保这个地址跟在你的网站、邮件和传单上看到的地址是同一个。如果是随机地址 1j7mdg5rbqyuhenydx39wvwk7fslpeoxzy，普通用户可能会只检查头几个字符“1j7mdg”，就认为地址匹配。使用靓号地址生成器，那些想替换类似地址的骗子可能很快生成与前几个字符相匹配的地址，如表4-8所示。 表4-8 生成匹配某随机地址的多个靓号 Original Random Address 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy Vanity (4-character match) 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy Vanity (5-character match) 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n Vanity (6-character match) 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX 那靓号地址还能增加安全性吗？如果Eugenia生成1Kids33q44erFfpeXrmDSz7zEqG2FesZEN的靓号地址，用户可能看到靓号单词和后面的几个字符，例如注意到1Kids33。这样就会迫使攻击者至少生成6个字母相匹配的的靓号地址（比之前多2个字符），花费比Eugenia多3364倍（582的努力。本质上，Eugenia付出的努力（或者支付给靓号池付出的）迫使攻击者不得不生成更长的靓号模式。如果Eugenia花钱请矿池生成8个字符的靓号地址，攻击者将会被迫生成10个字符，这将是个人电脑，甚至订制的昂贵靓号挖矿机或靓号池也无法生成的。对Eugenia来说可能还能承担的起，但对攻击者来说却一定是承受不起，特别如果欺诈的潜在回报不足以抵消生成靓号地址所需的费用。 4.5.3 纸钱包 纸钱包是打印在纸张上的比特币私钥。有时纸钱包为了方便起见也包括对应的比特币地址，但这并不是必要的，因为地址可以从私钥中派生。纸钱包是一个非常有效的建立备份或者线下存储比特币（即冷存储）的方式。作为备份机制，纸钱包可以提供安全性，以防在电脑硬盘损坏、失窃或意外删除的情况下造成密钥的的丢失。作为冷存储机制，如果纸钱包密钥在线下生成并且从来没在电脑中存储过，那么在防范黑客攻击，键盘记录器，或其他在线电脑威胁方面会更加安全。 纸钱包有许多不同的形状，大小，和外观设计，但基本原则就是密钥和地址打印在纸上。表4-9展现了纸钱包最基本的形式。 表4-9 比特币纸钱包的私钥和公钥的打印形式 Public address Private key (WIF) 1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 使用工具，可以很容易地生成纸钱包，譬如使用bitaddress.org网站上的\"client-side JavaScript generator\"。这个页面包含所有生成密钥和纸钱包所必须的代码，甚至在完全断网的情况下，也可以生成密钥和纸钱包。方法是，把HTML页面保存在本地磁盘或外部U盘。然后断开互联网，用浏览器打开文件。更推荐，使用一个纯净版操作系统启动电脑，比如光盘启动的Linux系统。在脱机情况下使用这个工具所生成的密钥，都可以通过USB线（不能用无线）在本地打印机上打印出来，这样就创造了一个纸钱包，其中的密钥只存在纸张上从未存储在任何在线系统上。将这些纸钱包放置在防火保险柜内，然后发送比特币到这个比特币地址上，就实现了一个简单但非常有效的冷存储解决方案。图4-8展示了通过bitaddress.org 生成的纸钱包。 图4-8展示了通过bitaddress.org 生成的纸钱包 这个简单的纸钱包系统的不足之处是那些被打印下来的密钥容易被盗窃。一个能够接近这些纸张的小偷只需偷走它或者用相机拍照，就能控制被这些密钥锁定的比特币。一个更复杂的纸钱包存储系统是使用BIP-38加密私钥。所有者使用一个记在脑中的口令保护打印在纸钱包上的这些私钥。没有口令，这些被加密过的密钥毫无用处。纸钱包仍旧优于用密码保护的钱包，因为这些密钥从没有在线过，并且必须从保险箱或者其他物理安全存储设备中取走。图4-9展示了通过bitaddress.org 生成的加密纸钱包。 图4-9 通过bitaddress.org 生成的加密纸钱包的例子，密码：test 警告 虽然你可以多次向纸钱包存款，但最好一次性提取里面所有的资金。因为在解锁和花费资金的过程中，如果你没有一次性全部提取，钱包会生成一个找零地址。如果签名交易所用的计算机存在安全隐患，就有可能泄露私钥，丢失找零地址中的资金。一次性提走所有资金可以减少私钥泄露的风险，如果你所需的金额比较少，可以把剩余的资金一次性发送到一个新的纸钱包里。 纸钱包有许多设计形式和大小尺寸，还有许多不同的特征。还可以作为礼物送给别人，有季节性的主题，像圣诞节和新年主题。另一些设计用于存放在银行金库或带有密码保护的保险箱中，要么用不透明的刮擦标签，要么用防篡改的胶纸折叠密封。图4-10至图4-12展示了几个不同安全和备份功能的纸钱包的例子。 图4-10 从bitcoinpaperwallet.com生成的、私钥写在折叠袋上的纸钱包 图4-11 从bitcoinpaperwallet.com 生成的、私钥被密封住的纸钱包 其他设计有密钥和地址的额外副本，类似于票根形式的可以拆卸存根，可以存储多个副本以防火灾、洪水或其他自然灾害。 图4-12 在备份“存根”上有多个密钥副本的纸钱包例子 "},"ch05.html":{"url":"ch05.html","title":"第五章 钱包","keywords":"","body":"第五章 钱包 “钱包”一词在比特币中有多重含义。 广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户资金访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。 狭义上，即从程序员的角度来看，“钱包”是指用于存储和管理用户密钥的数据结构。 我们将深入介绍第二层含义，本章中钱包是私钥的容器，一般是通过结构化文件或简单数据库来实现。 5.1 钱包技术概述 在本节中，我们总结了各种技术，它们为用户构建起友好，安全和灵活的比特币钱包。 关于比特币的常见误解是，比特币钱包里含有比特币。事实上，钱包里只含有密钥。“币”被记录在比特币网络的区块链中。 用户使用钱包中的密钥签名交易，从而控制网络上的钱币。某种意义上，比特币钱包是密钥链。 提示 比特币钱包只含有密钥，而不是币。每个用户都有一个包含多个密钥的钱包。 钱包只包含私钥/公钥对的密钥链（请参阅第四章）。用户用密钥签名交易，从而证明他们拥有这笔交易的输出（他们的钱币）。钱币以交易输出的形式存储在区块链中（通常记为vout或txout）。 根据钱包包含的多个密钥之间是否有关系，主要分为两种类型： 第一种类型是非确定性钱包（nondeterministic wallet），其中每个密钥都是从随机数独立生成的。密钥彼此无关。这种钱包也被称为“Just a Bunch Of Keys（一堆密钥）”，简称JBOK钱包。 第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分层确定性（hierarchical deterministic）钱包或HD钱包。 确定性钱包由种子进行初始化的。为了便于使用，种子被编码为英文单词，也称为助记词（mnemonic code words）。 接下来的几节将深入介绍这些技术。 5.1.1 非确定性（随机）钱包 在第一个比特币客户端中（ 现在叫Bitcoin Core）中，钱包只是随机生成的私钥的集合。举个例子，Bitcoin Core客户端第一次启动时预先生成100个随机私钥，之后根据需要再生成足够多的密钥，并且每个密钥只使用一次。这种钱包现在正在被确定性钱包替换，因为它们难以管理、 备份以及导入。随机密钥的缺点就是如果你生成很多密钥，就必须保存它们所有的副本。这就意味着这个钱包必须频繁地备份。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就会无法挽回地丢失。这就与避免地址重复使用的原则相冲突：每个比特币地址只能用于一次交易。地址重复使用会把多个交易和地址关联在一起，会减少隐私。零型非确定性钱包不是好的选择，特别是要避免重复使用地址，因为要管理更多的密钥，还要更频繁地备份。虽然Bitcoin Core客户端包含0型钱包，但Bitcoin Core开发者并不鼓励大家使用。图5-1展示的是一个非确定性钱包，其含有的随机密钥是个松散的集合。 提示 除了简单的测试之外，任何场合都不鼓励使用非确定性钱包。 对于备份和使用来说太麻烦了。相反，推荐使用基于行业标准的HD钱包，只需要备份种子助记词。 图5-1 0型非确定性（随机）钱包：随机钥匙的集合 5.1.2 确定性（基于种子）钱包 确定性，或者“基于种子”钱包包含的私钥都是使用相同种子，通过单向哈希函数衍生而来的。种子是随机生成的数字。还和别的数据，比如索引号码或者“链码”（参见“ 分层确定性钱包（BIP-32/BIP-44）”一节）结合起来派生私钥。在确定性钱包中，只需要种子就足够恢复所有的派生的私钥，所以只要在初始创建时，一个简单备份就足够。种子也足以用于钱包导入或者导出，允许在不同钱包实现之间轻松迁移所有用户密钥。图5-2展示了确定性钱包的逻辑图。 图5-2 1型确定性(基于种子钱包）：从种子派生的密钥的确定性序列 5.1.3 分层确定性钱包（HD Wallets (BIP-32/BIP-44)） 确定性钱包被开发成更容易从单个“种子”中生成许多密钥。确定性钱包的最高级形式是通过BIP-32标准定义的HD钱包。HD钱包包含的密钥以树状结构衍生，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。图5-3展示了这种树状结构。 图5-3 2型HD钱包:从种子产生的密钥树 相比较随机（不确定性）密钥，HD钱包有两个主要的优势。第一，树状结构可以被用来表达附加的组织含义，比如子密钥的特定分支用来接收交易收入款项，另一个分支用来负责接收对外付款的找零。密钥的分支也可以用于公司设置，将不同的分支分配给部门、子公司、特定功能或会计类别。 HD钱包的第二个好处是，用户可以创建一系列公钥，而不需要访问对应的私钥。这样，HD钱包就能用在不安全的服务器上，或者仅作为接收用途，它为每个交易发布不同的公钥。公钥不需要被预先加载或者提前衍生，服务器也不需要有用来支付的私钥。 5.1.4 种子和助记词（BIP-39） HD钱包具有管理多个密钥和多个地址的强大机制。如果将它们与一种标准化的方法相结合，从一系列英文单词创建种子，这些单词更易于转录、导出和跨钱包导入，那么它们将更加有用。 这些英文单词被称为助记词，标准由BIP-39定义。 今天，大多数比特币钱包（以及其他加密货币的钱包）使用此标准，使用可互操作的助记词导入和导出种子进行备份和恢复。 让我们从实际的角度来看以下哪些种子更容易转录，记录在纸上、无错拼读、导出导入到别的钱包： 16进制表示的确定性钱包的种子： 0C1E24E5917779D297E14D45F14E1A1A 12个单词的助记词表示的确定性钱包的种子： army van defense carry jealous true garbage claim echo media make crunch 5.1.5 钱包最佳实践 由于比特币钱包技术已经成熟，出现了一些常见的行业标准，使得比特币钱包具备广泛互操作，易于使用，安全和灵活的特性。这些常用的标准是： 助记码，基于BIP-39 HD钱包，基于BIP-32 多用途HD钱包结构，基于BIP-43 多币种和多帐户钱包，基于BIP-44 这些标准可能会随着发展而改变或过时，但是现在它们形成了一套互锁技术，这些技术事实上已成为比特币的钱包标准。 这些标准已被软件和硬件比特币钱包广泛采用，使所有这些钱包实现互操作。用户导出在其中一个钱包上生成的助记词，再导入另一个钱包，就可以恢复所有交易，密钥和地址。 支持这些标准的软件钱包，有（按字母顺序排列）Breadwallet，Copay，Multibit HD和Mycelium。支持这些标准的硬件钱包，有（按字母顺序排列）Keepkey，Ledger和Trezor。 以下部分将详细介绍这些技术。 提示 如果您正准备实施一个比特币钱包，那么应该构建为一个HD钱包，遵循BIP-32，BIP-39，BIP-43和BIP-44标准，将种子编码为助记词用以备份，像下面章节会描述的。 5.1.6 使用比特币钱包 在之前的用户故事中，我们介绍了Gabriel，里约热内卢是一个有进取心的少年，他正在经营一家简单的网络商店，销售比特币品牌的T恤，咖啡杯和贴纸。 Gabriel使用图5-4的Trezor比特币硬件钱包来安全地管理他的比特币。 Trezor是一个简单的USB设备，具有两个按钮，用于存储密钥（以HD钱包的形式）和签署交易。 Trezor钱包遵循本章讨论的所有行业标准，因此Gabriel不依赖于任何专有技术或单一供应商解决方案。 图5-4 Trezor设备：比特币硬件HD钱包 当Gabriel首次使用Trezor时，设备从内置的硬件随机数生成器生成助记词和种子。 在钱包初始化阶段，屏幕上会按顺序逐个显示单词（见图5-5）。 图5-5 Trezor显示的其中一个助记词 写下这个助记词，Gabriel就创建了一个备份（参见表5-1），可以在Trezor设备丢失或损坏的情况下用于恢复。记下来的助记词可以在新的Trezor钱包，或者任一种兼容的软件和硬件钱包进行恢复。 请注意，单词顺序非常重要，因此，助记词记录在纸上时，每个单词之间都要有空格。Gabriel必须仔细地把每个单词都记录在编号的空格里，以保持正确的顺序。 表5-1 Gabriel的助记器备份 1. army 7. garbage 2. van 8. claim 3. defense 9. echo 4. carry 10. media 5. jealous 11. make 6. true 12. crunch 提示 为了简单起见，表5-1显示了12个单词。 事实上，大多数硬件钱包生成更安全的24个词的助记符。 助记词使用的方式都是相同的，与长度无关。 作为网店的第一次实践，Gabriel使用他的Trezor设备生成一个比特币地址。所有客户的订单都使用此单一地址。 我们将看到，这种方法有一些缺点，不过可以使用HD钱包进行改进。 5.2 钱包技术细节 现在我们开始逐个深入了解这些比特币钱包所使用的重要的行业标准。 5.2.1 助记词（BIP-39） 助记词是表示（编码）随机数的一组有序的英文单词，用作生成确定性钱包的种子。这些有序单词足以重建种子，并且从种子重新创建钱包以及所有派生的密钥。使用助记词实现确定性钱包的应用会在首次创建钱包时，向使用者展示一个12至24个有序的单词。这些有序单词就是钱包的备份，就可以用来恢复以及重建相同或兼容钱包应用程序的密钥。与随机数序列比较，助记词可以让使用者备份钱包更容易一些，因为更容易阅读和正确抄写。 提示 助记词经常与“脑钱包”混淆。 他们不一样。主要区别在于脑钱包包含用户选择的单词，而助记词是由钱包随机创建呈现给用户的。 这个重要的区别使助记词更加安全，因为人类的随机数来源还是很贫乏的。 助记词定义在比特币BIP-39中（参见【附录3、比特币改进建议（BIPs）】）。需要注意的是，BIP-39是助记词的标准实施方案。还有另外一个标准，使用一组不同的单词，早于BIP-39由Electrum钱包使用。 BIP-39由Trezor硬件钱包的母公司提出，与Electrum的实施不兼容。 其实，BIP-39现在已经通过数十个可互操作的实施获得了广泛的行业支持，已被视为事实上的行业标准。 BIP-39定义了助记词和种子的创建，我们在这里总结为九个步骤。 为了清楚起见，整个过程分为两部分： 1-6步见5.2.2创建助记词，7-9步见5.2.3从助记词到种子。 5.2.2创建助记词 助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表： 1、创建一个128到256位的随机序列（熵）。 2、提取SHA256哈希的前（熵长/ 32的比值）位，创造随机序列的校验和。 3、将校验和添加到随机序列的末尾。 4、将序列拆分为11位长度的多个段。 5、将每个11位值映射为有2048个单词的预定义字典中的一个单词。 6、生成的有顺序的单词组就是助记码。 图5-6展示了熵如何生成助记词。 图5-6 熵的产生和助记词的编码 表5-2表示了熵数据的大小和助记词的长度之间的关系。 表5-2助记词：熵及助记词长度 Entropy (bits) Checksum (bits) Entropy + checksum (bits) Mnemonic length (words) 128|4|132|12 160|5|165|15 192|6|198|18 224|7|231|21 256|8|264|24 5.2.3 从助记词生成种子 助记词表示长度为128至256位的熵。 通过使用密钥延伸函数PBKDF2，熵被用于导出更长的（512位）种子。产生的种子用于构建确定性钱包并导出密钥。 密钥延伸函数有两个参数：助记词和盐（salt）。 密钥延伸函数中盐的目的是增加构建暴力攻击使用的查找表的难度。 在BIP-39标准中，盐还有另一目的，引入密码口令（passphrase），作为保护种子的附加安全因素，我们将在BIP-39可选密码口令章节详细描述。 创建助记词之后的7-9步是： 7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记词。 8、PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“mnemonic”与可选的用户提供的密码口令一起组成。 9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记词和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。 图5-7显示了从助记词如何生成种子 图5-7 从助记词到种子 提示 密钥延伸函数，使用2048次哈希是一种非常有效的保护，可以防止对助记词或密码口令的暴力攻击。 它使得攻击尝试非常昂贵（从计算的角度），需要尝试超过几千个密码和助记词组合，而这样可能产生的种子的数量是巨大的（2512）。 表5-3、5-4和表5-5展示了一些助记码的例子和它所生成的种子(有的带密码口令，有的不带)。 表5-3 128位熵助记词，没有密码口令产生的种子 参数|实例 |:-|:-| |Entropy input (128 bits)|0c1e24e5917779d297e14d45f14e1a1a| |Mnemonic (12 words)|army van defense carry jealous true garbage claim echo media make crunch Passphrase|(none)| |Seed (512 bits)|5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39 a88b76373733891bfaba16ed27a813ceed498804c0570| 表5-4 128位熵助记词，有密码口令产生的种子 参数|实例 |:-|:-| |Entropy input (128 bits)|0c1e24e5917779d297e14d45f14e1a1a| |Mnemonic (12 words)|army van defense carry jealous true garbage claim echo media make crunch Passphrase|SuperDuperSecret| |Seed (512 bits)|3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28ab3ab091897d0 715861dc8a18358f80b79d49acf64142ae57037d1d54| 表5-5 256位熵助记词，没有密码口令产生的种子 参数|实例 |:-|:-| |Entropy input (256 bits)|2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c| |Mnemonic (24 words)|cake apple borrow silk endorse fitness top denial coil riot stay wolf luggage oxygen faint major edit measure invite love trap field dilemma oblige| |Passphrase|(none)| |Seed (512 bits)|3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3a04356e53d062e5 5f1e0deaa082df8d487381379df848a6ad7e98798404| 5.2.4 BIP-39中的可选密码口令 BIP-39标准允许在推导种子时使用可选的密码口令。 如果没有使用密码口令，助记词是用由常量字符串“mnemonic”构成的盐进行延伸，从任何给定的助记词产生一个特定的512位种子。 如果使用密码短语，密钥延伸函数使用同样的助记词也会产生不同的种子。事实上，使用同一个助记词，每一个可能的密码口令都会导致不同的种子。 基本上没有“错误”的密码口令， 所有密码口令都是有效的，它们都会导致不同的种子，形成一大批未初始化的钱包。这些钱包数量非常之多（2512），根本不可能使用暴力破解或随机猜测。 提示 BIP-39中没有“错误的”密码口令。 每个密码都会导致一些钱包，只是未使用的钱包是空的。 可选密码口令带来两个重要功能： （存储在大脑中的）密码口令成为第二重保护，使得仅有助记词是不够的，避免了助记词备份被盗取后利用。 起到掩人耳目的效果或“胁迫钱包”，把选定的密码口令指向有小额资金的钱包，分散攻击者注意力，使其不再关注拥有大额资金的“真实”钱包。 然而，需要注意的是，使用密码口令也会引起丢失的风险： 如果钱包所有者无行为能力或死亡，没有人知道密码，种子就是无用的，所有存储在钱包中的资金都将永远丢失。 相反，如果所有者将密码口令与种子备份在相同的地方，则失去第二重保护的目的。 虽然密码口令非常有用，但考虑到钱包拥有者幸存的可能性，以及允许其家人收回加密货币财产，密码口令只能与精心规划的备份和恢复过程结合使用。 5.2.5 使用助记词 BIP-39作为函数库实施，支持多种编程语言： python-mnemonic SatoshiLabs团队提出了BIP-39的Python标准参考实现 bitcoinjs/bip39 BIP-39的JavaScript实现是流行的bitcoinJS框架的一部分。 libbitcoin/mnemonic BIP-39的C++实现是流行的Libbitcoin框架的一部分。 还有一个BIP-39在独立的网页中实现的生成器，非常适合用于测试和实验。图5-8展示一个独立的网页，可以生成助记词、种子和扩展私钥。 图5-8 独立的网页BIP-39生成器 BIP-39生成器可以在线或离线使用，可以使用这个在线地址。 5.3 从种子创造HD钱包 HD钱包从单个根种子（root seed）创建，后者为128，256到512位的随机数。最常见的是，这个种子是从助记词产生的，如上一节所述。 HD钱包的所有密钥是由根种子确定的，使用这个根种子就可以在任何兼容HD钱包中重新创造整个HD钱包。所以简单的转移生成HD钱包根种子的助记词就可以很容易地备份，储存导出以及导入HD钱包中所包含的数以千计百万计的密钥。 图5-9展示从根种子创建主密钥以及HD钱包的主链码的过程。 图5-9 从根种子创建主密钥，主链码 根种子作为HMAC-SHA512算法的输入，得到的哈希值可以用来创造主私钥master private key（m) 和 主链码master chain code（c） 。 主私钥（m）使用标准椭圆曲线乘法过程m * G生成对应的主公钥（M）。 链码用于从父密钥创造子密钥的函数中引入熵。如下一节所示。 5.3.1 私有子密钥的衍生 分层确定性钱包使用子密钥衍生child key derivation，简称CKD函数从父密钥衍生出子密钥。 子密钥衍生函数是基于单向哈希函数。这个函数结合了： 一个父私钥或者父公钥（ECDSA压缩密钥） 一个叫做链码（256 位）的种子 一个索引号（32 位） 链码是用来给这个过程引入确定性随机数据的，使得仅凭索引和子密钥也不足以衍生其他子密钥。因此，有了子密钥并不能发现自己的姊妹密钥，除非再有了链码。最初的链码种子（在密码树的根部）是用种子制造的，随后的子链码从各自的父链码衍生出来。 这三个项目（父密钥，链码，索引）相结合并哈希计算生成子密钥，如下。 父公钥，链码以及索引号合并在一起用HMAC-SHA512算法哈希计算之后产生512位的哈希值。所得的哈希拆分为两部分。右半部分的256位成为子链链码。左半部分256位附加到父私钥来衍生子私钥。在图5-10中，我们看到，索引设置为0，生成父级的“0”子级（第一个索引）。 图5-10 扩展父私钥创建子私钥 改变索引允许我们扩展父级，并按顺序创建其他子级，例如子级0、子级1、子级2等。每一个父密钥可以有2,147,483,647 (231) 个子密钥。(231是整个232范围可用的一半，另一半是为特定类型的推导而保留的，我们将在本章稍后讨论。) 向密码树下一层重复这个过程，每个子密钥可以依次成为父密钥，继续创造它自己的子密钥，直到无限代。 5.3.2 使用衍生的子密钥 子私钥与不确定（随机）密钥区别不大。因为衍生函数是单向的，所以子密钥不能被用来发现它的父密钥。子密钥也不能用来发现它们的相同层级的姊妹密钥。如果你有第n个子密钥，你不能发现它的姐妹密钥，比如前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。只有父密钥以及链码才能得到所有的子密钥。没有子链码，子密钥也不能衍生出任何孙密钥。你需要同时有子私钥以及对应的子链码才能创建一个新的分支，衍生出孙密钥。 那子私钥自己可被用做什么呢？它可以用来制作公钥和比特币地址。之后它就可以被用于对那个地址签署交易和支付花费。 提示 子私钥、对应的公钥和比特币地址都与随机创建的密钥和地址不可区分。它们是序列的一部分这一事实在创建它们的HD钱包功能之外是看不到的。一旦被创造出来，它们就和“正常”密钥一样工作了。 5.3.3 扩展密钥 正如我们之前看到的，密钥衍生函数可以被用来创造密钥树上任何层级的子密钥，基于以下三个输入量：密钥，链码以及想要的子密钥的索引。密钥以及链码这两个重要的部分被结合之后，就叫做扩展密钥（extended key）。术语“扩展密钥”也被认为是“可扩展的密钥”，因为这种密钥可以用来衍生子密钥。 扩展密钥被储存并且简单地表示为将256位密钥与256位链码所串成的512位序列。有两种类型扩展密钥。扩展的私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公钥）。公钥以及链码组成扩展公钥，它可以用来创建子公钥（只能是公钥），见“生成公钥”章节。 扩展密钥作为HD钱包中密钥树结构的一个分支的根。你可以衍生出这个分支的剩下所有部分。扩展私钥可以创建一个完整的分支，而扩展公钥只能够创造公钥的分支。 提示 一个扩展密钥包括一个私钥或者公钥和一个链码。一个扩展密钥可以创造出子密钥并且能创造出密钥树结构中的整个分支。共享了扩展密钥就可以访问整个分支。 扩展密钥通过Base58Check来编码，很容易在不同的BIP-32兼容钱包之间导入导出。扩展密钥编码用的 Base58Check使用特殊的版本号，Base58编码字符前缀分别为“xprv”和“xpub”，这种前缀可以让编码更易被识别。因为扩展密钥是512或者513位，所以它比我们之前所看到的Base58Check编码串更长一些。 以下面的扩展私钥为例，其使用的是Base58Check编码： xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c 下面是上面扩展私钥对应的扩展公钥，同样使用Base58Check编码： xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9 5.3.4 公用子密钥的衍生 正如之前提到的，分层确定性钱包的一个很有用的特点就是可以不通过私钥而直接从父公钥派生出子公钥。这就给了我们两种衍生子公钥的方法：或者通过子私钥，或者直接通过父公钥。 因此，扩展公钥可以在HD钱包结构的分支中，用来衍生所有的公钥（且只有公钥）。 这种快捷方式可以用来创造非常安全的只有公钥部署环境。这个环境中，服务器或者应用程序不管有没有私钥，只要有扩展公钥的副本就可以。这种部署可以创造出无限数量的公钥以及比特币地址，但是不能花费发送到这个地址里的任何比特币。与此同时，在另一种更安全的服务器上，扩展私钥可以衍生出对应的私钥，签署交易支付花费。 这种方案的常见应用是安装扩展公钥在电商的web服务器上。web服务器可以使用公钥衍生函数去给每一笔交易（比如客户的购物车）创造一个新的比特币地址。服务器没有私钥，也就避免了被盗的风险。没有HD钱包的话，唯一的方法就是在不同的安全服务器上创造成千上万个比特币地址，之后再预加载到电子商务服务器上。这种方法非常繁琐而且要需要持续的维护来确保电商服务器不会“用光”公钥。 这种解决方案的另一种常见的应用是冷存储或者硬件钱包。在这种情况下，扩展私钥可以被储存在纸钱包中或者硬件设备中（比如 Trezor 硬件钱包），扩展公钥可以在线保存。使用者可以根据意愿创造“接收”地址而私钥可以安全地在线下保存。为了支付资金，使用者可以使用扩展私钥离线签署比特币客户端应用或者签署硬件钱包设备（比如 Trezor）上的交易。例5-11说明了扩展父公钥以派生子公钥的机制。 例5-11 扩展父公钥以创建子公钥 5.3.5 在网店中使用扩展公钥（xpub） 继续Gabriel网店的故事，让我们看看Gabriel是如何使用HD钱包。 Gabriel建立一个简单的托管的WordPress页面，作为他的网上商店。它的网店非常简单，只有几个页面和带有比特币地址的订单表格。 Gabriel使用他的Trezor设备生成的第一个比特币地址作为他的商店的主要比特币地址。这样，所有收到的款项都支付到了这个Trezor硬件钱包所控制的地址。 客户可以使用表格提交订单，并向Gabriel发布的比特币地址付款，触发一封电子邮件发送给Gabriel，其中包含订单详细信息。每周只有几个订单的时候，这个系统运行得很好。 然而，这个小型网店变得相当成功，并吸引了当地社区的很多订单。Gabriel很快就不堪重负。由于所有订单都支付到相同的地址，因此很难正确匹配订单和交易，尤其是同时接到同一数量的多个订单时。 HD钱包可以在不知道私钥的情况下获取子公钥，该能力为Gabriel提供了更好的解决方案。 Gabriel可以在他的网站上加载一个扩展公钥（xpub），这可以为每个客户订单生成一个唯一的地址。Gabriel可以花费他在Trezor里的资金，但加载在网站上的xpub只能生成地址并收到资金。HD钱包的这个功能非常安全。 Gabriel的网站不包含任何私钥，因此不需要高级别的安全性。 为了导出xpub，Gabriel将基于Web的软件与Trezor硬件钱包配合使用。必须插入Trezor设备才能导出公钥。请注意，硬件钱包永远不会导出私钥，这些密钥始终保留在设备上。图5-12显示了Gabriel用于导出xpub的Web界面。 图5-12 从Trezor硬件钱包导出xpub Gabriel将xpub复制到他网店的比特币商店软件中。 他使用的软件是Mycelium Gear，这是一个网店的开源插件，用于各种web托管和内容平台。 Mycelium Gear使用xpub为每次购买生成一个唯一的地址。 5.3.6 强化子密钥的衍生 从xpub衍生一个分支公钥的能力是很重要的，但牵扯一些潜在风险。访问xpub并不能访问子私钥。但是，因为xpub包含有链码，如果子私钥被知道或者被泄漏的话，链码就可以被用来衍生所有的其他子私钥。泄露的私钥如果再加上父链码，就可能暴露所有子项的所有私钥。更糟糕的是，子私钥与父链码可以用来推断父私钥。 为了应对这种风险，HD钱包使用一种替代衍生函数，叫做强化衍生(hardened derivation），“打破”了父公钥以及子链码之间的关系。这个强化衍生函数使用了父私钥去推导子链码，而不是父公钥。这就在父/子顺序中创造了一道“防火墙”，链码就不能危害父私钥或者同级私钥。强化衍生函数看起来与常规的子私钥衍生相同，不同的是父私钥可以作为哈希函数的输入，而父公钥不行，如图5-13所示。 图5-13 子密钥的强化衍生，省略父公钥 当使用强化私钥衍生函数时，得到的子私钥以及链码与使用常规衍生函数所得到的结果完全不同。得到的密钥“分支”可以被用来生产不易被攻击的扩展公钥，因为它所含的链码不能被用来泄露任何私钥。强化衍生也因此被用在使用扩展公钥的密钥树的上一层创造“隔层”。 简单来说，如果想利用xpub的便捷来衍生公钥的分支，又不想冒泄露链码的风险， 就该从强化父密钥，而不是常规父密钥衍生。最好的方式是，为了避免主密钥泄露，主密钥所衍生的第一层级的子密钥总是通过强化衍生得来。 5.3.7 常规衍生和强化衍生的索引号 用在衍生函数中的索引号是32位整数。为了区分密钥是从常规衍生函数中衍生出来还是从强化衍生函数中产出的，这个索引号被分为两个范围。索引号在0和231–1(0x0 to 0x7FFFFFFF)之间的只用于常规衍生。索引号在231和232– 1(0x80000000 to 0xFFFFFFFF)之间的只用于强化衍生。因此，索引号小于231就意味着子密钥是常规的，而大于或者等于231的子密钥就是强化的。 为了让索引号更容易被阅读和展示，强化子密钥的索引号是从0开始展示的，但是右上角有一个小撇号。第一个常规子密钥就表示为0，第一个强化子密钥（索引号为0x80000000）就表示为0'。第二个强化密钥依序有了索引号0x80000001，表示为1'，以此类推。当你看到HD钱包索引号i'，这就意味着 231+i。 5.3.8 HD钱包密钥识别符（路径） HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）来表示（见表5-6）。由主私钥衍生的私钥以“m”开头。由主公钥衍生的公钥以“M“开。因此，主私钥的第一个子私钥是m/0。第一个子公钥是M/0。第一个子私钥的第二个孙私钥（对于主私钥来说是孙私钥）就是m/0/1，以此类推。 密钥的“祖辈”是从右向左读，直到衍生它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥，m/x又是m的第x个子密钥。 表5-6 HD钱包路径的例子 HD 路径 密钥描述 m/0 主私钥(m)衍生的第一个子私钥(0) m/0/0 第一个子私钥 (m/0)衍生的第一个子私钥(0) m/0'/0 第一个强化子密钥 (m/0')衍生的第一个常规子密钥（0） m/1/0 第二个子密钥 (m/1)衍生的第一个字私钥(0) M/23/17/0/0 第24个子密钥(M/23)衍生的第18个子密钥(M/23/17)的第一个字密钥(M/23/17/0)的第一个子公钥(0) 5.3.9 浏览HD钱包树状结构 HD钱包树状结构提供了极大的灵活性。每一个父扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只这个树结构可以无限类推到无穷代。但是，又由于这个灵活性，无限的树状结构进行导航就变得异常困难。尤其是更换不同的HD钱包，因为内部组织到分支以及子分支的可能性是无穷的。 有两个BIP提供了这个复杂问题的解决办法——通过为HD钱包树的结构创建建议标准。BIP-43提出使用第一个强化子索引作为表示树结构“用途”（purpose）的特殊标识符。基于BIP-43，HD钱包应该只使用树的第一个一级分支，其余部分的结构和名称空间由索引号通过定义其用途来标识。举个例子，只使用分支m/i'/的HD钱包，表示特定用途，该用途由索引号“i”标识。 对上述规范进行了扩展，BIP-44提议使用多账户结构，使用44'这个号码作为BIP-43的“用途”。所有遵循BIP-44的HD钱包按照只使用树的第一个分支的要求,被定义为：m/44'/。 BIP-44指定了包含5级预定义树的结构： m / purpose' / coin_type' / account' / change / address_index 第一层的purpose总是被设定为44'。第二层的“coin_type”特指币种，允许多币种HD钱包中的每一种数字货币在第二层级下都有自己的子树。目前有三种货币被定义：Bitcoin 是 m/44'/0'、Bitcoin Testnet 是 m/44'/1'，以及 Litecoin 是 m/44'/2'。 树的第三层级是“account”，允许用户为了会计或者组织目的，再细分钱包到独立的逻辑性子账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m/44'/0'/0' 和 m/44'/0'/1'。每个账户都是它自己子树的根。 第四层级就是“change”。每一个HD钱包有两个子树，一个是接收地址，另一个用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许树的这一层级可以在不安全环境下，导出扩展公钥。可用的地址由HD钱包派生为第四层级的子级，就是第五层级“address_index”。比如，比特币主账户的第三个收款地址就是 M/44'/0'/0'/0/2。表5-7展示了更多的例子。 表5-7 BIP-44 HD 钱包结构的例子 HD path Key described M\\/44'\\/0'\\/0'\\/0\\/2 比特币主账户的第三个收款公钥 M\\/44'\\/0'\\/3'\\/1\\/14 比特币第四个账户的第十五个找零收款公钥 m\\/44'\\/2'\\/0'\\/0\\/1 Litecoin主账户中的第二个私钥，用于签名交易 "},"ch06.html":{"url":"ch06.html","title":"第六章 交易","keywords":"","body":"第六章 交易 6.1 简介 比特币交易是比特币系统中最重要的部分。比特币中的其他一切都是为了确保交易可以被创建、在网络上传播、验证，并最终添加到全局交易分类账本（区块链）中。比特币交易的本质是数据结构，这些数据结构是对比特币交易参与者价值传递的编码。比特币区块链是一本全局复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。 在这一章，我们将会剖析比特币交易的多种形式、所包含的信息、如何被创建、如何被验证以及如何成为所有比特币交易永久记录的一部分。在本章中使用的术语“钱包”，指的是构建交易的软件，而不仅仅是密钥数据库。 6.2 交易细节 在【第二章比特币概述】中，我们使用区块浏览器查看了Alice曾经在Bob的咖啡店支付咖啡的交易（图6-1）。 区块浏览器应用程序显示从Alice的“地址”到Bob的“地址”的交易。 这里显示的是交易内容的简化视图。 实际上，正如我们将在本章中看到的，所显示的大部分信息都是由区块浏览器构建的，并不在交易中。 图6-1 Alice与Bob咖啡店的交易 6.2.1 交易 - 幕后细节 在幕后，实际的交易看起来与典型的区块浏览器提供的交易非常不同。 事实上，我们在各种比特币应用程序用户界面中看到的大多数高级结构并不存在于比特币系统中。 我们可以使用Bitcoin Core的命令行界面（getrawtransaction和decodeawtransaction）来检索Alice的“原始”交易，对其进行解码，并查看它包含的内容。 结果如下： Alice的交易被解码后是这个样子： { \"version\": 1, \"locktime\": 0, \"vin\": [ { \"txid\":\"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\": \"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\", \"sequence\": 4294967295 } ], \"vout\": [ { \"value\": 0.01500000, \"scriptPubKey\": \"OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG\" }, { \"value\": 0.08450000, \"scriptPubKey\": \"OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\", } ] } 您可能会注意到这笔交易似乎少了些什么东西，比如：Alice的地址在哪里？Bob的地址在哪里？ Alice发送的“0.1”个币的输入在哪里？ 在比特币里，没有具体的货币，没有发送者，没有接收者，没有余额，没有帐户，没有地址。为了使用者的便利，以及使事情更容易理解，所有这些都构建在更高层次上。 你可能还会注意到很多奇怪和难以辨认的字段以及十六进制字符串。 不必担心，本章将详细介绍这里所示的各个字段。 6.3 交易的输入输出 比特币交易的基本组成部分是交易输出transaction output。 交易输出是比特币不可分割的基本组合，记录在区块链上，并被整个网络认可有效。 比特币全节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”（unspent transaction outputs），即UTXO。 所有UTXO的集合被称为UTXO集，目前有数百万个UTXO。 当新的UTXO被创建，UTXO集就会变大，当UTXO被消耗时，UTXO集会随着缩小。每一个交易都代表UTXO集的变化（状态转换）。 当用户的钱包已经“收到”比特币时，就意味着，钱包已经检测到了可用的UTXO，这些UTXO可以用钱包所控制的其中一个密钥消费。 因此，用户的比特币“余额”是指用户钱包中可用的UTXO总和，这些UTXO分散在几百个交易和几百个区块中。用户的 “比特币余额”，这个概念是比特币钱包应用创建的。比特币钱包扫描区块链，得到可以用这个钱包控制的密钥进行消费的所有UTXO，加到一起就计算出了该用户的余额 。大多数钱包维护一个数据库或使用数据库服务来存储所有UTXO的快速引用集，其中包含可以使用用户的密钥进行消费的所有UTXO。 一个UTXO可以是1“聪”（satoshi）的任意倍数（整数倍）。就像美元可以被分割成表示两位小数的“分”一样，比特币可以被分割成八位小数的“聪”。尽管UTXO可以是任意值，但一旦被创造出来，即不可分割。这是UTXO值得被强调的一个重要特性：UTXO的面值为“聪”的整数倍，是离散（不连续）且不可分割的价值单位，一个UTXO只能在一次交易中作为一个整体被消耗。 如果一个 UTXO比一笔交易金额大，它仍会被当作一个整体而消耗掉，但同时会在交易中生成找零。例如，你有一个价值20比特币的 UTXO，想支付1比特币，那么你的交易必须消耗掉整个20比特币的UTXO，产生两个输出：一个支付了1比特币给收款人，另一个支付19比特币的找零到你的钱包。这样的话，由于UTXO（或交易输出）的不可分割特性，大部分比特币交易都会产生找零。 想象一下，一位顾客要买1.5元的饮料。她掏出钱包并试图从所有硬币和钞票中找出一种组合来凑齐她要支付的1.5 元。如果可能的话，她会选刚刚好的零钱（比如一张1元纸币和5个一毛硬币）或者是小面额的组合（比如3个五毛硬币）。如果都不行的话，她会用一张大面额的钞票，比如5元纸币。如果她把5元给了商店老板，她会得到3.5元的找零，并把找零放回她的钱包供未来使用。 类似的，一笔比特币交易可以是任意金额，但必须从用户可用的UTXO中创建出来。用户不能再把UTXO进一步细分，就像不能把一元纸币撕开而继续当货币使用一样。用户的钱包应用通常会从用户可用的UTXO中选取多个来拼凑出一个大于或等于当前交易所需的比特币量。 就像现实生活中一样，比特币应用可以使用一些策略来满足付款需求：组合若干小额UTXO，并算出准确的找零；或者使用一个比交易额大的UTXO然后进行找零。所有这些复杂的、由可花费UTXO组成的集合，都是由用户的钱包自动完成， 并不为用户所见。只有当你以编程方式用UTXO来构建原始交易时，这些才与你有关。 一笔交易会消耗先前的已被记录（存在）的UTXO，并创建新的UTXO以备未来的交易消耗。通过这种方式，一定数量的比特币价值在不同所有者之间转移，并在交易链中消耗和创建UTXO。 交易的输出与输入链存在一个例外，即被称为创币交易Coinbase Transaction的特殊交易，它是每个区块中的第一笔交易，这笔交易是由“赢家”矿工放置的，创造了支付给该矿工的全新比特币，作为挖矿奖励。这个特殊的创币交易不消耗UTXO，相反，它有一个称为“coinbase”的特殊类型的输入。这也就是为什么比特币可以在挖矿过程中被创造出来，我们将在“第十章挖矿”进行详述。 提醒 输入和输出，先有那个呢？先有鸡还是先有蛋？严格来讲，先产生输出，因为创造新比特币的 “币基交易”没有输入，但它可以无中生有产生输出。 6.3.1 交易输出 每一笔比特币交易都会创造输出，并被比特币账簿记录下来。几乎所有的输出，除了一个例外（见“数据输出操作符”（OP_RETURN）），都能创造称为UTXO的比特币块，然后被整个网络识别，供所有者在未来交易中使用。 UTXO集中的UTXO被每一个全节点比特币客户端追踪。 新的交易从UTXO集中消耗（花费）一个或多个输出。 交易输出包含两部分： 一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位； 确定花费输出所需条件的加密难题（cryptographic puzzle） 这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。 有关交易脚本语言会在后面的“交易脚本和脚本语言”一节中详细讨论。 现在，我们来看看 Alice 的交易（之前的6.2.1“交易 - 幕后细节”所示），看看我们是否可以找到并识别输出。 在 JSON 编码中，输出位于名为 vout 的数组（列表）中： \"vout\": [ { \"value\": 0.01500000, \"scriptPubKey\": \"OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG\" }, { \"value\": 0.08450000, \"scriptPubKey\": \"OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\", } ] 如您所见，交易包含两个输出。 每个输出都由一个值和一个加密难题来定义。 在 Bitcoin Core 显示的编码中，这里的value值以比特币为单位，但在交易本身中，它被记录为以 “聪”为单位的整数。 输出的第二部分是设定支付条件的加密难题。 Bitcoin Core 将其显示为 scriptPubKey，后面跟一个可读的脚本。 稍后将在6.4.3 脚本构建（锁定与解锁）中讨论UTXO的锁定和解锁。 在ScriptPubKey 中使用的脚本语言在6.4比特币交易脚本和脚本语言中讨论。 但在深入研究这些话题之前，需要先了解交易输入和输出的整体结构。 6.3.1.1 交易序列化 - 输出 当交易通过网络传输或在应用程序之间交换时，它们是序列化的。 序列化是将数据结构的内部表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。 交易输出的序列化格式如表6-1所示： 表6-1交易输出序列化 Size Field Description 8 bytes (little-endian) Amount Bitcoin value in satoshis (10-8 bitcoin) 1–9 bytes (VarInt) Locking-Script Size Locking-Script length in bytes, to follow Variable Locking-Script A script defining the conditions needed to spend the output 大多数比特币库和框架在内部不会将交易存储为字节流，因为每次需要访问单个字段时，都需要复杂的解析。为了方便和可读性，比特币库在数据结构（通常是面向对象的结构）中存储交易。 从交易的字节流表示转换为库的内部表示数据结构的过程称为反序列化或交易解析。转换回字节流通过网络传输、哈希或存储在磁盘上的过程称为序列化。大多数比特币库都有用于交易序列化和反序列化的内置函数。 看看是否可以从序列化的十六进制形式手动解码 Alice 的交易，找到我们以前看到的一些元素。包含两个输出的部分在下面例6-1中加粗显示： 例6-1 Alice的交易，序列化十六进制表示 0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73 4d2804fe65fa35779000000008b483045022100884d142d86652a3f47 ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039 ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84 16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1 7b4a10fa336a8d752adfffffffff0260e31600000000001976a914ab6 8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000 1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac 00000000 这里有一些提示： 加粗显示的部分有两个输出，每个都如本节之前所述进行了序列化。 0.015比特币的价值是1,500,000 聪。 十六进制表示是16 e3 60。 在序列化交易中，值16 e3 60以小端（最低有效字节优先）字节顺序进行编码，所以它看起来像60 e3 16。 scriptPubKey的长度为25个字节，十六进制显示为19。 6.3.2交易输入 交易输入标识哪个UTXO（通过引用）将被消费，并通过解锁脚本提供所有权证明。 要构建一个交易，一个钱包从它控制的UTXO中选择足够的面值来支付请求的付款。 有时一个UTXO就足够，有时候需要不止一个。 对于用于付款的每个UTXO，钱包将创建一个指向该UTXO的输入，使用解锁脚本解锁它。 让我们更详细地看一下输入的组成内容。输入的第一部分是一个指向UTXO的指针，引用交易哈希和输出索引，这个索引标识了交易中的特定UTXO。 第二部分是解锁脚本，钱包构建它用以满足在UTXO中的支付条件。 大多数情况下，解锁脚本是一个证明比特币所有权的数字签名和公钥，但是并不是所有的解锁脚本都包含签名。 第三部分是序列号，稍后再讨论。 考虑一下我们在【6.2.1 交易 - 幕后细节】提到的例子。交易输入是一个名为 vin 的数组（列表）： \"vin\": [ { \"txid\": \"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\" : \"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\", \"sequence\": 4294967295 } ] 如您所见，列表中只有一个输入（因为一个UTXO的面值足够完成付款）。 输入包含四个元素： 一个交易ID，引用包含将要消费的UTXO的交易 一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零） 一个 scriptSig（解锁脚本），满足UTXO的消费条件，解锁用于支出 一个序列号（稍后讨论） 在 Alice 的交易中，输入指向的交易ID是： 7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18 输出索引是0（即由该交易创建的第一个UTXO）。解锁脚本由Alice的钱包创建，首先检索引用的UTXO，检查其锁定脚本，然后用它来构造满足要求的解锁脚本。 仅仅看这个输入，你可能已经注意到，除了涉及包含该UTXO的交易之外，我们无从了解这个UTXO的任何内容。不知道它的金额（多少聪），不知道锁定脚本的消费要求。要找到这些信息，必须通过检索整个交易来检索被引用的UTXO。请注意，由于输入的值未明确说明，因此还必须使用被引用的UTXO来计算需要支付的交易费（参见【6.3.3 交易费】）。 不仅仅是Alice的钱包需要检索输入中引用的UTXO。一旦将该交易广播到网络，每个验证节点也将需要检索交易输入中引用的UTXO，以验证该交易。 因为缺乏上下文，这些交易本身似乎不完整。它们在输入中引用了UTXO，但是如果不检索UTXO，我们就无法知道输入的值或其锁定条件。在编写比特币软件时，无论何时，只要是解码交易以验证交易、计算费用或检查解锁脚本，所编的代码就必须首先从区块链中检索引用的UTXO，以便构造输入引用的UTXO隐含但不存在的上下文。例如，要计算支付总额的交易费，必须知道输入和输出值的总和。但是，如果没有检索输入中引用的UTXO，就不能知道这些值。因此，在单个交易中计算交易费用看似简单，实际上涉及多个交易的多个步骤和数据。 我们可以使用与Bitcoin Core相同的命令序列，就像我们在检索Alice的交易（getrawtransaction和decodeawtransaction）时一样。可以得到在前面的输入中引用的UTXO，如下： Alice 的UTXO，输入中引用的来自以前的交易： \"vout\": [ { \"value\": 0.10000000, \"scriptPubKey\": \"OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\" } ] 我们看到这个UTXO的值为0.1BTC，并且它有一个包含“OP_DUP OP_HASH160 ...”的锁定脚本（scriptPubKey）。 提示 为了充分了解Alice的交易，我们必须检索作为输入引用的之前的交易。 检索以前的交易和未花费的交易输出的函数很常见，大多数比特币函数库和API中都有。 6.3.2.1 交易序列化--交易输入 当交易被序列化在网络上传输时，它们的输入被编码成字节流，如下表所示 表6-2 交易输入序列化 Size Field Description 32 bytes Transaction Hash Pointer to the transaction containing the UTXO to be spent 4 bytes Output Index The index number of the UTXO to be spent; first one is 0 1–9 bytes (VarInt) Unlocking-Script Size Unlocking-Script length in bytes, to follow Variable Unlocking-Script A script that fulfills the conditions of the UTXO locking script 4 bytes Sequence Number Used for locktime or disabled (0xFFFFFFFF) 与输出一样，可以从序列化格式的 Alice 的交易中找到输入。 首先，将输入解码： \"vin\": [ { \"txid\": \"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\", \"vout\": 0, \"scriptSig\" : \"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\", \"sequence\": 4294967295 } ] 现在，看一下下面例6-2中序列化以十六进制表示的字段： 例6-2 Alice的交易，序列化并以十六进制表示 0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73 4d2804fe65fa35779000000008b483045022100884d142d86652a3f47 ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039 ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84 16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1 7b4a10fa336a8d752adfffffffff0260e31600000000001976a914ab6 8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000 1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000 000 提示： 交易ID序列化后与原来的字节逆序呈现，因此以（十六进制）18开头，以79结尾 输出索引为4字节组的“0”，容易识别 scriptSig的长度为139个字节，十六进制为8b 序列号设置为FFFFFFFF，也容易识别 6.3.3 交易费 大多数交易都包含交易费，这是对比特币矿工保护网络安全的补偿。交易费本身也是一种安全机制，增加攻击者向网络中大量发送交易的经济成本。我们将在【第十章挖矿】详细讨论挖矿、交易费和矿工得到的奖励。 这一节解释交易费是如何被包含在一个典型的交易中的。大多数钱包自动计算并包含交易费。但是， 如果你以编程方式构造交易，或者使用命令行界面，你必须手动计算并包含这些费用。 交易费用是一种激励措施，激励将交易纳入（挖矿）下一个区块，但通过对每笔交易收取小额费用，也起到抑制滥用系统的作用。交易费由成功挖到区块的矿工收取，该区块把交易记录在区块链上。 交易费是基于交易的千字节（KB）大小来计算的，而不是交易比特币的价值。总的来说，交易费是根据比特币网络中的市场力量确定的。矿工会依据许多不同的标准，比如交易费，对交易进行优先级排序，甚至在某些特定情况下免费处理交易。但大多数情况下，交易费影响处理优先级，这意味着有足够费用的交易会更可能被打包进下一个挖出的区块中；反之交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，而且没有交易费的交易最终也可能会被处理，但是，有交易费会鼓励优先处理。 随着时间的推移，交易费的计算方式以及在交易处理优先级上的影响已经发生了变化。起初，交易费是固定的，是网络中的一个固定常数。随着网络容量和交易量的增加，收费结构逐渐放松，并可能受到市场力量的影响。至少从2016年初以来，比特币网络容量的限制已经造成交易之间的竞争，从而导致更高的费用，免费交易彻底成为历史。零费用或非常低费用的交易很少被处理，有时甚至不会在网络上传播。 在 Bitcoin Core 中，费用中继策略由minrelaytxfee选项设置。 目前默认的minrelaytxfee是每KB大小0.00001比特币或者mBTC的1%。 因此，默认情况下，费用低于0.0001比特币的交易被视为零费用，只有在内存池有空间时才会被转发; 否则，会被丢弃。 比特币节点可以通过调整minrelaytxfee的值来覆盖默认的费用中继策略。 任何创建交易的比特币服务，包括钱包，交易所，零售应用等，都必须实施动态收费。动态费用可以通过第三方费用估算服务或内置的费用估算算法来实现。如果不确定，请从第三方服务开始，随着经验积累，如果希望删除第三方依赖项，再设计并实现自己的算法。 费用估算算法根据网络能力和“彼此竞争”的交易提供的费用计算适当的费用。这些算法从十分简单的（最后一个块中的平均值或中位数）到非常复杂的（统计分析）都有。它们估计必要的费用（以字节的聪为单位），这将使得交易具有很高的可能性被选择打包进一定数量的块内。大多数服务为用户提供高、中、低优先级费用的选择。高优先级意味着用户支付更高的交易费，但交易就更可能被打包进下一个区块中。中低优先级意味着用户支付较低的交易费，但交易可能需要更长时间才能确认。 许多钱包应用程序使用第三方服务进行费用计算。常用的一个是earnbitcoin网站这个页面 ,它提供了一个API和一个可视化图表，以聪/字节为单位显示了不同优先级的费用。 提醒 固定费用在比特币网络上不再可行。 设置固定费用的钱包将导致用户体验很差，因为交易往往会被“卡住”，不被确认。不了解比特币交易和费用的用户因交易被“卡住” 而感到沮丧，因为他们认为自己已经失去了这笔钱。 下面图6-2中的图表显示了按照10聪/字节增长的实时估算费用，还有每个收费区间中交易的预期确认时间（分钟和块数）。 对于每个收费区间（例如，61-70 聪/字节），两个横条显示该区间内过去24小时中交易总数（102,975笔）和未确认交易的数量（1405笔）。 根据图表，此时推荐的高优先级费用为80 聪/字节，这就使交易在最近的下一个区块（零块延迟）中被挖出。 一般来说，一笔常规交易的大小约为226字节，因此单笔交易费建议为18,080 聪（0.00018080 BTC）。 费用估算数据可以通过简单的HTTP REST APIhttps://bitcoinfees.earn.com/api/v1/fees/recommended 例如，在命令行中使用curl命令： 使用费用估算API $ curl https://bitcoinfees.earn.com/api/v1/fees/recommended {\"fastestFee\":80,\"halfHourFee\":80,\"hourFee\":60} API返回一个satoshi/byte 形式的JSON对象，其中包括当前”最快确认“ (fastestFee)，三个块（halfHourFee）确认和六个块（hourFee）确认的费用估算值。 图6-2 bitcoinfees.earn.com提供的费用估算服务 6.3.4 把交易费加到交易中 交易的数据结构没有交易费这个字段。相反，交易费是指输入和输出之间的差值。从所有输入中扣掉所有输出之后的剩余的金额是矿工收取的交易费： Fees = Sum(Inputs) – Sum(Outputs) 正确理解交易比较困难，但又尤为重要。因为如果你要构建你自己的交易，你必须确保没有因为疏忽没支付够输入，反而在交易中添加一大笔交易费。这意味着你必须计算所有的输入，如有必要则加上找零， 不然的话，就给了矿工一笔相当可观的交易费！ 举例来说，如果你消耗了一个20比特币的UTXO来完成1比特币的付款，你必须包含一笔19比特币的找零回到你的钱包。否则，那剩下的19比特币会被当作交易费，并将由挖出你交易的矿工收走。尽管你会得到高优先级的处理，并且让一个矿工喜出望外，但这一定不是你想要的结果。 警告 如果你忘记了在手动构造的交易中增加找零的输出，系统会把找零当作交易费来处理。“不用找了！”也许不是你的真实意愿。 让我们重温一下Alice在咖啡店的交易来看看在实际中它如何运作。Alice想花0.015比特币购买咖啡。为了确保这笔交易能被立即处理，Alice想添加一笔交易费，比如说0.001。这意味着总花费会变成0.016。因此她的钱包需要凑齐一些UXTO加起来是0.016比特币或更多金额。如果更多的话，就得加上找零。我们假设她的钱包有一个0.2比特币的UTXO可用。钱包就会消耗掉这个UTXO，创造一个新的0.015的输出给Bob的咖啡店，另一个0.184比特币的输出作为找零回到Alice的钱包，并留下未分配的0.001交易费作为交易的隐含费用。 再看看另一种情况。Eugenia，菲律宾的儿童募捐项目主管，完成了一次为孩子购买教材的筹款活动。她从世界范围内接收到了好几千份小额捐款，总额是50比特币。所以她的钱包塞满了非常小的UTXO。现在她想用比特币从本地的一家出版商购买几百本教材。 现在Eugenia的钱包应用想要构造一个单笔大额付款交易，它必须来自可用的由许多较小的金额组成的UTXO集。这意味着这笔交易是把上百个小额UTXO作为输入，产生一个用来付给出版商的输出。输入数量这么巨大的交易一定会比1KB要大，也许会达到两至三KB。结果就是它需要比通常交易要高得多的交易费。 Eugenia的钱包应用会测量交易的大小，乘以每KB需要的费用来计算适当的交易费。很多钱包会支付较大的交易费，确保交易得到及时处理。更高交易费不是因为Eugenia付的钱很多，而是因为她的交易很复杂并且尺寸更大——交易费与交易的比特币金额无关。 6.4 比特币交易脚本和脚本语言 比特币交易脚本语言，称为脚本Scripts，是一种类似Forth的逆波兰表示法的基于堆栈的执行语言。 如果听起来不知所云，可能是你没有学习过20世纪60年代的编程语言，但是没关系，我们将在本章中解释这一切。 放置在UTXO上的锁定脚本和解锁脚本都以此脚本语言编写。 当一笔比特币交易被验证时，每一笔输入中的解锁脚本与其相应的锁定脚本一起执行，以确定这笔交易是否满足支付条件。 脚本是一种非常简单的语言，设计范围有限，可在一些硬件上执行，与嵌入式设备一样简单。 它仅需要做最少的处理，许多现代编程语言可以做的事情它都不能做。 但将它用于验证可编程货币，这就是一个深思熟虑的安全特性。 如今，大多数比特币网络处理的交易都是“Alice付给Bob”的形式，基于一种称为“P2PKH”（Pay-toPublic-Key-Hash）脚本。但是，比特币交易不局限于“支付给Bob的比特币地址”的脚本。事实上，锁定脚本可以被编写成表达各种复杂的情况。为了理解这些更为复杂的脚本，我们必须首先了解交易脚本和脚本语言的基础知识。 本节将会展示比特币交易脚本语言的各个内容；同时，也会演示如何使用它去表达简单的花费条件以及这些条件如何通过解锁脚本来满足。 小贴士： 比特币交易验证并不基于静态模式，而是通过执行脚本语言来实现的。这种语言允许表达几乎无限的各种条件。这也就是比特币拥有“可编程的货币”的力影响力的方式。 6.4.1 图灵不完备性 比特币脚本语言包含许多操作码，但在一个重要方面受到故意的限制——除了条件流程控制之外，没有循环或复杂的流程控制功能。这样就确保了脚本语言不是图灵完备的Turing Complete，这意味着脚本的复杂性有限，执行时间也是可预见的。脚本并不是一种通用语言，这些限制确保该语言不被用于创造无限循环或其它类型的逻辑炸弹，这样的炸弹可以植入在一笔交易中，引起针对比特币网络的“拒绝服务”攻击。记住，每一笔交易都会被网络中的全节点验证，受限制的语言能防止交易验证机制被作为漏洞。 6.4.2 无状态验证 比特币交易脚本语言是无状态的的，在执行脚本之前没有状态，或者在执行脚本之后也没有保存状态。所以执行脚本所需的所有信息都已包含在脚本中。可以预见的是，一个脚本能在任何系统上以相同的方式执行。如果您的系统验证了一个脚本，可以确信的是比特币网络中的任何其他系统也将能验证这个脚本，这意味着一个有效的交易对每个人而言都是有效的，而且每一个人都知道这一点。这种结果的可预见性是比特币系统的一项至关重要的优势。 6.4.3 脚本构建（锁定与解锁） 比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。 锁定脚本是一个放置在输出上面的花费条件：它指定了今后花费这笔输出必须要满足的条件。 由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），在历史上它曾被称为脚本公钥scriptPubKey。在这本书中，我们称之为“锁定脚本”，以承认这种脚本技术的广泛可能性。在大多数比特币应用程序中，我们所称的“锁定脚本”将以scriptPubKey的形式出现在源代码中。您还将看到被称为见证脚本（witness script）的锁定脚本（参见【7.8 隔离见证】），或者更普遍称为加密难题cryptographic puzzle。 这些术语在不同的抽象层次都代表同样的东西。 解锁脚本是这样一个脚本，它“解决”或满足由锁定脚本放置在输出上的条件，并允许使用输出。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包（通过用户的私钥）生成的数字签名。由于解锁脚本常常包含一个数字签名，因此它曾被称作脚本签名ScriptSig。在大多数比特币应用的源代码中，ScriptSig便是我们所说的解锁脚本。你也会看到解锁脚本被称作“见证”（witness 参见【7.8 隔离见证】）。在本书中，我们将它称为“解锁脚本”，用以承认更广泛的锁定脚本需求，因为并非所有解锁脚本都一定包含签名。 每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁脚本和锁定脚本。 如果解锁脚本满足锁定脚本的条件，则输入有效（请参阅【6.4.3.3 解锁脚本和锁定脚本的单独执行】）。 所有输入都是作为交易总体验证的一部分独立验证的。 请注意，UTXO被永久地记录在区块链中，因此是不变的，并且不受在新交易中引用失败的尝试的影响。只有正确满足输出条件的有效交易才会导致输出被视为“已花费”，然后从未花费交易输出集（UTXO set）中移除。 下图是最常见类型的比特币交易（P2PKH:对公钥哈希的付款）的解锁和锁定脚本的示例，显示在脚本验证之前解除锁定和锁定脚本的连接所产生的组合脚本： 图6-3 结合scriptSig和scriptPubKey评估交易脚本 6.4.3.1脚本执行堆栈 比特币的脚本语言被称为基于堆栈的语言，因为它使用一种被称为堆栈stack的数据结构。堆栈是一个非常简单的数据结构，可以被视为一叠卡片。堆栈允许两个操作：推送push和弹出pop。 推送就是在堆栈顶部添加一个项目。 弹出从堆栈中删除最顶端的项。堆栈上的操作只作用于堆栈最顶端项目。堆栈数据结构也被称为“后进先出”（ Last-In-First-Out）或 “LIFO” 队列。 脚本语言执行脚本时，从左到右处理每个项目。数字（数据常量）被推送入堆栈。操作码（Operators）从堆栈中推送或弹出一个或多个参数，对其进行操作，并可能将结果推送到堆栈上。例如，操作码 OP_ADD 将从堆栈中弹出两个项目，对它们求和，并将求和结果值推送到堆栈上。 条件操作码（Conditional operators）对一个条件进行评估，产生一个 TRUE 或 FALSE 的布尔结果（boolean result）。例如， OP_EQUAL 从堆栈中弹出两个项目，如果它们相等，则推送为 TRUE（由数字1表示），否则推送为 FALSE（由数字0表示）。比特币交易脚本通常包含条件操作码，以便它们可以产生用来表示有效交易的 TRUE 结果。 6.4.3.2一个简单的脚本 现在让我们将学到的关于脚本和堆栈的知识应用到一些简单的例子中。 如图6-4，脚本“ 2 3 OPADD 5 OP_EQUAL ”演示了算术加法操作码 OP_ADD ，该操作码将两个数字相加，然后把结果推送到堆栈， 后面的条件操作符 OP_EQUAL 是验算之前的两数之和是否等于 5 。为了简化起见，前缀OP在演示步骤过程中被省略了。有关可用脚本操作码和函数的更多详细信息，请参见【附录：交易脚本】。 图6-4比特币的脚本验证中，执行简单的数学运算 尽管绝大多数解锁脚本都指向一个公钥哈希值（本质上就是比特币地址），因此需要使用资金的所有权证明，但脚本不必那么复杂。任何解锁和锁定脚本的任何组合如果结果为真（TRUE），则为有效。前面用于脚本语言示例的简单算术计算同样也是一个有效的锁定脚本，该脚本能用于锁定交易输出。 使用部分算术脚本作为锁定脚本的示例： 3 OP_ADD 5 OP_EQUAL 该脚本能被包含解锁脚本输入的一笔交易所满足： 2 验证软件将锁定和解锁脚本组合起来，结果脚本是： 2 3 OP_ADD 5 OP_EQUAL 正如在上图6-4中所看到的一步步例子，当脚本被执行时，结果是OP_TRUE，交易有效。这不仅是一个有效的交易输出锁定脚本，同时产生的UTXO也能被任何具备算术技能知道数字2能够满足脚本的人所花费。 小贴士： 如果堆栈顶部的结果显示为TRUE（标记为{0x01}），即为任何非零值，或脚本执行后堆栈为空，则交易有效。如果堆栈顶部的结果显示为FALSE（0字节空值，标记为{}）或脚本执行被操作码明确终止，如OP_VERIFY、 OP_RETURN，或条件终止符如OP_ENDIF，则交易无效。详见【附录：交易脚本】 以下是一个稍微复杂一点的脚本，它用于计算 2+7-3+1 。注意，当脚本在同一行包含多个操作码时，堆栈允许一个操作码的结果由下一个操作码执行。 2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL 请试着用纸笔自行演算脚本，当脚本执行完毕时，堆栈中会留下一个TRUE值。 6.4.3.3 解锁脚本和锁定脚本的单独执行 在最初版本的比特币客户端中，解锁脚本和锁定脚本按顺序连起来执行。出于安全因素考虑，在2010年发生了改变，因为存在一个漏洞，允许格式错误的解锁脚本将数据推送到堆栈并损坏锁定脚本。而在当前的方案中，脚本是单独执行的，在两次执行之间传输堆栈，如下所述。 首先，使用堆栈执行引擎执行解锁脚本。如果解锁脚本在执行过程中未报错（例如：没有留下“dangling”操作码），则复制主堆栈，并执行锁定脚本。如果从解锁脚本中复制而来的堆栈数据执行锁定脚本的结果为“TRUE\"，那么解锁脚本就成功地满足了锁定脚本所设置的条件，因此，该输入是一个能使用该UTXO的有效授权。如果合并脚本执行后的结果是”TRUE“以外的任何结果，输入都是无效的，因为它不能满足UTXO中所设置的使用该笔资金的条件。 6.4.4 P2PKH（Pay-to-Public-Key-Hash） 比特币网络处理的大多数交易都是由“付款至公钥哈希”或P2PKH脚本锁定的输出，这些输出都含有一个锁定脚本，将输入锁定为一个公钥哈希值，即我们常说的比特币地址。由P2PKH脚本锁定的输出可以通过提供一个公钥和由相应私钥创建的数字签名来解锁（花费）。参见【6.5数字签名（ECDSA）】。 例如，我们再次回顾一下Alice向Bob咖啡馆支付的案例。Alice向Bob咖啡馆的比特币地址支付0.015比特币，该笔交易的输出内容为以下形式的锁定脚本： OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG 脚本中的 Cafe Public Key Hash 即为咖啡馆的比特币地址，但该地址不是基于Base58Check编码。事实上，大多数比特币地址的公钥哈希public key hash都显示为十六进制码，而不是大家所熟知的以1开头的基于Bsase58Check编码的比特币地址。 上述锁定脚本相应的解锁脚本是： 将两个脚本结合起来可以形成如下组合验证脚本： OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG 只有当解锁脚本与锁定脚本的设定条件相匹配时，执行组合验证脚本时才会显示结果为真（TRUE）。换句话说，只有当解锁脚本得到了咖啡馆的有效签名，交易执行结果才会被通过（结果为真），该有效签名是从与公钥哈希相匹配的咖啡馆的私钥中所获取的。 图6-5和图6-6（分两部分）显示了组合脚本一步步检验交易有效性的过程。 图6-5 评估P2PKH交易的脚本（1/2） 图6-6 评估P2PKH交易的脚本（2/2） 6.5 数字签名（ECDSA） 到目前为止，我们还没有深入了解“数字签名”的细节。在本节中，我们将研究数字签名的工作原理，以及如何在不出示私钥的情况下提供私钥的所有权证明。 比特币中使用的数字签名算法是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm）或ECDSA。 ECDSA是基于椭圆曲线私钥/公钥对用于数字签名的算法，如【4.1.5 椭圆曲线加密（Elliptic Curve Cryptography）解释】所述。ECDSA用于脚本函数OP_CHECKSIG，OP_CHECKSIGVERIFY，OP_CHECKMULTISIG和OP_CHECKMULTISIGVERIFY。每当在锁定脚本中看到这些时，解锁脚本都必须包含一个ECDSA签名。 数字签名在比特币中有三种用途（请参阅下面的侧栏）。第一，签名证明私钥的所有者，即资金所有者，有权花费这些资金。第二，授权证明是不可拒绝的（不可否认性）。第三，签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改。 请注意，交易的每笔输入都是独立签名的。这一点至关重要，因为不管是签名还是输入都不必属于同一“所有者”或者被其使用。事实上，一个名为 “CoinJoin” 的特定交易方案就使用这个特性来创建多方私密交易。 注意： 每个交易输入和它包含的任何签名完全独立于任何其他输入或签名。 多方可以协作构建交易，但是每方只能签名一个输入。 维基百科对 “数字签名 ”的定义： 数字签名是用于证明数字消息或文档的真实性的数学方案。 有效的数字签名使收件人有理由相信消息是由已知的发件人创建的（身份验证），发件人不能否认已发送的消息（不可否认性），并且消息在传输过程中没有更改（完整性）。 来源: https://en.wikipedia.org/wiki/Digital_signature 6.5.1 数字签名如何工作 数字签名是一种数学方案mathematical scheme，由两部分组成的：第一部分是使用私钥（签名密钥）从消息（交易）创建签名的算法； 第二部分是允许任何人给定依据给定的消息和公钥验证签名的算法。 6.5.1.1 创建数字签名 在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值（参见【6.5.3签名哈希类型（SIGHASH）】）。签名密钥是用户的私钥，结果就是签名： Sig = Fsig(Fhash(m), dA) 这里的： dA 是签名私钥 m 是交易（或其部分） Fhash 是散列函数 Fsig 是签名算法 Sig 是结果签名 ECDSA数学运算的更多细节可以在【6.5.4 ECDSA数学】找到。 函数Fsig 产生由两个值组成的签名Sig，通常称为R和S： Sig = (R, S) 现在已经计算了两个值R和S，它们就使用一种称为可分辨编码规则Distinguished Encoding Rules或DER的国际标准编码方案，序列化为字节流。 6.5.1.2 签名序列化（DER） 我们再来看看Alice创建的交易。 在交易输入中有一个解锁脚本，其中包含Alice的钱包中的以下DER编码签名： 3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301 该签名是Alice的钱包生成的R和S值的序列化字节流，证明她拥有授权花费该输出的私钥。 序列化格式包含以下9个元素： 0x30表示DER序列的开始 0x45 - 序列的长度（69字节） 0x02 - 一个整数值 0x21 - 整数的长度（33字节） 00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb - R值 0x02 - 接下来是一个整数 0x20 - 整数的长度（32字节） 4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813 - S值 后缀（0x01）指示使用的哈希的类型（SIGHASH_ALL） 看看您是否可以使用此列表解码 Alice 的序列化（DER编码）签名。 重要的数字是R和S; 数据的其余部分是DER编码方案的一部分。 6.5.2 验证签名 要验证签名，必须有签名（R和S）、序列化交易和公钥（对应于用于创建签名的私钥）。本质上，签名的验证意味着“只有生成此公钥的私钥的所有者，才能在此交易上产生此签名。” 签名验证算法采用消息（交易或其部分的哈希值）、签名者的公钥和签名（R和S值），如果签名对该消息和公钥有效，则返回 TRUE 值。 6.5.3 签名哈希类型（SIGHASH） 数字签名被应用于消息，在比特币中，就是交易本身。签名意味着签名者对特定交易数据的承诺commitment。最简单的形式是，签名应用于整个交易，从而承诺所有输入，输出和其他交易字段。但是，一个签名也可以只承诺交易数据的子集，这对于我们将在本节中看到的许多场景是有用的。 比特币签名使用 SIGHASH 标志显示，交易数据的哪一部分包含在私钥签名的哈希中。 SIGHASH 标志是附加到签名的单个字节。每个签名都有一个SIGHASH标志，该标志在随输入不同而不同。一笔交易如果有三个签名输入，就会有不同SIGHASH标志的三个签名，每个签名签署（承诺）交易的不同部分。 记住，每个输入可能在其解锁脚本中包含一个签名。因此，包含多个输入的交易可以拥有具有不同SIGHASH标志的多个签名，这些标志在每个输入中承诺交易的不同部分。还要注意，比特币交易可能包含来自不同“所有者”的输入，他们在部分构建（和无效）的交易中可能仅签名一个输入，需要与他人协作收集所有必要的签名后才能使交易生效。许多SIGHSASH标志类型，只有考虑到由许多参与者在比特币网络之外共同协作去更新仅部分签名了的交易，才具有意义。 有三个SIGHASH标志：ALL，NONE和SINGLE，如下表6-3所示。 表6-3 SIGHASH类型和意义 SIGHASH flag Value Description ALL 0x01 签名应用到所有输出输入 NONE 0x02 签名只应用到所有输入，不包括任何输出 SINGLE 0x03 签名应用到所有输入和与签名输入具有相同索引号的那个输出 另外还有一个修饰符标志SIGHASH_ANYONECANPAY，它可以与前面的每个标志组合使用。 当设置ANYONECANPAY时，只有一个输入被签名，其余的（及其序列号）保持开放以进行修改。 ANYONECANPAY的值为0x80，并通过按位OR运算，得到如下表6-4所示的组合标志： 表6-4 带修饰符的SIGHASH类型及其含义 SIGHASH flag Value Description ALL|ANYONECANPAY 0x81 签名应用到一个输入和所有输出 NONE|ANYONECANPAY 0x82 签名应用到一个输入，不包括任何输出 SINGLE|ANYONECANPAY 0x83 签名应用到一个输入和具有相同索引号的输出 这些标志组合总结如下图6-7。 图6-7 不同sighash组合的总结 签名和验证期间应用sighash标志的方式是生成交易的副本并截断其中的某些字段（设置为零长度并清空）。继而交易被序列化，SIGHASH标志被添加到序列化交易的结尾，并将结果哈希，得到的哈希值即是被签名的“消息”。 根据使用的SIGHASH标志，交易的不同部分会被截断。 所得到的哈希值取决于交易中数据的不同子集。 在进行哈希前的最后一步，借助于包含SIGHASH，签名提交了SIGHASH类型，因此不能再更改（例如，被矿工）。 提醒 所有SIGHASH类型都签署到交易的nLocktime字段（请参阅【7.5.1交易锁定时间（nLocktime）】）。 此外，SIGHASH类型本身在交易签名之前就被附加到交易中了，因此一旦签名就不能再修改它。 在Alice的交易（参见【6.5.1.2 签名序列化（DER）】）的例子中，我们看到DER编码签名的最后一部分是01，这是SIGHASH_ALL标志。这会导致锁定交易数据，因此Alice的签名承诺的是所有的输入和输出状态。 这是最常见的签名形式。 我们来看看其他一些SIGHASH类型，以及如何在实践中使用它们： ALL | ANYONECANPAY 这种结构可以用来做“众筹”交易，试图筹集资金的人可以用单笔输出来构建一个交易，单笔输出将“目标”金额付给众筹发起人。这样的交易显然是无效的，因为它没有输入。但是现在其他人可以添加自己的输入来修改它，实现捐赠。他们用ALL | ANYONECANPAY签名自己的输入，除非收集到足够的输入以达到输出的价值，否则交易无效，每次捐赠是一项“抵押”，直到募集到整个目标金额，筹款人才能收取。 NONE 该结构可用于创建特定金额的“不记名支票”或“空白支票”。它对输入进行承诺，但允许更改输出锁定脚本。任何人都可以将自己的比特币地址写入输出锁定脚本并兑换交易。不过，输出值本身被签名锁定。 NONE | ANYONECANPAY 这种结构可以用来建造一个“吸尘器”。用户的钱包中拥有微小UTXO，因为微小UTXO的面值还不够支付交易费，所以用户无法花费这些费用。借助这种类型的签名，微小UTXO可以捐赠给任何人，收集起来随时消费。 有一些修改或扩展SIGHASH系统的建议。其中一个是Blockstream的Glenn Willen作为Elements项目的一部分提议的Bitmask Sighash模式。其目的是创建一个灵活的SIGHASH类型的替代方案，允许使用“输入和输出的任意的，矿工可以重写的位掩码”来表示“更复杂的合同预承诺方案，例如分布式资产交易所中有变更的已签名的报价”。 注释: 您不会在用户的钱包应用程序中看到SIGHASH标志作为一个功能呈现。 有极少数例外，钱包会构建P2PKH脚本，并使用SIGHASH_ALL标志进行签名。 要使用不同的SIGHASH标志，必须编写软件来构造和签名交易。 更重要的是，SIGHASH标志可以被特殊用途的比特币应用程序使用，实现新的用途。 6.5.4 ECDSA数学 如前所述，签名由数学函数Fsig 创建，该函数生成了由R和S两个值组成的签名。在本节中，我们将更详细查看Fsig 函数。 签名算法首先生成一个 短暂的ephemeral（临时的）私公钥对。 该临时密钥对用于在涉及签名私钥和交易哈希的转换之后计算R和S值。 临时密钥对基于随机数k，后者用作临时私钥。 从k，生成相应的临时公钥P（以P = k G计算，与派生比特币公钥相同）;参见【4.1.4 公钥】部分）。数字签名的R值则是临时公钥P*的x坐标。 在此基础上，算法计算签名的S值，使得： S = k-1 (Hash(m) + dA * R) mod n 其中： k是临时私钥 R是临时公钥的x坐标 dA是签名私钥 m是交易数据 n是椭圆曲线的阶 验证是签名生成函数的倒数，使用R，S值和公钥来计算值P，该值是椭圆曲线上的一个点（签名创建时使用的临时公钥）： P = S-1 Hash(m) G + S-1 R Qa 其中： R和S是签名值 Qa是Alice的公钥 m是签名的交易数据 G是椭圆曲线生成点 如果计算出的点P的x坐标等于R，则验证者就得出结论，签名是有效的。 请注意，在验证签名时，私钥既不知道也不会泄露。 小贴士： ECDSA是一个相当复杂的数学问题，完整的解释超出了本书的范围。 网上有一些很棒的指南会指导你一步步学习：搜索“ECDSA解释”或尝试这个：http://bit.ly/2r0HhGB。 6.5.5 随机性在签名中的重要性 如我们在【6.5.4 ECDSA数学】中所看到的，签名生成算法使用随机密钥k作为临时私有公钥对的基础。 k 的值不重要，只要它是随机的。如果使用相同的k值用在不同的消息（交易）上生成两个签名，则任何人都可以计算签名私钥。在签名算法中使用相同的 k 值会导致私钥泄露！ 警告 如果在两个不同的交易中，签名算法使用相同的 k值，则私钥就能被计算出来，暴露给全世界！ 这不仅仅在理论上可能，我们已经看到在比特币交易签名算法的几种不同实现中，这个问题导致了私钥暴露。人们由于无意中重复使用 k 值导致资金被盗。重用 k 值的最常见原因是未正确初始化的随机数生成器。 为了避免此漏洞，行业最佳实践是，不使用以熵为种子的随机数生成器生成k，而是使用以交易数据本身为种子的确定性随机流程。这确保每个交易产生不同的 k 值。在互联网工程任务组（Internet Engineering Task Force）发布的RFC 6979中定义了 k 值的确定性初始化的行业标准算法。 如果您正在部署在比特币中签名交易的算法，则必须使用RFC 6979或类似的确定性随机算法来确保为每个交易生成不同的 k 值。 6.6 比特币地址，余额和其他抽象 我们在本章开始时发现，交易的“幕后”看起来与钱包、区块链浏览器和其他面向用户的应用程序中呈现出来的非常不同。 前几章中的许多简单而熟悉的概念，如比特币地址和余额，似乎都没有出现在交易结构中。 我们看到交易本身并不包含比特币地址，而是通过锁定和解锁比特币离散值的脚本进行操作。 余额也不存在于这个系统中的任何地方，但是每个钱包应用程序都明明白白地显示了用户钱包的余额。 现在，我们已经探讨了比特币交易中实际包含的内容，我们可以研究如何从交易的看似原始的组件中派生出更高级别的抽象。 我们再来看看Alice的交易在一个常用的区块浏览器（下图6-8）中呈现的： 图6-8 Alice与Bob咖啡馆的交易 在交易的左侧，区块链浏览器将Alice的比特币地址显示为“发送者”。其实这个信息本身并不在交易中。当区块链浏览器查询到交易时，它还查询在输入中关联的上一个交易，并从该旧交易中提取第一个输出。在该输出内是一个锁定脚本，将UTXO锁定到Alice的公钥哈希（P2PKH脚本）。区块链浏览器提取公钥哈希，并使用Base58Check编码对其进行编码，以生成和显示表示该公钥的比特币地址。 同样，在右侧，区块链浏览器显示了两个输出：第一个到Bob的比特币地址，第二个到Alice的比特币地址（作为找零）。为了创建这些比特币地址，区块链浏览器再次从每个输出中提取锁定脚本，将其识别为P2PKH脚本，从中提取公钥哈希。最后，区块链浏览器使用Base58Check重新编码公钥哈希，生成和显示比特币地址。 如果点击Bob的比特币地址，区块链浏览器将显示Bob的比特币地址的余额，如下图6-9： 图6-9 Bob的比特币地址的余额 区块链浏览器显示了Bob的比特币地址的余额。但是比特币系统中却没有“余额”的概念。这里显示的余额其实是由区块链浏览器按如下方式构建出来的： 为了构建“总收入”数量，区块链浏览器首先解码比特币地址的Base58Check编码，检索编码在地址内的Bob公钥的160位哈希值。然后，区块链浏览器搜索交易数据库，使用包含Bob公钥哈希的P2PKH锁定脚本查找输出。通过汇总所有输出的值，区块链浏览器就得出了接收总额。 构建当前余额（显示为“最终余额”）需要更多的工作。区块链浏览器保持一个单独的数据库，即UTXO集，其中保存着当前未被使用的输出。为了维护这个数据库，区块链浏览器必须实时监控比特币网络中出现的未经确认的交易，添加新创建的UTXO，删除已用UTXO。这是一个复杂的过程，依赖于在交易传播过程中跟踪交易，以及与比特币网络保持共识，以确保跟随正确的主链。区块链浏览器有时也会出现未能保持同步，导致其对UTXO集的跟踪扫描不完整或不正确。 区块链浏览器从UTXO集中，汇总引用Bob的公钥哈希的所有未花费输出的金额，就得出显示给用户的“最终余额”数值。 为了生成这张画面，得到这两个“余额”，区块链浏览器必须索引和搜索数十、数百甚至数十万的交易。 总之，通过钱包应用程序，区块链浏览器和其他比特币用户界面呈现给用户的信息通常由更高级别的抽象组成，这些抽象是通过搜索许多不同的交易、检查其内容和操作其中包含的数据而派生出来的。通过呈现这种简单的比特币交易视图（类似于从一个发送者到一个接收者的银行支票），这些应用程序必须抽象出许多潜在的细节。它们主要关注常见的交易类型：每个输入上具有SIGHASH_ALL签名的P2PKH交易。因此，虽然比特币应用程序以易于阅读的方式呈现所有了80％以上的交易，但有时候会被偏离规范的交易困扰。对于包含更复杂的锁定脚本，或不同SIGHASH标志，或多个输入和输出的交易，这种抽象就显得简单和不足。 每天都有数百个不包含P2PKH输出的交易在区块链上被确认。 区块链浏览器经常向他们发出红色警告信息，表示无法解码地址。 正如我们将在下一章中看到的，这些并不一定是奇怪的交易。它们是包含比常见的P2PKH更复杂的锁定脚本的交易。接下来我们将学习如何解码和理解更复杂的脚本及其支持的应用程序。 "},"ch07.html":{"url":"ch07.html","title":"第七章 高级交易和脚本","keywords":"","body":"第七章 高级交易和脚本 7.1 介绍 在上一章中，我们介绍了比特币交易的基本要素，并且了解了最常见的交易脚本类型，即P2PKH脚本。在本章中，我们将介绍更高级的脚本，以及如何使用它来构建复杂条件的交易。 首先，我们将了解多重签名multisignature脚本。接下来，我们将查看第二种最常见的交易脚本支付脚本哈希Pay-to-Script-Hash，它开启了复杂脚本的整个世界。然后，查看新的脚本操作符，能够通过时间锁timelocks给比特币添加时间维度。最后，我们将研究隔离见证Segregated Witness，这是对交易结构的架构性更改。 7.2 多重签名 多重签名脚本设置了一个条件，脚本中记录了N个公钥，必须至少提供其中的M个签名才能解锁资金。这也称为M/N方案，其中N是密钥的总数，M是验证必须的签名数。例如，2/3的多重签名是三个公钥被列为潜在签名人，其中至少两个必须用于签名才能创建有效的使用资金的交易。 目前，标准多重签名脚本限制在最多3个公钥，这意味着可以执行从1/1到3/3或这个范围内的任意组合的多重签名。在本书出版时，可能会取消对3个公钥的限制，建议检查issstandard（）函数，查看网络当前接受的值。注意，3个公钥限制只应用于标准多重签名脚本，不适用于P2SH脚本包装的多重签名脚本。P2SH多重签名脚本限制为15个密钥，允许最多15/15多重签名。我们将在【7.3 P2SH（Pay-to-Script-Hash）】学习P2SH。 设置M/N多重签名条件的锁定脚本的一般形式是： M ... N CHECKMULTISIG M是花费输出所需的签名的数量的底限，N是列出的公钥的总数。 设置2/3多重签名条件的锁定脚本如下所示： 2 3 CHECKMULTISIG 上述锁定脚本可被含有一对签名和公钥的解锁脚本满足： 或者由3个公钥中任意2个对应的私钥产生的签名组合。 这两个脚本一起形成下面的组合验证脚本： 2 3 CHECKMULTISIG 执行时，仅当解锁脚本与锁定脚本设置的条件匹配时，此组合脚本的评估结果才为TRUE。上述例子中设置条件就是：解锁脚本是否含有3个公钥中的任意2个相对应的私钥的有效签名。 CHECKMULTISIG执行中的bug CHECKMULTISIG的执行中出现了一个bug，需要做一些轻微的变通。 就是当CHECKMULTISIG执行时，它应该消耗堆栈上的M + N + 2个项目作为参数。 然而，由于该bug，CHECKMULTISIG会弹出一个额外的值或超出预期一个值。 我们使用前面的验证示例更详细地看一下： 2 3 CHECKMULTISIG 首先，CHECKMULTISIG弹出最上面的项目，这是N（在这个例子中N是“3”）。然后它弹出N个项目，这是可以签名的公钥数。在这个例子中，是公钥A，B和C，然后，它弹出一个项目，即M，参与仲裁数目（需要多少个签名）。这里M = 2。此时，CHECKMULTISIG应弹出最后的M个项目，就是那些签名，并查看它们是否有效。然而，不幸的是，实施中的错误导致CHECKMULTISIG再弹出一个项目（总共M + 1个）。检查签名时，额外的项目被忽略，虽然它对CHECKMULTISIG本身没有直接影响。但是，必须存在额外的值，因为如果不存在，则当CHECKMULTISIG尝试弹出到空堆栈上时，会导致堆栈错误和脚本失败（将交易标记为无效）。因为额外的项目被忽略，它可以是任何东西，但通常使用0。 因为这个bug已经成为共识规则的一部分，所以现在它必须被永远复制。因此，正确的脚本验证将如下所示： 0 2 3 CHECKMULTISIG 这样解锁脚本就不是下面的： 而是： 0 从现在开始，如果你看到一个多签解锁脚本，你应该期望开头就看到有一个额外的0，其目的是解决一个bug，却意外地成为共识规则。 7.3 P2SH（Pay-to-Script-Hash） 支付脚本哈希P2SH是2012年推出的一种功能强大的新型交易，它大大简化了复杂交易脚本的使用。为了解释P2SH的必要性，让我们看一个实际的例子。 在【第1章 比特币介绍】中，我们曾介绍过迪拜的电子产品进口商Mohammed。他的公司账目广泛采用比特币的多重签名功能。多重签名脚本是比特币高级脚本最为常见的一种用途之一，是一种非常强大的功能。Mohammed的公司对所有客户付款，会计术语称为“应收账款”，即AR，都使用多重签名脚本。基于多重签名方案，客户支付的任何款项都会被锁定，必须至少两个签名才能解锁，一个来自Mohammed，另一个来自其合伙人或拥有备份密钥的律师。这样的多重签名机制能提升公司治理管控，同时也能有效防范盗窃、挪用和丢失。 最终的脚本非常长： 2 5 OP_C HECKMULTISIG 虽然多重签名十分强大，但使用起来还是多有不便。Mohammed必须在客户付款前将上面的脚本发送给每一位客户，而每一位客户也必须使用专用的能创建自定义交易脚本的比特币钱包软件，每位客户还得学会如何利用自定义脚本来创建交易。此外，由于脚本可能包含特别长的公钥，最终的交易脚本可能是最初交易脚本长度的5倍之多。超大的交易还将给客户造成费用负担。最后，这样一个大交易脚本将一直记录在所有节点内存的UTXO集中，直到该笔资金被使用。所有这些都使得这种复杂锁定脚本在实践中变得困难重重。 P2SH正是为了解决这一实际难题而被引入的，它使复杂脚本的使用能与直接向比特币地址支付一样简单。使用P2SH支付，复杂的锁定脚本被其电子指纹（加密哈希）所取代。当随后出现的一笔交易试图花费这个UTXO时，除了解锁脚本外，它还必须包含与哈希匹配的脚本。简单地说，P2SH意味着“支付给匹配这个哈希的脚本，这个脚本将在以后花费这个输出时呈现。” 在P2SH交易中，锁定脚本被哈希值取代，称为兑换脚本redeem script，因为它在兑换时提交给系统，而不是作为锁定脚本。表7-1显示了不带P2SH的脚本，表7-2显示用P2SH编码的相同脚本。 表7-1 不含P2SH的复杂脚本 Locking Script 2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG Unlocking Script Sig1 Sig2 表7-2 P2SH复杂脚本 Redeem Script 2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG Locking Script HASH160 EQUAL Unlocking Script Sig1 Sig2 从表中可以看出，对于P2SH，详细描述了花费输出条件的复杂脚本（兑换脚本）不会在锁定脚本中显示。相反，兑换脚本本身，锁定脚本中只出现了它的哈希值，在以后花费输出时才作为解锁脚本的一部分出现。这会把费用和复杂性的负担从交易发送者转移给接收者（承担支出）。 让我们再看下Mohammed公司的复杂的多重签名脚本和相应的P2SH脚本。 首先，看一下Mohammed公司使用的多重签名脚本，用于来自客户的所有付款： 2 5 CHECKMULTISIG 如果占位符由实际的公钥（以04开头的520bit）替代，你会看到脚本非常长： 2 04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800 5 CHECKMULTISIG 整个脚本都可由仅为20个字节的加密哈希所取代，首先采用SH256哈希算法，再对结果运用RIPEMD160算法。 命令行界面使用libbitcoin-explorer (bx)产生下面的脚本哈希： echo \\ 2 \\ [04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \\ [04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \\ [047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \\ [0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \\ [043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \\ 5 CHECKMULTISIG \\ | bx script-encode | bx sha256 | bx ripemd160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e 上面的一系列命令首先将Mohammed的多签兑换脚本编码为一个序列化的十六进制编码比特币脚本。下面的bx命令使用RIPEMD160再次哈希，生成最终的脚本哈希： Mohammed的兑换脚本20字节哈希： 54c557e07dde5bb6cb791c7a540e0a4796f5e97e P2SH交易把输出锁定在这个哈希，而不是那个特别长的兑换脚本。使用的锁定脚本为： HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL 正如你所看到的，这个脚本简短多了。P2SH交易等同于“支付给包含该哈希的脚本”，而不是“支付给5个多重签名脚本”。客户在向Mohammed公司支付时，只需在其支付指令中纳入这个非常简短的锁定脚本即可。当 Mohammed和他的合伙人想要花费这笔UTXO时，附上原始兑换脚本（他们的哈希锁定到UTXO的那个脚本）和必要的解锁签名即可，如： 两个脚本经由两步实现组合。 首先，将兑换脚本与锁定脚本比对以确认其与哈希是否匹配： HASH160 EQUAL 假如兑换脚本哈希匹配，解锁脚本自行执行以解锁兑换脚本： 2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG 本章中描述的几乎所有脚本只能以P2SH脚本来实现。 它们不能直接用在UTXO的锁定脚本中。 7.3.1 P2SH地址 P2SH的另一重要特征是它能将脚本哈希编码为一个地址，正如BIP-13中所定义的。P2SH地址是采用Base58Check对20个字节哈希的脚本进行编码，就像比特币地址是公钥20字节哈希的Base58Check编码一样。由于P2SH地址采用5作为前缀，这导致基于Base58编码的地址以“3”开头。 例如，Mohammed的复杂脚本，Base58Check编码后的P2SH地址为“39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw”。我们可以通过bx命令确认： echo \\ '54c557e07dde5bb6cb791c7a540e0a4796f5e97e'\\ | bx address-encode -v 5 39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw 现在，Mohammed可以把这个地址发送给他的客户，他们可以采用任意比特币钱包进行简单支付，就像是比特币地址一样。前缀“3”暗示客户这是一种特殊类型的地址，一种对应于脚本而不是公钥的地址，但它作为付款方式与比特币地址完全相同。 P2SH地址隐藏了所有的复杂性，因此，运用其进行支付的人根本看不到脚本。 7.3.2 P2SH的优点 与在锁定输出中直接使用复杂脚本相比，P2SH特性提供了以下好处： 在交易输出中，复杂脚本由简短电子指纹取代，使得交易代码变短。 脚本被编译为地址，支付发送者及其比特币钱包都不需要复杂工程就可以执行P2SH。 P2SH将构建脚本的负担转移至接收方，而非发送者。 P2SH将长脚本数据的存储负担从输出方（既存储在区块链，又存储在UTXO集），转移至输入方（只存储在区块链中）。 P2SH将长脚本数据的存储负担从当前（支付时）转移至未来（花费时）。 P2SH将长脚本的交易费成本从发送方转移至接收方，接收方必须包含长的兑换脚本才能使用该笔资金。 7.3.3 兑换脚本和验证 在0.9.2版Bitcoin Core客户端之前，P2SH通过IsStandard()，仅限于标准类型的比特币交易脚本。这也意味着花费交易中的兑换脚本只能是标准化的P2PK、P2PKH或者多重签名。 0.9.2版的Bitcoin Core客户端，P2SH交易能包含任意有效的脚本，这使得P2SH标准更为灵活，可以用于多种新的或复杂类型的交易进行实验。 请记住不能将P2SH植入P2SH兑换脚本，因为P2SH规范不是递归的。虽然在技术上可以将RETURN【7.4 数据记录输出（RETURN操作符）】包含在兑换脚本中，规则中也未阻止此这样操作，但这没有实际用途，因为在验证期间执行RETURN将导致交易被标记为无效。 需要注意的是，因为在尝试使用P2SH输出之前，兑换脚本不会呈现给网络，因此，如果使用无效兑换脚本的哈希锁定输出，则不管如何都会进行处理。该UTXO将会被成功锁定，但是你将不能使用该笔资金，包含兑换脚本的花费交易也不被接受，因为该脚本是无效的。这样就会产生风险，你把比特币锁定在永不能花费的P2SH中。比特币网络本身会接受这个P2SH锁定脚本，即便它对应的是无效的兑换脚本，因为脚本哈希没有给出它所表示的脚本的含义。 注释 P2SH锁定脚本包含一个兑换脚本哈希，其中不包括该兑换脚本本身的任何线索。即便在兑换脚本无效的情况下，P2SH交易也会被认为有效并被接受。你可能会意外地锁死比特币，以后再也无法使用它。 7.4 数据记录输出（RETURN操作符） 比特币的分布式和时间戳账本，即区块链技术，其潜在用途将大大超越支付领域。许多开发者试图充分发挥交易脚本语言的安全性和弹性优势，将其运用于数字公证服务、股票证书和智能合约等领域。使用比特币的脚本语言来实现这些目的的早期尝试，包括创建交易输出，把数据记录在区块链上，例如，以这样的方式记录文件的数字指纹，任何人可以通过引用该交易来建立该文件特定日期的存在证明。 运用比特币的区块链技术存储与比特币支付不相关数据的做法是一个有争议的话题。许多开发者认为其有滥用的嫌疑，因而试图予以阻止。另一些开发者则将之视为区块链技术强大功能的有力证明，认为应该给予大力支持。那些反对包含非支付数据的人辩称这将导致“区块链膨胀”，增加运行的全节点的磁盘存储成本，承担了区块链不应该携带的数据。而且，此类交易创建了不能花费的UTXO，使用目标比特币地址作为20字节的自由格式字段。因为比特币地址只是被当作数据使用，并不对应于私钥，所以会导致UTXO永远不能用于交易，因而是伪支付。这些交易永远不会被花费，所以永远不会从UTXO集中删除，会导致UTXO数据库的大小永远增加“膨胀”。 在0.9版的Bitcoin Core客户端上，通过采用RETURN 操作符最终实现了妥协。RETURN 允许开发者在交易输出上增加80字节的非支付数据。然后，与伪UTXO不同，RETURN 创造了一种明确的可验证不可消费型输出，此类数据无需存储于UTXO集。RETURN输出被记录在区块链上，它们会消耗磁盘空间，也会导致区块链规模的增加，但它们不存储在UTXO集中，因此也不会使得UTXO内存池膨胀，更不会增加全节点昂贵的内存代价。 RETURN 脚本的样式： RETURN “data”部分被限制为80字节，且多表示为哈希值，如同SHA256算法输出一样（不过值是32字节）。许多应用都在其前面加上前缀以方便识别。例如， 这家网站Proof of Existence 的数字公证服务使用8字节前缀DOCTIOND，16进制ASCII编码为44×4F 43 50 50 4F 4F 46。 请记住，并不存在对应于RETURN 的解锁脚本，也就不能花费RETURN的输出。RETURN的关键点就是锁定的输出不能花费，因此它不需要被保存在UTXO集中供未来消费，RETURN是可验证但是不可花费的。 RETURN 常为一个金额为0比特币的输出， 因为分配到该输出的比特币都会永久消失。假如一笔 RETURN 被作为一笔交易的输入，脚本验证引擎将会阻止验证脚本的执行，将标记交易为无效。执行RETURN本质上导致脚本“返回”FALSE并停止执行。如果你不小心将 RETURN 的输出作为另一笔交易的输入，则该交易是无效的。 一笔标准交易（通过了 isStandard() 函数检验的）只能有一个 RETURN 输出。但是单个RETURN 输出能与任意类型的输出交易进行组合。 Bitcoin Core 0.10版本添加了两个新的命令行选项。 选项datacarrier控制RETURN交易的传播和挖矿，默认设置为“1”以允许它们。 选项datacarriersize采用一个数字参数，指定RETURN脚本的最大大小（以字节为单位），默认为83字节，允许最多80个字节的RETURN数据加上一个字节的RETURN操作码和两个字节的PUSHDATA操作码。 注释 RETURN最初提出的时候，限制为80字节，但发布时，限制被减少到40字节。 2015年2月，在Bitcoin Core的0.10版本中，限制提高到80字节。 节点可以选择不传播或不挖矿RETURN，或者只传播和挖矿包含少于80字节数据的RETURN。 7.5 时间锁（Timelocks） 时间锁是对交易或输出的限制，只允许在一个时间点之后才能消费。比特币从一开始就有一个交易级时间锁定功能，它由交易中的nLocktime字段实现。在2015年底和2016年中期推出了两个新的时间锁功能，提供UTXO级别的时间锁功能，这就是CHECKLOCKTIMEVERIFY和CHECKSEQUENCEVERIFY。 时间锁对于延期交易和将资金锁定到将来某个日期很有用。更重要的是，时间锁将比特币脚本扩展到时间的维度，为复杂的多步骤智能合约打开了大门。 7.5.1 交易锁定时间（nLocktime） 比特币从一开始就有一个交易级的时间锁功能。交易锁定时间是交易级设置（交易数据结构中的一个字段），它定义了交易有效，可以在网络上传播或添加到区块链的最早时间。锁定时间也称为nLocktime，是来自于Bitcoin Core代码库中使用的变量名称。在大多数交易中将其设置为零，表示立即传播和执行。如果nLocktime不为零，低于5亿，则将其解释为区块高度，这意味着交易在指定的区块高度之前无效，并且不被传播，也不被包含在区块链中。如果大于或等于5亿，它被解释为Unix纪元时间戳（自1-1-1970之后的秒数），并且交易在指定时间之前无效。指定未来区块或时间的nLocktime交易必须由发起系统持有，并且只有在有效后才被发送到比特币网络。如果交易在指定的nLocktime之前传输到网络，那么第一个节点就会拒绝该交易，并且不会传播到其他节点。使用nLocktime等同于一张延期支票。 7.5.1.1 交易时间锁限制 nLocktime就是一个限制，虽然将来有可能花费这些输出，但是到指定时间为止，还不能说不能花费它们。我们用下面的例子解释一下。 Alice签署了一笔交易，支付给Bob的地址，并将交易nLocktime设定为未来的3个月。Alice把这笔交易发送给Bob搁置起来。有了这个交易，Alice和Bob知道： 在3个月过去之前，Bob不能完成交易进行兑换。 Bob可以在3个月后接受交易。 然而： Alice可以创建另一笔交易，不设置时间锁，花费上面两倍的输入。 这样，Alice就可以在3个月过去之前花费相同的UTXO。 Bob不能保证Alice不会这样做。 了解交易nLocktime的限制很重要。 唯一的保证是Bob在3个月过去之前无法兑换它，却无法保证Bob最终是否可以得到资金。 为了实现这样的保证，时间锁限制必须放在UTXO上，成为锁定脚本的一部分，而不是交易的一部分。 这是通过另一种形式的时间锁来实现的，称为检查锁定时间验证(CLTV)。 7.5.2 检查锁定时间验证Check Lock Time Verify (CLTV) 2015年12月，通过比特币软分叉升级引入了一种新形式的时间锁。根据BIP-65中的规范，脚本语言中添加了一个名为CHECKLOCKTIMEVERIFY CLTV的新脚本操作符。 CLTV是每个输出的时间锁，而不是像nLocktime一样是每个交易的时间锁。这使得在应用时间锁的方式上具有更大的灵活性。 简单地说，通过在输出的兑换脚本中添加CLTV操作码，限制了输出，因此只能在指定的时间过后花费。 提示 nLocktime是交易级别时间锁，而CLTV是基于输出的时间锁。 CLTV不替换nLocktime，而是限制特定的UTXO，使它们只能在大于或等于nLocktime设置的值的将来交易中使用。 CLTV操作码采用一个参数作为输入，为与nLocktime相同格式的数字（区块高度或Unix纪元时间）。如VERIFY后缀所示，CLTV是在结果为false时停止脚本执行的操作码类型。如果结果为TRUE，则继续执行。 为了使用CLTV来锁定输出，必须将其插入到创建输出交易的输出兑换脚本中。例如，如果Alice支付Bob的地址，输出通常会包含如下P2PKH脚本： DUP HASH160 EQUALVERIFY CHECKSIG 要锁定一段时间，比如说3个月以后，交易将是一个包含兑换脚本的P2SH交易： CHECKLOCKTIMEVERIFY DROP DUP HASH160 EQUALVERIFY CHECKSIG 其中是从交易开始被挖矿时间起估计3个月的区块高度或时间值：当前块高度+12,960（块）或当前Unix纪元时间+7,760,000（秒）。现在，不要担心CHECKLOCKTIMEVERIFY之后的DROP操作码,下面很快就会解释。 当Bob尝试花费这个UTXO时，他构建了一个引用UTXO作为输入的交易。他在该输入的解锁脚本中使用了他的签名和公钥，并将交易nLocktime设置为等于或大于Alice设置的CHECKLOCKTIMEVERIFY 时间锁。然后，Bob把这笔交易广播到比特币网络上。 Bob的交易评估如下。如果Alice设置的CHECKLOCKTIMEVERIFY参数小于或等于支出交易的nLocktime，脚本执行将继续（就好像执行“无操作”或NOP操作码一样）。否则，脚本执行停止，并且该交易被视为无效。 更确切地说，CHECKLOCKTIMEVERIFY失败并停止执行，标记交易无效（来自：BIP-65）： 堆栈是空的要么 堆栈中的顶部项小于0;要么 顶层堆栈项和nLocktime字段的锁定时间类型（高度或者时间戳）不相同;要么 顶层堆栈项大于交易的nLocktime字段;要么 输入的nSequence字段为0xffffffff。 注释 CLTV和nLocktime描述时间锁必须使用相同的格式，无论是区块高度还是自Unix纪元以来经过的秒数。 最重要的是，在一起使用时，nLocktime的格式必须与输出中的CLTV格式相匹配，它们必须是区块高度或秒数时间。 执行后，如果满足CLTV的要求，则它前面的时间参数将作为堆栈上的顶部项保留，并且可能需要随DROP一起删除，以便正确执行后续脚本操作码。 经常在脚本中看到CHECKLOCKTIMEVERIFY后面跟着DROP就是这个原因。 通过将nLocktime与CLTV结合使用，【7.5.1.1交易时间锁限制】中描述的情况就发生了变化。 Alice就不能再花这笔钱了（因为它被Bob的密钥锁定了），Bob也不能在3个月的锁定期终止前花掉它。 通过将时间锁功能直接引入到脚本语言中，CLTV允许我们开发一些非常有趣的复杂脚本。 该标准在BIP-65（CHECKLOCKTIMEVERIFY）中定义（附录BIP-65）。 7.5.3 相对时间锁 nLocktime和CLTV都是绝对时间锁absolute timelocks，它们指定绝对时间点。接下来我们研究的两个时间锁功能，是相对时间锁relative timelocks，它们设置的花费输出的条件为从区块链中的输出被确认开始所经过的时间。 相对时间锁是有用的，因为它们允许两个或多个相互依赖的交易链被下链处理，同时对一个交易施加时间限制，该时间限制依赖于其前一个交易从被确认开始经过的时间。换句话说，只有这个UTXO被记录在区块链，时钟才开始计数。这个功能在双向状态通道和闪电网络中特别有用，我们将在后面章节【12.6支付通道和状态通道】中看到。 相对时间锁和绝对时间锁一样，都是通过交易级特性和脚本级操作码实现的。交易级相对时间锁是通过设置作为共识规则的nSequence的值实现的，它是每个交易输入中都有设置的交易字段。脚本级相对时间锁使用CHECKSEQUENCEVERIFY（CSV）操作码实现。 相对时间锁是根据【BIP-68】与【BIP-112】的规范共同实现的，其中BIP-68通过与相对时间锁运用一致性增强的数字序列实现，BIP-112中是运用到了CHECKSEQUENCEVERIFY这个操作码实现。 BIP-68和BIP-112是在2016年5月作为软分叉升级时被激活的一个共识规则。 7.5.4 nSequence相对时间锁 相对时间锁可以设置在每个交易输入中，方法是设置每个输入中的nSequence字段。 7.5.4.1 nSequence的本义 nSequence字段的最初设计是想在内存中修改交易（但是从未运用过）。这种情况下，一笔交易的输入包含的nSequence值低于232-1（0xffffffff），就表示该交易尚未“完全完成”。这样的交易将一直保留在内存池中，直到被花费相同输入，具有更高nSequence值的的另一笔交易代替。一旦收到一笔交易，其nSequence值为0xFFFFFFFF，那么它就被视为“完成”并交给矿工挖矿。 nSequence的最初设计从未被正确实现，在不使用时间锁的交易中，nSequence的值通常设置为0xFFFFFFFF。对于具有nLocktime或CHECKLOCKTIMEVERIFY的交易，nSequence值必须设置为小于231，以使时间锁保护有效，如下面所述。 7.5.4.2 nSequence作为共识执行的相对时间锁 随着BIP-68的激活，新的共识规则适用于输入中的nSequence值小于231的任何交易（ 1 交易的输入中的nSequence值小于231，就表示具有相对时间锁。这种交易中的输入只有相对锁定时间到期后才能有效。例如，一笔交易的输入的nSequence相对时间锁是30个区块，那么只有当输入引用的UTXO被挖出后再经过30个区块之后，该交易才有效。由于nSequence是每个输入中的字段，因此交易可能包含任何数量的时间锁定输入，这其中的每个输入都必须满足时间限制交易才能有效。交易中的输入可以是时间锁定输入（nSequence 31），也可以是没有相对时间锁定（nSequence> = 231）的输入。 nSequence值以块或秒为单位，但与nLocktime中使用的格式略有不同。类型（type）标志用于区分计数块和计数时间（以秒为单位）。类型标志设置在第23个最低有效位（即值1 当将nSequence解释为相对时间锁时，只考虑16个最低有效位。一旦对标志（位32和23）求值，nSequence值通常用16位掩码（例如nSequence或者0x0000FFFF）进行“屏蔽”。 下图显示由BIP-68定义的nSequence值的二进制结构。 图7-1 BIP-68 中nSequence编码的定义(出处: BIP-68) BIP-68规定了基于nSequence值的共识执行的相对时间锁。该标准参见BIP-68, Relative lock-time using consensus-enforced sequence numbers。. 7.5.5 带CSV的相对时间锁 就像CLTV和nLocktime一样，在脚本中有一个脚本操作码使用nSequence值作为相对时间锁。该操作码是CHECKSEQUENCEVERIFY，通常简称为CSV。 在UTXO的兑换脚本中执行时，CSV操作码仅允许花费交易中nSequence值大于或等于CSV参数的输入。实质上，这限制了UTXO的消耗，直到从该UTXO被挖出之后过了一定数量的区块或秒数。 与CLTV一样，CSV中的值必须与相应nSequence值中的格式相匹配。如果CSV指定的是区块数，那么nSequence也是区块数。如果CSV以秒为单位，那么nSequence的参数也是秒数。 当创建和签署多个（链接的）交易，但不想对外广播，想让它们保持“链下”时，使用CSV的相对时间戳特别有用。在父交易按相对时间锁中指定的时间进行传播、被挖矿和老化之前，子交易是不能使用的。有一个应用案例可以在【12.6支付通道和状态通道】和【12.7可路由的支付通道（闪电网络）】章节中看到。 CSV 细节参见 BIP-112, CHECKSEQUENCEVERIFY. 7.5.6 中位时间过去 作为激活相对时间锁的一部分，时间锁（绝对和相对）的“时间”计算方式也发生了变化。在比特币中，现实时间（wall time）和共识时间之间存在微妙但非常显著的差异。比特币是一个去中心化网络，这意味着每个参与者都有自己的时间视角。网络上的事件并非在任何地方都是瞬间发生的。网络延迟必须是每个节点必须考虑的重要因素。最终，所有内容都被同步，以创建一个共同的分类帐。比特币每10分钟会对于过去存在的分类账状态达成一个新的共识。 区块头中的时间戳由矿工设定。共识规则允许一定的余地来解决去中心化节点之间时钟精度的问题。然而，这给矿商创造了一个不好的激励，他们在一个区块内谎报时间，通过纳入尚未到期的时间锁交易来赚取额外费用。有关详细信息，请参阅以下部分。 为了杜绝矿工说谎，加强时间锁的安全性，与相对时间锁同时激活的还有一个BIP。这就是BIP-113，它定义了一个称为中位时间过去Median-Time-Past的新的共识测量机制。 中位时间过去是通过读取最后11个块的时间戳并求出中位值来计算的。这个中位时间值就变成了共识时间，并被用于所有的时间锁计算。通过结合11个区块，没有一个矿工会为了获得尚未到期的时间戳的交易中的交易费，去影响时间戳。 中位时间过去改变了nLocktime，CLTV，nSequence和CSV的时间计算的实现。由中位时间过去计算的共识时间总是比现实时间晚大约一个小时。如果要创建时间锁交易，评估nLocktime，nSequence，CLTV和CSV中编码所需时间值时，应该考虑在这个因素。 中位时间过去参见【BIP-113】。 7.5.7 针对费用狙击（Fee Sniping）的时间锁 费用狙击是一种理论攻击情形，矿工试图从将来的区块挑选手续费较高的交易重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。 例如，假设存在的最高块是块＃100,000。有些矿工现在不是试图对＃100,001区块进行挖矿来延长区块链，而是试图重新挖矿＃100,000区块。这些矿工选择在自己的候选块＃100,000中包括任何有效的交易（还未挖出）。他们不必使用相同的交易来重挖区块。事实上，他们会更倾向于选择在其中添加最有利可图（每kB最高交易费）的交易。他们会纳入“旧”块＃100,000中的任何交易，还有他们当前内存池的任何交易。当他们重新创建块＃100,000时，本质上就把“现在”的交易拉出来重写到“过去”中。 今天，这种攻击还不是非常有利可图，因为挖矿奖励远远高于每个区块中的总费用。但在未来的某个时候，交易费将是奖励的大部分（甚至是奖励的整体），那时候这种情况就会很难避免了。 为了防止“费用狙击”，Bitcoin Core创建交易时，默认情况下，使用nLocktime将它们限制为“下一个区块”。在刚才的场景中，Bitcoin Core 会将其创建的任何交易的nLocktime设置为100001。在正常情况下，这个nLocktime不起作用-无论如何，这些交易只能包含在块100001中，就是下一个块。 但是在区块链分叉攻击时，由于所有这些交易都将被时间锁阻止在＃100,001，所以矿工们无法从内存池中提取高收费交易，因为所有这些交易都将被时间锁定到区块100001中。他们只能在当时有效的交易中重新挖区块#100,000，实质上不会获得新的费用。 为了实现这一点，Bitcoin Core将所有新交易的nLocktime设置为，并将所有输入上的nSequence设置为0xFFFFFFFE以启用nLocktime。 7.6 流程控制脚本（条件语句 ） 比特币脚本的一个更强大的功能是流程控制，也称为条件语句。您可能熟悉各种编程语言中的类似IF…THEN…ELSE的流程控制。比特币条件语句看起来有点不同，但本质上是相同的构造。 基本上，比特币条件操作码允许我们构造一个具有两种解锁方式的兑换脚本，具体取决于对逻辑条件求值的真/假结果。例如，如果x为真，则兑换脚本为A，否则ELSE兑换脚本为B。 此外，比特币条件表达式可以无限期地“嵌套”，这意味着一个条件语句可以包含另外一个条件语句，其中又会包含别的条件语句等等 。比特币脚本流程控制可用于构造非常复杂的脚本，可以有数百甚至数千个可能的执行路径。嵌套没有限制，但共识规则对脚本的最大字节数有限制。 比特币使用IF，ELSE，ENDIF和NOTIF操作码实现流程控制。此外，条件表达式可以包含布尔运算符，如BOOLAND，BOOLOR和NOT。 乍看之下，您可能会发现比特币的流程控制脚本令人困惑。那是因为比特币脚本是一种堆栈语言。正如当1+1表示为1 1 ADD时看起来是“逆向”的，比特币中的流程控制语句也看起来是“逆向”的。 在大多数传统（过程）编程语言中，流程控制如下所示： 大多数编程语言中的流控制伪代码 if (condition): code to run when condition is true else: code to run when condition is false code to run in either case 在基于堆栈的语言中，比如比特币脚本，逻辑条件出现在IF之前，看起来像是“逆向”的，如下所示： Bitcoin脚本流程控制 condition IF code to run when condition is true ELSE code to run when condition is false ENDIF code to run in either case 阅读Bitcoin脚本时，请记住，条件语句在IF操作码的前面。 7.6.1 VERIFY操作码条件语句 比特币脚本中的另一种条件形式是操作码以VERIFY结尾。 VERIFY后缀表示如果评估的条件不为TRUE，脚本的执行将立即终止，并且该交易被视为无效。 与提供可选执行路径的IF子句不同，VERIFY后缀充当保护子句，只有在满足前提条件时才会继续执行。 例如，以下脚本需要Bob的签名和产生特定哈希的原像（密钥）。 这两个条件必须都满足才能解锁： 有EQUALVERIFY保护子句的兑换脚本。 HASH160 EQUALVERIFY CHECKSIG 为了兑换成功，Bob必须构建一个解锁脚本，提供有效的原像和签名： 满足上述兑换脚本的解锁脚本 没有原像，Bob无法继续执行到检查其签名的脚本部分。 该脚本可以用IF编写： 具有IF保护语句的兑换脚本 HASH160 EQUAL IF CHECKSIG ENDIF Bob的解锁脚本是一样的： 满足上述兑换脚本的解锁脚本以 使用IF的脚本与使用VERIFY后缀的操作码作用相同;，它们都可以作为保护语句。 但是，VERIFY的构造更有效率，少用了两个操作码。 那么，我们什么时候使用VERIFY，什么时候使用IF？ 如果我们想要做的是附加一个前提条件（保护语句），那么VERIFY后缀更好。 然而，如果有不止一个执行路径（流程控制），那么IF ... ELSE流程控制语句更合适。 提示 诸如EQUAL之类的操作码会将结果（TRUE / FALSE）推送到堆栈上，留下它用于后续操作码的执行。 相比之下，操作码EQUALVERIFY后缀不会在堆栈上留下任何东西。 以VERIFY结尾的操作码都不会将结果留在堆栈上。 7.6.2 在脚本中使用流程控制 比特币脚本中流程控制的常见的用途是构建一个提供多个执行路径的兑换脚本，每个执行路径都是兑换UTXO的不同方式。 我们来看一个简单的例子，两个签名人，Alice和Bob，两人中任何一个都可以兑换。 使用多重签名，表示为1/2多重签名脚本。 为了演示，我们先使用IF语句执行相同的操作： IF CHECKSIG ELSE CHECKSIG ENDIF 看到这个兑换脚本，你可能会想：“条件在哪里？IF语句前面什么也没有啊！” 条件并不是兑换脚本的一部分。 相反，条件是提供给解锁脚本，允许Alice和Bob“选择”他们想要的执行路径。 Alice用解锁脚本兑换： 1 最后的1作为条件（TRUE），使IF语句可以执行有Alice签名的第一个兑换路径。 如果是Bob兑换，他必须通过给IF语句赋一个FALSE值才能选择第二个执行路径： 0 Bob的解锁脚本将0放置在堆栈上，导致IF语句执行第二个（ELSE）脚本，该脚本需要Bob的签名。 由于可以嵌套IF语句，就可以创建一个执行路径的“迷宫”。 解锁脚本可以提供一个“映射”，选择实际执行的路径： IF script A ELSE IF script B ELSE script C ENDIF ENDIF 在这种情况下，有三个执行路径（脚本A，脚本B和脚本C）。 解锁脚本以一系列TRUE或FALSE值的形式提供路径。 例如要选择路径脚本B，解锁脚本必须以1 0（TRUE，FALSE）结尾。 这些值将被推送到堆栈，第二个值（FALSE）首先停留在堆栈的顶部。 外部IF语句弹出FALSE值并执行第一个ELSE语句。 然后，TRUE值移动到堆栈的顶部，再通过内部（嵌套）的IF来执行，选择B执行路径。 使用这个结构，构造的兑换脚本就可以有数十或数百个执行路径，每个脚本提供了一种不同的方式来兑换UTXO。 花费时，构建一个解锁脚本，通过在每个流程控制点的堆栈上放置相应的TRUE和FALSE值来指引执行路径。 7.7 复杂的脚本示例 在本节中，我们将本章中的许多概念合并成一个例子。 我们的例子使用了迪拜一家公司所有者Mohammed的故事，他们主营进出口业务。 在这个例子中，Mohammed希望用灵活的规则建立公司资本账户。他创建的方案需要使用时间锁设置不同级别的授权。 多重签名计划的参与者是Mohammed，和他的两个合伙人Saeed和Zaira，以及他们的公司律师Abdul。三个合伙人根据多数规则作出决定，也就是三人中的两人必须同意才可以。然而，如果他们的密钥出现问题，他们希望他们的律师能够用三个合伙人中任何一人的签名收回资金。最后，如果所有的合伙人一段时间临时都联系不上或不能工作，他们希望律师能够直接接管该帐户。 这是Mohammed设计的实现上述目的脚本（每一行前面的数字是行号）： 具有时间锁的可变多重签名 01 IF 02 IF 03 2 04 ELSE 05 CHECKSEQUENCEVERIFY DROP 06 CHECKSIGVERIFY 07 1 08 ENDIF 09 3 CHECKMULTISIG 10 ELSE 11 CHECKSEQUENCEVERIFY DROP 12 CHECKSIG 13 ENDIF Mohammed的脚本使用嵌套的IF ... ELSE流程控制语句实现三个执行路径。 在第一个执行路径中，该脚本是三个合伙人的简单的2/3多重签名。该执行路径由第3行和第9行组成。第3行将多重签名的法定人数设置为2（2/3）。 通过在解锁脚本的末尾设置TRUE TRUE来选择该脚本： 第一个执行路径的解锁脚本（2/3 多签） 0 TRUE TRUE 提示 此解锁脚本开头的0是因为CHECKMULTISIG中的一个错误，会从堆栈中多弹出一个额外的值。 CHECKMULTISIG会忽略这个额外的值，但它必须存在，否则脚本执行将失败。 推送0（通常）是解决bug的方法，如【7.2 多重签名CHECKMULTISIG执行中的bug】所述。 第二个执行路径只能在UTXO创建30天后才能使用。 此时，它需要Abdul（律师）和三个合伙人之一（1/3）的签名。 这是通过第7行实现的，该行将多签的法定人数设置为1。要选择此执行路径，解锁脚本将以FALSE TRUE结束： 第二个执行路径的解锁脚本(律师 + 1/3） 0 FALSE TRUE 提示 为什么先FALSE后TRUE？ 反了吗？是这两个值被推到堆栈的顺序，先推FALSE，后推 TRUE。 因此，第一个IF操作码首先弹出的是TRUE。 最后，第三个执行路径允许律师单独花费资金，但只能在90天之后。 要选择此执行路径，解锁脚本必须以FALSE结束： 第三个执行路径的解锁脚本（仅适用于律师） FALSE 在纸上运行脚本来查看它在堆栈上的行为。 阅读这个例子还需要考虑几件事情。 看看你能不能找到答案？ 为什么律师不能通过在解锁脚本上选择FALSE，随时兑换第三条执行路径？ 在UTXO挖出后，5天、35天和105天分别可以使用多少条执行路径？ 如果律师失去密钥，资金是否丢失？ 如果91天过去了，你的答案是否会改变？ 合伙人如何每隔29天或89天“重置”时钟，以防止律师获取资金？ 为什么这个脚本中的一些CHECKSIG操作码有VERIFY后缀，而其他的没有？ 7.8 隔离见证 隔离见证（segwit）是对比特币共识规则和网络协议的升级，是作为BIP-9软分叉被提议并实施的，并于2017年8月1日在比特币的主网上激活。 在密码学中，术语“见证”用于描述解决密码难题的方案。在比特币术语中，见证满足放置在未花费交易输出（UTXO）上的加密条件。 在比特币环境中，数字签名是见证的一种类型，但更广义来说，见证是指能够满足对UTXO施加的条件并解锁该UTXO以供消费的任何解决方案。术语“见证”是“解锁脚本”或“scriptSig”的更一般的术语。 在引入隔离见证之前，交易中的每一个输入后面紧跟着的就是解锁它的见证数据。见证数据作为每个输入的一部分嵌入到交易中。术语隔离见证（简称segwit）只是指把特定输出的签名或解锁脚本隔离开。“单独的scriptSig”或“单独的签名”就是它最简单的形式。 因此，隔离见证是对比特币的一种架构更改，旨在将见证数据从交易的scriptSig（解锁脚本）字段移动到伴随交易的独立的见证数据结构中。客户端要求的交易数据可以包括见证数据，也可以不包括。 在本节中，我们将讨论隔离见证的一些好处，描述用于部署和实现此体系结构更改的机制，并演示在交易和地址中如何使用隔离见证。 隔离见证由以下BIP定义： BIP-141 隔离见证的主要定义。 BIP-143 0版本见证程序的交易签名验证 BIP-144 对等服务-新的网络消息和序列化格式 BIP-145 隔离见证的getblocktemplate更新（用于挖矿） BIP-173 原生v0-16见证输出的Base32地址格式 7.8.1 为什么要用隔离见证 隔离见证是一种架构性更改，对比特币的可扩展性、安全性、经济激励和性能有多方面影响： 交易延展性 将见证数据从交易中移出，用作标识符的交易哈希就不再包括见证数据。由于见证数据是交易中唯一可由第三方修改的部分，请参阅【7.8.5.5 交易标识符】，删除它也就消除了交易延展性攻击的机会。有了隔离见证，交易哈希就不能被除了交易的创建者之外的任何人更改，这大大促进了许多依赖于高级比特币交易构造的其他协议的实现，如支付通道、链式交易和闪电网络。 脚本版本控制 随着隔离见证脚本的引入，每个锁定脚本前面都有一个脚本版本号，类似于交易和区块的版本号。添加脚本版本号允许以后向兼容的方式（例如使用软分叉升级）升级脚本语言，引入新的脚本操作对象、语法或语义。以无中断方式升级脚本语言的能力将大大加快比特币的创新速度。 网络和存储扩展 见证数据通常对交易的总大小有很大贡献。更复杂的脚本，如用于多签或支付通道的脚本体积会非常大。在某些情况下，这些脚本会占到交易数据的大多数（超过75%）。通过将见证数据从交易中移出，隔离见证提高了比特币的可扩展性。节点可以在验证签名后删减见证数据，或者在进行简化的支付验证时完全忽略见证数据。见证数据不再需要发送到所有节点，也不需要被所有节点存储在磁盘上。 签名验证优化 隔离见证升级签名函数（CHECKSIG，CHECKONSIGG等），以减少算法的计算复杂度。在引入隔离见证之前，用于生成签名的算法需要大量与交易大小成比例的哈希操作。相对于签名操作的数量数据哈希计算复杂度增加到O（n2），给验证签名的所有节点带来了巨大的计算负担。有了隔离见证，算法的复杂度降低到O（n）。 离线签名改进 隔离见证签名包含由签名的哈希中的每个输入引用的值（金额）。以前，离线签名设备（如硬件钱包）必须在签名交易之前验证每个输入的金额。这通常是通过流式传输大量先前作为输入引用的交易的数据来实现的。由于金额现在是已签名的提交哈希的一部分，因此离线设备不需要以前的交易。如果金额不匹配（由被入侵的在线系统篡改），签名将是无效的。 7.8.1 隔离见证如何工作 乍一看，隔离见证似乎只是对交易构造方式的改变，属于交易级特性，但事实并非如此。其实，隔离见证是对单独的UTXO花费方式的更改，因此可以说是每个输出层面的特性。 交易可以花费使用了隔离见证的输出或传统（内嵌见证）输出，或两者都有。因此，将交易称为“隔离见证交易”没有多大意义。相反，应该将特定的交易输出称为“隔离见证输出”。 当交易使用UTXO时，必须提供一个见证。在传统的UTXO中，锁定脚本要求见证数据内嵌在花费UTXO的交易的输入部分。但是，隔离见证UTXO指定了一个锁定脚本，该脚本可以用输入之外的见证数据（隔离）满足。 7.8.2 软分叉（后向兼容） 隔离见证是对输出和交易架构方式的重大变革。通常情况下，这种变革需要改变共识规则，要同时更换每个比特币节点和钱包，也就是硬分叉。但是，隔离见证引入的时候采用的是一个更少破坏性的变革，是后向兼容的，称为软分叉。这种类型的升级允许未升级的软件忽略更改并继续运行，而不会造成任何中断。 隔离见证输出被构造成未升级的旧系统仍然可以验证它们。对于旧的钱包或节点，隔离见证输出看起来和其他任何可以花费的输出没什么区别。这样的输出可以使用空签名花费，因此交易内部没有签名（它是隔离的）这一事实不会使交易无效。但是，新的钱包和挖矿节点会看到隔离见证输出，并希望在交易的见证数据中找到有效的见证。 7.8.3 隔离见证输出和交易示例 接下来看一些示例交易，看看它们在隔离见证下会发生什么变化。我们首先研究如何使用隔离见证程序改造Pay-to-Public-Key-Hash（P2PKH）支付。然后，再来研究隔离见证同样如何作用于Pay-to-Script-Hash（P2SH）脚本。最后，研究如何将前面两个隔离见证程序嵌入到P2SH脚本中。 7.8.3.1 Pay-to-Witness-Public-Key-Hash (P2WPKH) 在【2.1.2 买一杯咖啡】中，Alice创建一笔交易，付给Bob一杯咖啡的费用。该笔交易构建了一个价值0.015BTC的 P2PKH 输出（Bob可用来花费），该输出脚本看起来像这样： P2PKH 输出脚本示例： DUP HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 EQUALVERIFY CHECKSIG 如果通过隔离见证，Alice将会创建一个支付给见证公钥哈希Pay-to-Witness-Public-Key-Hash（P2WPKH）脚本，看起来是这样的： P2WPKH 输出脚本示例： 0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 正如你所见，隔离见证输出的锁定脚本比传统输出简单得多。它包含两个值，会被推送到脚本计算堆栈中。对于一个传统（非隔离见证）比特币客户端来说，这两个推送值看起来像是一个任何人都能花费的输出，而不需要签名（或者更确切的说，能被空的签名使用）。而对一个更新的、隔离见证客户端来说，第一个数字（0）被解释为一个版本号（见证版本），第二部分（20字节）相当于一个锁定脚本，被称为见证程序 witness program。这20字节的见证程序就像是 P2PKH 脚本中的公钥哈希值一样。 现在，再看看Bob用来去花费这个输出对应的交易。对于原始脚本（非隔离见证），Bob的交易必须在交易输入中包含签名： 以下被解码的交易，显示了使用签名花费的 P2PKH 输出： [...] “Vin” : [ \"txid\": \"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2\", \"vout\": 0, \"scriptSig\": “”, ] [...] 但是，要花费隔离见证输出，这个交易输入中没有签名。相反，Bob的交易只有空的 scriptSig 和交易本身之外的隔离见证： 以下被解码的交易，显示了使用隔离见证数据花费的 P2WPKH 输出： [...] “Vin” : [ \"txid\": \"0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2\",\"vout\": 0, \"scriptSig\": “”, ] [...] “witness”: “” [...] 7.8.3.2 钱包的P2WPKH 构造 尤其值得注意的是，P2WPKH 应该只能由收款人（接收方）创建，而不是由发送者从已知的公钥、P2PKH 脚本或地址进行转换。发送方无从知道接收者的钱包是否具有能力构建隔离见证交易，并消费 P2WPKH 输出。 另外，P2WPKH 输出必须从压缩公钥的哈希值中创建。未压缩公钥在隔离见证中是非标准的，可能会被将来的软分叉明确禁用。如果在 P2WPKH 中使用的哈希值来自未压缩公钥，那么它可能是不可消费的，资金就可能丢失。P2WPKH 输出应该由收款人的钱包，通过私钥派生的压缩公钥来创建。 警告 P2WPKH 应该由收款人（接收者）通过将压缩公钥转换成P2WPKH哈希值进行创建。绝对不要将P2PKH脚本、比特币地址或未压缩公钥转换成P2WPKH见证脚本。 7.8.3.3 Pay-to-Witness-Script-Hash (P2WSH) 第二种类型的验证程序对应“支付给脚本哈希”（ Pay-to-Script-Hash , P2SH）脚本。我们在【7.3 P2SH（Pay-to-Script-Hash）】中见过这类脚本。例子中，Mohammed的公司使用P2SH 来表示一个多重签名脚本。对Mohammed’s的公司的支付被编码成一个这样的锁定脚本： P2SH 输出脚本示例： HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL 这个P2SH脚本引用了一个兑换脚本的哈希值，该脚本定义了一个花费资金的“2/3”的多重签名要求。为了花费该输出，Mohammed的公司需提供兑现脚本（其哈希值与P2SH输出中的脚本哈希值匹配）和满足兑现脚本所必需的签名，所有这些都在交易输入中： 下面的解码交易显示要被花费的P2SH输出： [...] “Vin” : [ \"txid\": \"abcdef12345...\", \"vout\": 0, \"scriptSig\": “ ”, ] 现在，让我们看看整个示例如何升级成为隔离见证。如果Mohammed的客户使用的是兼容隔离见证的钱包，他们就能创建一个P2WSH输出进行付款，如下： P2WSH 输出脚本示例： 0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73 再一次，就像P2WPKH的例子一样，你可以看到，隔离见证等效脚本要简单得多，省略了P2SH脚本中的各种脚本操作符。而且，隔离见证程序仅包含两个推送到堆栈的值：一个见证版本（0）和一个32字节的兑换脚本的哈希值。 提示 P2SH使用结果为20字节的RIPEMD160(SHA256(script)) 哈希算法，P2WSH见证程序使用了结果为32字节的SHA256（脚本）哈希算法。在选择哈希算法时，这一差异是有意为之，用于通过哈希值长度来区分两种类型的见证程序（P2WPKH and P2WSH），并为P2WSH（128bit安全，P2SH是80bit安全）提供更强的安全性。 Mohammed的公司可以通过提供正确的兑换脚本和足够的签名满足花费P2WSH输出。兑换脚本和签名都将作为见证数据的一部分被隔离在消费交易之外。在交易输入内部，Mohammed的钱包会放一个空的scriptSig： 下面的解码交易显示了带有隔离见证数据的P2WSH输出： [...] “Vin” : [ \"txid\": \"abcdef12345...\",\"vout\": 0, \"scriptSig\": “”, ] [...] “witness”: “ ” [...] 7.8.3.4 P2WPKH和P2WSH的区别 在前面的两节中，我们展示了两种类型的见证程序：支付给见证公钥哈希 (P2WPKH)和 支付给见证脚本哈希(P2WSH) 。这两种见证程序都有一个字节版本号和跟随其后的更长的一个哈希值组成。它们看起来非常相似，但解释却完全不同：一个被解释为一个公钥哈希值，被签名所满足，另一个被解释为脚本哈希值，被兑换脚本所满足。他们之间的关键区别是哈希值的长度： P2WPKH中的公钥哈希值是20字节。 P2WSH中的脚本哈希值是32字节。 正是这个区别使得钱包可以区分这两种类型的见证程序。通过查看哈希值的长度，钱包可以确定是哪种类型的见证程序，P2WPKH 或者 P2WSH。 7.8.4 隔离见证升级 正如我们前面看到的例子，隔离见证的升级需要经过两步过程。首先，钱包必须创建特殊的隔离见证输出。然后，这些输出可以被知道如何构建隔离见证交易的钱包花费。在这些例子中，Alice的钱包是支持隔离见证的，能够使用隔离见证脚本创建特殊输出。Bob的钱包也是支持隔离见证的，能够花费这些输出。这个例子中隐含的是，实际上，Alice的钱包需要知道Bob使用的是支持隔离见证的钱包，也能花费这些输出。否则，如果Bob的钱包没有升级，Alice试图对Bob创建隔离见证付款，那么Bob的钱包将无法检测到这些付款。 提示 对于P2WPKH和P2WSH付款类型，付款和收款钱包都需要升级才能使用隔离见证。此外，付款的钱包还需要知道收款的钱包已经兼容隔离见证。 隔离见证不会在整个网络中同时实施。相反，隔离见证被实施为向后兼容的升级，这时新老客户端都有。钱包开发人员会各自升级自己的钱包软件，添加隔离见证功能。当付款钱包和收款钱包都支持隔离见证时，使用P2WPKH和P2WSH付款类型。传统的P2PKH和P2SH将继续为未升级的钱包工作。这留下了两个重要的场景，下一节将讨论这个情况： 付款钱包不支持隔离见证，如何支付给能处理隔离见证的收款钱包。 付款钱包支持隔离识别，如何根据地址识别和区分收款钱包是否具有隔离见证功能。 7.8.4.1 在P2SH中嵌入隔离见证 举个例子，假设Alice的钱包没有升级隔离见证，但Bob的钱包已经升级，可以处理隔离见证交易。Alice和Bob可以使用“旧”的非隔离见证交易。但是Bob可能想使用隔离见证，享受适用于见证数据的折扣，降低交易费用。 在这种情况下，Bob的钱包会构建一个包含隔离见证脚本的P2SH地址。Alice的钱包认为这是一个“正常的”P2SH地址，并可以在未识别隔离见证的情况下付款。然后，Bob的钱包可以通过隔离见证交易来花费这笔款项，这样充分利用了隔离见证交易并降低交易费用。 两种形式的见证脚本P2WPKH和P2WSH都可以嵌入到P2SH地址中。第一个是P2SH（P2WPKH），第二个是P2SH（P2WSH）。 7.8.4.2 P2SH 中的 P2WPKH 我们将检查的第一种见证脚本是P2SH（P2WPKH）。这是一个支付到见证公钥哈希的见证程序，嵌入在P2SH脚本中，所以可以被不支持隔离见证的钱包使用。 Bob的钱包用Bob的公钥构造了一个P2WPKH见证程序。然后这个见证程序被哈希，这个哈希值被编码成P2SH脚本。P2SH脚本被转换成以“3”开头的比特币地址，正如【7.3 P2SH（Pay-to-Script-Hash）】部分看到的。 Bob的钱包开始使用的就是之前看到的P2WPKH 见证程序： Bob的P2WPKH见证程序： 0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 P2WPKH见证程序由见证版本和Bob的20字节公钥哈希组成。 Bob的钱包然后哈希之前的见证程序，先用SHA256，然后用RIPEMD160，产生另一个20字节的哈希值。 我们使用bx命令重现： P2WPKH见证程序HASH160后的值 echo \\ '0 [ab68025513c3dbd2f7b92a94e0581f5d50f654e7]'\\ | bx script-encode | bx sha256 | bx ripemd160 3e0547268b3b19288b3adef9719ec8659f4b2b0b 接下来，兑换脚本哈希被转换成比特币地址。再看一下bx命令结果： P2SH地址 echo \\ '3e0547268b3b19288b3adef9719ec8659f4b2b0b' \\ | bx address-encode -v 5 37Lx99uaGn5avKBxiW26HjedQE3LrDCZru 现在，Bob可以把这个地址展示给顾客，方便他们付款。Alice的钱包可以支付给37Lx99uaGn5avKBxiW26HjedQE3LrDCZru，就像任何其他比特币地址一样。 为了给Bob付款，Alice的钱包会用P2SH脚本锁定输出： HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL 即使Alice的钱包不支持隔离见证，Bob也可以使用隔离见证交易花费它创建的付款。 7.8.4.3 P2SH 中的 P2WSH 同样，多重签名脚本或其他复杂脚本的P2WSH见证程序也可以嵌入到P2SH脚本和地址中，使得任何钱包都可以实现兼容隔离见证的支付。 正如我们在【7.8.4.3 Pay-to-Witness-Script-Hash (P2WSH)】中看到的，Mohammed的公司正在使用带多重签名脚本的隔离见证支付。为了让任何一个客户都有可能向他的公司付款，不管他们的钱包是否已经升级支持隔离见证，Mohammed的钱包都可以将P2WSH见证程序嵌入到P2SH脚本中。 首先，Mohammed的钱包用SHA256（仅一次）对兑换脚本进行哈希运算。我们使用bx命令： Mohammed的钱包创建了P2WSH见证程序 echo \\ 2 \\ [04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \\ [04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \\ [047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \\ [0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \\ [043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \\ 5 CHECKMULTISIG \\ | bx script-encode | bx sha256 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73 接下来，哈希过的兑换脚本转换为P2WSH见证程序： 0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73 然后，使用SHA256和RIPEMD160对见证程序本身进行哈希，生成一个新的20字节哈希，就像传统P2SH中使用的那样。还是使用bx命令： P2WSH见证程序的HASH160结果 echo \\ '0 [9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73]'\\ | bx script-encode | bx sha256 | bx ripemd160 86762607e8fe87c0c37740cddee880988b9455b2 接下来，钱包从这个哈希构造一个P2SH比特币地址。同样，我们使用bx命令计算： P2SH比特币地址 echo \\ '86762607e8fe87c0c37740cddee880988b9455b2'\\ | bx address-encode -v 5 3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG 现在，Mohammed的客户无需支持隔离见证就可以向这个地址付款。要向Mohammed发送付款，钱包将使用以下P2SH脚本锁定输出： 用于锁定对Mohammed多签的付款的P2SH脚本 HASH160 86762607e8fe87c0c37740cddee880988b9455b2 EQUAL 然后，Mohammed的公司就可以利用隔离见证的特点，包括更低的交易费用，构建隔离见证交易来消费这些款项。 7.8.4.4 隔离见证地址 即使在隔离见证激活后，大多数钱包也需要一段时间才能升级。首先，正如我们在上一节中看到的，隔离见证将嵌入到P2SH中，以简化支持与不支持隔离见证钱包之间的兼容性。 然而，一旦钱包广泛支持隔离见证，直接使用隔离见证设计的原生地址格式，对见证脚本进行编码就很有意义，而不再是将其嵌入P2SH。 原生隔离见证地址格式在BIP-173中定义： 【BIP-173】 原生v0-16见证输出的Base32地址格式 BIP-173只编码见证（P2WPKH和P2WSH）脚本。它与非隔离见证的 P2PKH或P2SH脚本不兼容。与“传统”比特币地址的Base58编码相比，BIP-173是校验和Base32编码。BIP-173地址也称为bech32地址，暗示使用了“BCH”错误检测算法和32字符编码集。 BIP-173地址使用32个小写字母数字字符集，经过了精心选择，减少因误读或敲错产生的错误。选择一个小写字符集，bech32就更易于阅读、提起，并且二维码编码效率提高了45%。 BCH错误检测算法是对以前的校验和算法（从Base58Check）的一个巨大改进，不仅允许检测，而且允许纠正错误。在检测错误时，地址输入界面（如表单中的文本字段）可以检测并突出显示最可能敲错的字符。 根据BIP-173规范，以下是bech32地址的一些示例： 主网 P2WPKH： bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 测试网 P2WPKH： tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx 主网 P2WSH： bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3 测试网 P2WSH： tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7 就像上面示例中所见，隔离见证bech32字符串最长为90个字符，由三部分组成： 人类可读部分： 前缀“bc”和“tb”表示是主网还是测试网 分隔符： 数字“1”，不是32字符编码集的一部分，只是作为分隔符出现在这个位置 数据部分： 最少6个字母数字字符，经过校验和编码的见证脚本 目前，只有少数钱包接受或产生原生隔离见证bech32地址，但随着隔离见证使用率的增加，这些将会越来越多。 7.8.4.5 交易标识符 隔离见证的最大好处之一就是消除了第三方交易延展性。 在隔离见证之前，交易可以通过第三方巧妙地修改其签名，在不改变任何基本属性（输入，输出，金额）的情况下更改其交易ID（哈希）。这为拒绝服务DOS攻击，以及对有缺陷的钱包软件的攻击创造了机会，这些软件假定未经证实的交易哈希是不可变的。 通过引入隔离见证，交易有两个标识符txid和wtxid。传统的txid是序列化交易的双SHA256哈希，没有见证数据。交易的wtxid是具有见证数据的交易的新序列化格式的双SHA256哈希。 传统txid的计算方式与非隔离见证交易完全相同。但是，由于隔离见证交易在每个输入中都有空的scriptSig，不存在可由第三方修改的交易部分。因此，在隔离交易中，即使交易未经确认，txid也是不能被第三方修改的。 wtxid就像一个“扩展的”ID，因为该哈希也包含了见证数据。如果交易在没有见证数据情况下传输，则wtxid和txid是相同的。注意，由于wtxid包含见证数据（签名），并且由于见证数据可能具有延展性，所以在交易确认之前，wtxid被认为是可延展的。只有隔离见证的txid可以被第三方认为是不可变的，并且只有当交易的所有输入都是隔离见证输入时才是不变的。 提示 隔离见证交易有两个ID：txid和wtxid。txid是没有见证数据的交易的哈希，wtxid是包含见证数据的哈希。所有输入都是隔离见证输入的交易，不受第三方交易延展性影响。 7.8.5 隔离见证新的签名算法 隔离见证修改了四个签名验证函数（CHECKSIG，CHECKSIGVERIFY，CHECKMULTISIG和CHECKMULTISIGVERIFY）的语义，改变了交易承诺哈希的计算方式。 比特币交易中的签名应用于一个承诺哈希 commitment hash，该哈希值由交易数据计算得出，锁定了数据中表示签名者承诺这些金额的特定部分。例如，在简单的SIGHASH_ALL类型签名中，承诺哈希包括所有的输入和输出。 不幸的是，计算承诺哈希的方法导致了这样一种可能，即验证签名的节点可能会被迫执行大量哈希计算。具体地说，相对于交易中的签名操作的数量，其哈希操作数量增加了O（n2）复杂度。因此，攻击者可以创建具有大量签名操作的交易，从而导致整个比特币网络必须执行数百或数千个哈希操作来验证该交易。 隔离见证带来机会，通过改变承诺哈希计算方式来解决这个问题。对于隔离见证版本0见证程序，使用BIP-143中规定的改进的承诺哈希算法进行签名验证。 新算法实现了两个重要目标。首先，哈希操作的数量与签名操作的数量相比，平缓增长O（n）复杂度，从而减少了使用过于复杂的交易创建拒绝服务攻击的机会。其次，承诺哈希现在还包括作为承诺的一部分的每个输入的值（金额）。这意味着签名者可以承诺特定的输入值，而无需“获取”和检查输入引用的前一个交易。在离线设备（如硬件钱包）的情况下，这极大地简化了主机与硬件钱包之间的通信，消除了对以前的交易流进行验证的需要。硬件钱包可以接受不可信主机“声明的”的输入值。由于签名是无效的，如果输入值不正确，硬件钱包在签名输入之前不需要验证该值。 7.8.6 隔离见证的经济激励 比特币挖矿节点和全节点支持比特币网络和区块链，会产生资源成本。随着比特币交易量的增加，资源成本（CPU，网络带宽，磁盘空间，内存）也在增加。矿工通过收取与每次交易的大小（字节）成比例的费获得补偿。不挖矿的全节点不能得到补偿，因为需要运行权威的完全验证全索引节点，他们也会有这些成本，他们会使用该节点来运营比特币业务。 如果没有交易费用，比特币数据可能会大幅增加。费用旨在通过基于市场的价格发现机制，使比特币用户的需求与交易对网络带来的负担保持一致。 基于交易占据空间大小的费用计算方式认为交易中的所有数据其成本是相同的。但是从全节点和矿工的角度来看，交易的某些部分的成本要高得多。加入比特币网络的每笔交易都会影响节点上四种资源的消耗： 磁盘空间 每个交易都存储在区块链中，从而增加区块链的总大小。区块链存储在磁盘上，但可以通过“修剪pruning”旧交易来优化存储。 CPU 每个交易都必须经过验证，这需要CPU时间。 带宽 每笔交易至少通过网络传输一次（通过泛洪传播）。如果在区块传播协议中没有任何优化，交易将作为区块的一部分再次传输，对网络容量的影响会加倍。 内存 验证交易的节点将UTXO索引或整个UTXO集保留在内存中，以加快验证。由于内存比磁盘至少贵一个数量级，所以UTXO集的增长不成比例增加了节点的运行成本。 从列表中可以看出，并不是交易的每个部分都对运行节点的成本或者比特币扩展以支持更多交易的能力产生同等的影响。交易中最昂贵的部分是新创建的输出，因为它们被添加到内存中的UTXO集。相比之下，签名（又名见证数据）对网络增加的负担较小，运行节点的成本增加也不多，因为见证数据只被验证一次，之后又不再使用。此外，在收到新的交易并验证见证数据之后，节点可以立即丢弃该见证数据。如果按照交易规模计算费用，而不区分这两种数据，那么市场上的收费激励就不符合交易实际成本。事实上，目前的费用结构实际上鼓励了相反的行为，因为见证数据是交易的最大部分。 收费产生的激励之所以重要，是因为它们会影响钱包的行为。所有的钱包都必须执行一些策略来组合交易，这些策略要考虑到许多因素，比如隐私（减少地址重复使用），碎片化（大量找零）以及费用等。如果费用压倒性地促使钱包在交易中使用尽可能少的投入，这可能导致选择UTXO和改变地址策略，从而不经意地膨胀UTXO集。 交易在其输入中消耗UTXO，并用它们的输出创建新的UTXO。因此，输入比输出多的交易将导致UTXO集合的减少，而输出多于输入的交易将导致UTXO集合的增加。让我们考虑输入和输出之间的差异，并称之为“净增UTXO（Net-new-UTXO）”。这是一个重要的指标，因为它告诉我们交易将对最昂贵的全网资源（内存中的UTXO集）产生什么影响。净增UTXO为正值的交易增加了这一负担。净增UTXO为负值的交易就可以减轻负担。因此，因此，我们希望鼓励负净增UTXO或零净增UTXO持平的交易。 让我们来看一个例子，说明有无隔离见证，交易费用计算产生了哪些激励措施。我们来看两个不同的交易。交易A是3输入，2输出的交易，净增UTXO为-1，意味着它消耗的UTXO比它创建的多了一个，将UTXO减1。交易B是2输入3输出的交易，净增UTXO为1，意味着它向UTXO集增加一个UTXO，增加整个比特币网络的成本。这两个交易都使用多重签名（2/3）脚本来演示复杂脚本如何增加隔离见证对费用的影响。我们假设交易费为每字节30 satoshi，见证数据的折扣费用为75％： 未使用隔离见证 交易A费用：25,710 satoshi交易B费用：18,990 satoshi 使用隔离见证 交易A手续费：8,130 satoshi交易B手续费：12,045 satoshi 实施了隔离见证实施，这两笔交易的费都减少了。但通过比较这两个交易的成本，我们发现，在隔离见证之前，净增UTXO为负的交易的费用更高。在隔离见证之后，交易费用与减少新增UTXO的动机就保持一致，而不是无意中惩罚包含较多输入的交易。 因此，隔离见证对比特币用户支付的费用有两个主要的影响。首先，隔离见证通过折扣见证数据和增加比特币区块链的能力来降低交易的总体成本。其次，隔离见证对见证数据的折扣纠正了可能无意中在UTXO集合中造成更多膨胀的激励偏差。 "},"ch08.html":{"url":"ch08.html","title":"第八章 比特币网络","keywords":"","body":"第8章 比特币网络 8.1 P2P网络架构 比特币采用了基于互联网（Internet）的点对点（peer-to-peer）网络架构。点对点，或者叫P2P是指位于同一网络中的每台计算机都彼此平等，身份对等，各个节点共同提供网络服务，不存在任何“特殊”节点。网络节点以“扁平”的拓扑结构相互连通。 网络中不存在任何服务器端、中央化的服务、以及层级结构。点对点网络中的节点同时提供和消费服务，互惠互利。点对点网络也因此具有可靠性、去中心化，以及开放性。早期的互联网就是点对点网络架构的一个典型用例：IP网络中的各个节点完全平等。当今的互联网架构具有分层架构，但是IP协议仍然保留了扁平拓扑的结构。除了比特币，规模最大也最成功的点对点技术应用是在文件分享领域，Napster是该领域的先锋，BitTorrent是其架构的最新演变。 比特币所采用的点对点网络架构不仅仅是拓扑结构选择。比特币被设计为一种点对点的数字现金系统，它的网络架构既是这种核心特性的反映，也是该特性的基石。去中心化控制是核心设计原则，它只能通过维持一种扁平化、 去中心化的点对点共识网络来实现和维护。 “比特币网络”是运行比特币点对点协议的一系列节点的集合。除了比特币点对点协议之外，比特币网络中也包含其他协议，例如Stratum协议就被应用于挖矿、以及轻量级或移动端比特币钱包。网关路由服务器提供这些协议，使用比特币点对点协议接入比特币网络，并把网络拓展到运行其他协议的各个节点。例如，Stratum服务器通过 Stratum协议将所有的Stratum挖矿节点连接至比特币主网络、并将Stratum协议桥接至比特币点对点协议。我们使用“扩展比特币网络（extended bitcoin network）”指代所有包含比特币点对点协议、矿池挖矿协议、Stratum 协议以及其他连接比特币系统组件相关协议的整体网络结构。 8.2 节点类型及角色 尽管比特币点对点网络中的各个节点地位对等，但是根据所提供的功能不同，各节点可能具有不同的角色。比特币节点是路由、区块链数据库、挖矿、钱包服务这些功能的集合。全节点（full node）包括如图8-1所示的四个功能： 图8-1 具有所有四个功能：钱包，矿工，完整的区块链数据库和网络路由的比特币网络节点 所有节点都包含参与网络的路由功能，并且还可能包含其他功能。每个节点都参与验证并传播交易及区块信息，发现并维持与对等节点的连接。在图8-1中，路由功能由名为“网络路由节点”的圆圈或字母“N”表示。 一些节点保有一份完整的、最新的区块链副本，这样的节点被称为“全节点”。全节点能够自主权威验证所有交易，而不需借由任何外部参照。另外还有一些节点只维护了区块链的子集，并使用一种名为“简易支付验证simplified payment verification，SPV”的方式来验证交易，这样的节点被称为“SPV节点”，又叫“轻量级节点”。在上图的全节点示例中，全节点区块链数据库功能由一个称为“完整区块链”的圆圈或字母“B”表示。在图8-3中，SPV节点没有“B”圆圈，以示它们没有区块链的完整副本。 挖矿节点通过运行在专用硬件设备上的工作量证明（proof-of-work）算法，相互竞争创建新的区块。一些挖矿节点同时也是全节点，保有区块链的完整副本；还有一些参与矿池挖矿的节点是轻量级节点，它们必须依赖矿池服务器维护的全节点进行工作。上图中，挖矿功能如图中名为“矿工”的圆圈，用字母“M”表示。 用户钱包也可以作为全节点的一部分，这在比特币PC客户端中比较常见。越来越多的用户钱包，特别是那些运行在智能手机等资源受限设备上的用户钱包，都是SPV节点。在图8-1中，名为“钱包”的圆圈字母“W”代表钱包功能。 在比特币P2P协议中，除了这些主要的节点类型之外，还有一些服务器及节点也在运行着其他协议，例如专用矿池挖矿协议、轻量级客户端访问协议等。 图8-2描述了扩展比特币网络中最为常见的节点类型。 图8-2描述了扩展比特币网络中最为常见的节点类型。 8.3 扩展比特币网络 运行比特币协议的比特币主网由大约5000-8000个运行着不同版本比特币参考客户端（Bitcoin Core）的监听节点、以及几百个运行着各类比特币点对点协议的其他实现例如Bitcoin Classic, Bitcoin Unlimited, BitcoinJ, Libbitcoin, btcd, and bcoin等的节点组成。比特币点对点网络中的一小部分节点也是挖矿节点，它们竞争挖矿、验证交易、并创建新的区块。许多连接到比特币网络的大型公司运行着基于Bitcoin Core客户端的全节点客户端，它们具有区块链的完整副本及网络节点，但不具备挖矿及钱包功能。这些节点是网络中的边缘路由器，允许在上面构建各种其他服务，例如交易所、钱包、区块浏览器、商业支付处理等。 如前文所述，扩展比特币网络既包括了运行比特币点对点协议的网络，又包含运行专用协议的网络节点。连接到比特币点对点主网上，还有许多矿池服务器以及协议网关，它们把运行其他协议的节点连接起来。这些节点通常都是矿池挖矿节点（参见【第八章 挖矿】）以及轻量级钱包客户端，后者通常不具备区块链的完整备份。 图8-3描述了扩展比特币网络中多种类型的节点、网关服务器、边缘路由器、钱包客户端以及它们相互连接所需的各类协议。 图8-3 显示各种节点类型，网关和协议的扩展比特币网络 8.4 比特币传输网络 虽然比特币点对点网络服务于各种各样类型节点的一般需求，但是对于比特币挖矿节点的特殊需求，它的网络延迟就显得太高了。 比特币矿工参与的是时效性很强的竞争，以解决工作证明问题，延长区块链（（参见【第八章 挖矿】）。在参与这项竞争的同时，比特币矿工必须尽可能缩短从传播一个获胜区块到开始下一轮竞争之间的时间。挖矿中，网络延迟与利润率直接相关。 比特币传输网络是一种尝试最小化矿工之间区块传输延迟的网络。最初的比特币传输网络Bitcoin Relay Network 是由核心开发人员Matt Corallo在2015年创建的，目的是在极低延迟的矿工之间实现区块的快速同步。该网络由几个专门的节点组成，这些节点托管在世界各地的Amazon Web Services基础设施上，用于连接大多数矿工和采矿池。 这个最初的比特币传输网络在2016年被取代，同样是Matt Corallo创建的Fast Internet Bitcoin Relay Engine 或者 FIBRE。 FIBER是一种基于UDP的传输网络，可以节点网络内传输区块。 FIBRE实现了压缩区块优化，以进一步减少数据传输量和网络延迟。 康奈尔大学研究的另一个传输网络（仍在提案阶段）是 Falcon。 Falcon使用“直通路由”而不是“存储转发”来减少延迟，方法是在接收到区块时就开始部分传输，而不是等到接收到完整的区块。 传输网络不是替代比特币的点对点网络。相反，它们是重叠网络，在具有特殊需求的节点之间提供额外的连接，就像高速公路不能替代乡村道路，而是交通繁忙的两点之间的捷径，仍然需要通过小路连接高速公路。 8.5 网络发现 当新的网络节点启动后，它必须发现网络中的其他比特币节点才能参与。要启动这个过程，新节点必须在网络上发现至少一个现有节点并连接到该节点。其他节点的地理位置在哪儿都没有关系，比特币网络拓扑结构没有地理位置的定义。因此，可以随机选择任何现有的比特币节点。 为了连接到一个已知的对等点，节点会建立一个TCP连接，通常连接到端口8333（通常被称为比特币使用的端口），或者如果指定了另一个端口，则连接到另一个端口。在建立连接时，该节点会通过发送一条包含基本认证内容的version消息开始“握手”通信过程(见图8-4)。这一过程包括如下内容： ▷ nVersion 定义了客户端所“说”的比特币点对点协议所采用的版本（例如：70002）。 ▷ nLocalServices 一组该节点支持的本地服务列表，当前仅支持NODE_NETWORK ▷ nTime 当前时间 ▷ addrYou 从该节点看到的远程节点的IP地址 ▷ addrMe 本地节点所发现的本机IP地址 ▷ subver 指示当前节点运行的软件类型的子版本号（例如：”/Satoshi:0.9.2.1/”） ▷ BaseHeight 当前节点区块链的区块高度 （version网络消息的例子请参见GitHub ） 版本消息始终是任何对等节点发送给另一个节点的第一条消息。 接收版本消息的本地对等节点将检查远端节点报告的nVersion，并确定远端对等节点是否兼容。 如果远程对等节点兼容，则本地节点将确认版本消息，并通过发送一个verack建立连接。 新节点如何找到对等节点？ 第一种方法是使用一些“DNS种子”来查询DNS，DNS种子就是提供比特币节点IP地址列表的DNS服务器。 其中一些DNS种子提供了稳定的比特币侦听节点的IP地址静态列表。 一些DNS种子是BIND（Berkeley Internet Name Daemon）的自定义实现，它从爬虫程序或长时间运行的比特币节点收集的比特币节点地址列表中返回一个随机子集。 Bitcoin Core客户端包含五种不同DNS种子的名称。 不同DNS种子的所有权的多样性和实现的多样性为初始引导过程提供了高水平的可靠性。 在Bitcoin Core客户端中，DNS种子选项是否启用由选项开关 -dnsseed控制（默认设置为1，使用DNS种子）。 或者，一个刚刚启动的节点，对网络一无所知，必须被赋予至少一个比特币节点的IP地址，之后才可以通过进一步的引见建立连接。 命令行参数-seednode可用于连接到一个节点，仅用于将其用作引见种子。 在使用初始种子节点完成引见后，客户端将断开连接并使用新发现的对等节点。 图8-4 对等节点之间的初始握手 一旦建立一个或多个连接后，新节点发送一条包含自身IP地址的addr消息给其相邻节点。相邻节点再将此条addr消息依次转发给它们各自的相邻节点，从而保证新节点被其他节点知道、更好连接。另外，新接入的节点可以向它的相邻节点发送getaddr消息，要求它们返回其已知对等节点的IP地址列表。通过这种方式，节点可以找到需连接到的对等节点，并向网络发布它的消息以便其他节点查找。图8-5描述了这种地址发现协议。 图8-5 地址传播和发现 一个节点必须连接到几个不同的对等节点，以便建立进入比特币网络的不同路径。路径不是持久性的，节点可以随时加入或者离开，因此节点必须在失去旧连接时继续发现新节点，并在其他节点启动时提供帮助。节点启动时只需要一个连接，因为第一个节点可以将它引见给它的对等节点，而这些节点又会进一步提供引见。一个节点，如果连接到大量的其他对等节点，这既没必要，也是对网络资源的浪费。在启动完成后，节点会记住它最近成功连接的对等节点，以便当重新启动后它可以迅速与先前的对等节点网络重新建立连接。如果先前的网络的对等节点对连接请求无应答，该节点可以使用种子节点重新启动。 在运行Bitcoin Core客户端的节点上，您可以使用 getpeerinfo 命令列出对等节点： $ bitcoin-cli getpeerinfo { \"addr\" : \"85.213.199.39:8333\", \"services\" : \"00000001\", \"lastsend\" : 1405634126, \"lastrecv\" : 1405634127, \"bytessent\" : 23487651, \"bytesrecv\" : 138679099, \"conntime\" : 1405021768, \"pingtime\" : 0.00000000, \"version\" : 70002, \"subver\" : \"/Satoshi:0.9.2.1/\", \"inbound\" : false, \"startingheight\" : 310131, \"banscore\" : 0, \"syncnode\" : true }, { \"addr\" : \"58.23.244.20:8333\", \"services\" : \"00000001\", \"lastsend\" : 1405634127, \"lastrecv\" : 1405634124, \"bytessent\" : 4460918, \"bytesrecv\" : 8903575, \"conntime\" : 1405559628, \"pingtime\" : 0.00000000, \"version\" : 70001, \"subver\" : \"/Satoshi:0.8.6/\", \"inbound\" : false, \"startingheight\" : 311074, \"banscore\" : 0, \"syncnode\" : false } 用户可以通过提供 -connect= 选项来指定一个或多个IP地址，从而实现手动指定IP地址列表，取消自动节点管理功能。如果采用此选项，节点只连接到这些指定的节点IP地址，而不会自动发现并维护对等节点之间的连接。 如果已建立的连接没有数据通信，所在的节点会定期发送信息以维持连接。如果节点的某个连接长达90分钟没有任何通信，它会认为自己已经从网络断开，开始查找一个新的对等节点。因此，网络可以动态地调整节点变化和网络问题，并且可以根据需要在没有任何中央控制的情况下进行有机的增长和收缩。 8.6 全节点 全节点是指维持包含全部交易信息的完整区块链的节点。更加准确地说，这样的节点应当被称为“完整区块链节点”。在比特币发展的早期，所有节点都是全节点；当前的 Bitcoin Core 客户端也是完整区块链节点。但在过去的两年中出现了许多新型客户端，它们不需要维持完整的区块链，而是作为轻量级客户端运行。在下面的章节里我们会对这些轻量级客户端进行详细介绍。 完整区块链节点维护完整的、最新的包含全部交易信息的比特币区块链副本，这样的节点可以独立地进行建立并校验区块链，从第一区块（创世区块）一直建立到网络中最新的区块。完整区块链节点可以独立权威验证任何交易，而不需要借助任何其他节点或其他信息来源。完整区块节点通过比特币网络获取包含交易信息的新区块更新，在验证无误后将此更新合并至本地的区块链副本中。 运行完整区块链节点可以给您一种纯粹的比特币体验：不需借助或信任其他系统即可独立地对所有交易信息进行验证。 很容易判断是否正在运行完整节点，因为它需要超过100 GB的持久存储（磁盘空间）来存储完整的区块链。如果您需要很大的磁盘空间、并且同步比特币网络耗时2至3天，那么您运行的正是全节点。这就是摆脱中心化权威、获得完全的独立自由所要付出的代价。 尽管目前还有一些使用不同编程语言及软件架构构建的其他的完整区块链客户端存在，但是最常用的仍然是Bitcoin Core客户端，它也被称为“Satoshi客户端”。比特币网络中超过75%的节点运行着不同版本的Bitcoin Core客户端。它在版本消息中发送的子版本字符串中被标识为“Satoshi”，就像前面看到的getpeerinfo命令显示的，例如/Satoshi:0.8.6/。 8.7 交换“库存” 一个全节点连接到对等节点之后，首先做的就是尝试构建完整的区块链。如果该节点是一个全新节点，它就不包含任何区块链信息，它只知道一个区块——在客户端软件中静态内置的创世区块。新节点需要从0号区块（创世区块）开始下载数十万区块的全部内容，跟网络同步、并重建完整区块链。 同步区块链的过程从发送version消息开始，这是因为该消息中含有的BestHeight字段包含了一个节点当前的区块链高度（区块数量）。节点可以从它的对等节点中得到版本消息，了解双方各自有多少区块，从而可以与其自身区块链所拥有的区块数量进行比较。对等节点们会交换一个getblocks消息，其中包含他们本地区块链的顶端区块哈希值（指纹）。如果某个对等节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，那么它就能推断出：其自身的本地区块链比其他对等节点的区块链更长。 拥有更长区块链的对等节点比其他节点有更多的区块，可以识别出哪些区块们是其他节点需要“补充”的。它会识别出第一批可供分享的500个区块，通过inv（inventory）消息把这些区块的哈希值传播出去。缺少这些区块的节点便可以通过各自发送的getdata消息来请求得到完整区块信息，用包含在inv消息中的哈希值来识别被请求的区块，检索缺失的区块。 在下例中，我们假设某节点只含有创世区块。它收到了来自对等节点的inv消息，其中包含了区块链中后500个区块的哈希值。于是它开始向所有与之相连的对等节点请求区块，并通过分摊工作量的方式防止单一对等节点被批量请求所压垮。该节点会追踪记录其每个对等节点连接上“正在传输”（指那些它已经发出了请求但还没有接收到）的区块数量，并且检查该数量有没有超过上限（ MAX_BLOCKS_IN_TRANSIT_PER_PEER ）。用这种办法，如果一个节点需要更新大量区块，它会在上一请求完成后才发送对新区块的请求，从而允许对等节点控制更新速度，不至于压垮网络。每一个区块在被接收后就会被添加至区块链中，这一过程详见【第九章区块链】。随着本地区块链的逐步增加，越来越多的区块被请求和接收，整个过程将一直持续到该节点与全网络完成同步为止。 任何时候节点如果离线，都会将本地区块链与对等节点进行比较，并检索任何丢失的区块。如果一个节点只离线几分钟，可能只会缺失几个区块；当它离线长达一个月，可能会缺失上千个区块。但无论哪种情况，它都会从发送 getblocks 消息开始，收到一个inv响应，接着开始下载缺失的区块。库存和区块传播协议如图8-6所示。 图8-6节点通过检索来自对等节点的区块同步区块链 8.8 简易支付验证 （Simplified Payment Verification (SPV) ）节点 并非所有的节点都有能力存储完整的区块链。许多比特币客户端被设计成运行在空间和功耗受限的设备上，如智能手机、平板电脑、嵌入式系统等。对于这样的设备，通过简化的支付验证SPV，simplified payment verification的方式可以使它们在不必存储完整区块链的情况下进行工作。这种类型的客端被称为SPV客户端或轻量级客户端。随着比特币的普及，SPV节点逐渐变成比特币节点（尤其是比特币钱包）所采用的最常见的形式。 SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小只有完整区块链的1/1000。SPV节点不能构建所有可用于消费的UTXO的全貌，这是由于它们并不知道网络上所有交易的完整信息。SPV节点验证交易时所使用的方法略有不同，这个方法需依赖对等节点“按需”提供区块链相关部分的局部视图。 打个比方来说，每个全节点就像是一个在陌生城市里的游客，他带着一张包含每条街道、每个地址的详细地图。相比之下，SPV节点更像是只知道这座陌生城市一条主街道名字的游客，只能随机询问陌生人转弯方向。虽然两种游客都可以通过实地考察来验证一条街是否存在，但没有地图的游客不知道那个街道位于哪里，也不知道附近还有什么其他街道。没有地图的游客在“教堂街23号”的前面，并不知道这个城市里是否还有其他“教堂街23号”，也不知道面前的这个是否是要找的那个。对他来说，最好的方式就是向足够多的人问路，并且希望不会有人抢劫他。 简易支付验证是通过参考交易在区块链中的深度，而不是高度，来验证它们。一个拥有完整区块链的节点会构造一条验证链，这条链是由沿着区块链按时间倒序一直追溯到创世区块的数千区块及交易组成。而一个SPV节点会验证所有区块的链（但不是所有的交易），并且把区块链和与自己有关的交易链接起来。 例如，一个全节点要检查第300,000号区块中的某个交易，它会把从该区块开始一直回溯到创世区块的300,000个区块全部都链接起来，并建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。SPV节点则不能验证UTXO是否还未被支付。相反地，SPV节点会在该交易信息和它所在区块之间用merkle路径（见【9.7 Merkle 树】）建立一条链接。然后SPV节点一直等待，直到序号从300,001到300,006的六个区块堆叠在该交易所在的区块之上，并通过确立交易的深度是在第300,006区块~第300,001区块之下来验证交易的有效性。事实上，如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了6个区块，就是代理其证明该交易不是双重支付。 如果一个交易实际上不存在，SPV节点不会误认为该交易存在于某区块中。SPV节点会通过请求merkle路径证明以及验证区块链中的工作量证明，来证实交易的存在性。可是，一个交易的存在是可能对SPV节点“隐藏”的。SPV节点毫无疑问可以证实某个交易的存在性，但它不能验证该交易不存在（譬如同一个UTXO的双重支付），这是因为SPV节点没有一份关于所有交易的记录。这个漏洞会被针对SPV节点的拒绝服务攻击或双重支付攻击所利用。为了防御这些攻击，SPV节点需要随机连接到多个节点，以增加至少连接一个可靠节点的概率。这种随机连接的需求意味着SPV节点也容易受到网络分区攻击或Sybil攻击，这种情况更多是，SPV节点被连接到虚假节点或虚假网络中，没有连接到可靠节点或真正的比特币网络。 在绝大多数的实际情况中，具有良好连接的SPV节点是足够安全的，它在资源需求、实用性和安全性之间维持恰当的平衡。当然，如果要保证万无一失的安全性，最可靠的方法还是运行完整区块链的节点。 提示 完整的区块链节点验证交易的时候是通过检查整个链中在该交易之下的数千个区块来保证这个UTXO没有被支付。而 SPV节点是通过检查在其上面的少数区块将它压在下面的深度来验证交易。 SPV节点使用的是一条getheaders消息，而不是getblocks消息来获得区块头。响应的对等节点将用一条headers 消息发送多达2000个区块头。这一过程和全节点获取所有区块的过程没什么区别。SPV节点还在与对等节点的连接上设置了过滤器，用以过滤从对等节点发来的未来区块和交易数据流。任何有关的交易都是通过一条getdata的请求来读取的。对等节点生成一条包含交易信息的tx消息作为响应。区块头的同步过程如图8-7所示。 图8-7 SPV节点同步区块头 由于SPV节点需要读取特定交易从而选择性地验证交易，这样就又产生了隐私风险。与全区块链节点收集每一个区块内的全部交易所不同的是，SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。例如，监控网络的第三方可以跟踪某个SPV节点上的钱包所请求的全部交易信息，并且利用这些交易信息把比特币地址和钱包的用户关联起来，从而损害了用户的隐私。 在引入SPV/轻量级节点后不久，比特币开发人员添加了一个名为布隆过滤器bloom filters的功能来解决SPV节点的隐私风险。 Bloom过滤器允许SPV节点通过使用概率而不是固定模式的过滤机制接收交易的一个子集，无需精确地泄露他们感兴趣的地址。 8.9 布隆过滤器 布隆过滤器是一种基于概率的过滤方法，允许用户无需精确指定来描述特定模式。它给用户提供了一种有效的方式表示搜索模式同时又保护他们的隐私。在SPV节点里，这一方法被用来向对等节点请求发送匹配特定模式的交易，同时又不会泄露地址，密钥和搜索的交易。 用我们之前的例子，一位手中没有地图的游客需要询问去特定“地方教堂街23号”的路线。如果她向陌生人问到这条街， 不经意之间，就暴露了自己的目的地。布隆过滤器则会这样问，“附近有带‘堂’字的街道吗？”这样的问法会较少泄露目的地的信息。这种方法，这位游客可以仔细指定自己的地址，比如“以‘堂街’结尾”或者“‘教’字开头的街道”。通过改变搜索的精度，她可以或多或少地透露信息，代价是获得更多或更少的具体结果。如果她问的不太具体，会得到更多可能的地址和更好的隐私，但很多结果是无关的。如果她要求的非常具体，她得到的结果较少，但会失去隐私。 布隆过滤器可以让SPV节点指定交易的搜索模式，可以基于准确性或私密性进行调节。一个非常具体的布隆过滤器会生成更准确的结果，但代价是透露SPV节点感兴趣的模式，从而揭示用户钱包拥有的地址。反之，如果过滤器只包含简单的关键词，将会产生更多交易的更多数据，其中许多与节点无关，但节点会保持更好的隐私。 8.9.1 布隆过滤器如何工作 布隆过滤器通过一个由N个二进制数字（bit字段）的可变长度数组以及可变数量的M个哈希函数实现的。这些哈希函数的输出值始终在1和N之间，该数值与二进制位数组相对应。并且该函数为确定性函数，也就是说任何一个使用相同布隆过滤器的节点通过该函数都能对特定输入得到同一个的结果。布隆过滤器的准确性和私密性能通过改变长度（N）和哈希函数的数量（M）来调节。 在图8-8中，我们用一个小型的16位数组和3个哈希函数来演示布隆过滤器的应用原理。 图8-8 一个简单的布隆过滤器的例子，16位的字段和3个哈希函数 布隆过滤器数组里的每一个位的初始值都为零。要将模式添加到布隆过滤器，每个哈希函数都要依次哈希这个模式。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组（编号依次为1至N）中所对应的位被置为1，这样把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1；以此类推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个搜索模式也被“记录”在了布隆过滤器里。 图8-9显示了向图8-8里的简易Bloom过滤器添加模式“A”。 图8-9 向简易布隆过滤器添加模式“A” 增加第二个模式就是简单地重复之前的步骤。模式依次通过各哈希函数运算之后，相应的位改变为1，布隆过滤器记录下该模式。需要注意的是，当布隆过滤器里添加了更多的模式时，对应的某个哈希函数的输出值的位可能已经是1了，这种情况下，该位不会再次改变。也就是说，随着更多的模式指向了重复的位，布隆过滤器随着位1的增加而饱和，准确性也就开始降低了。该过滤器之所以是基于概率的数据结构，就是因为模式的增加会导致准确性的降低。 准确性取决于模式的数量以及数组大小（N）和哈希函数的多少（M）。更多位的数组和更多的哈希函数会记录更多的模式以提高准确性。而小的数组及有限的哈希函数只能记录有限的模式从而降低准确性。 图8-10显示了向该简易布隆过滤器里增加第二个模式“B”。 图8-10 向该简易布隆过滤器里增加第二个模式“B” 为测试某一模式是否被记录在某个布隆过滤器中，我们将该模式逐一代入各哈希函数中运算，并将所得的结果与原数组进行对比。如果所有的结果对应的位都变为了1，则表示这个模式有可能已被该过滤器记录。因为这些字节1也有可能是其他模式运算的重叠结果，所以这一结论并不确定，但是是相当可能的。简单来说，Bloom过滤器正匹配代表着“可能是”。 图8-11是一个验证模式“X”是否在前述Bloom过滤器中的图例。相应的比特位都被置为1，所以这个关键词很有可能是匹配的。 图8-11 在布隆过滤器中测试模式“X”的存在。结果是概率正匹配，意思是“也许” 另一方面，如果我们代入模式计算后的结果任何某位为0，说明该模式并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。 图8-12是一个验证模式“Y”是否存在于简易布隆过滤器中的图例。图中某个结果字段为0，该字段一定没有被匹配。 图8-12 在bloom过滤器中测试模式“Y”的存在。 结果是明确的否定匹配，意思是“绝对没有！” 8.10 SPV节点如何使用布隆过滤器 布隆过滤器用于过滤SPV节点从其对等节点接收的交易（和包含它们的区块），仅选择SPV节点感兴趣的交易，而不会泄露其感兴趣的地址或密钥。 SPV节点将初始化“过滤器”为“空”，在该状态下，布隆过滤器将不会匹配任何模式。然后，SPV节点通过从其钱包控制的任何UTXO中提取公钥哈希，脚本哈希和交易ID，然后列出所有感兴趣的地址，密钥和哈希值。 SPV节点再将其中的每一个添加到布隆过滤器，如果这些模式存在于交易中，则布隆过滤器将“匹配”，而不会透露这些模式内容。 然后，SPV节点将向对等节点发送一个filterload消息，其中包含本连接上使用的布隆过滤器。在对等节点上，针对每个传入交易检查布隆过滤器。全节点根据布隆过滤器检查交易的几个部分，寻找匹配，包括： 交易ID 每个交易输出的锁定脚本的数据组件（脚本中的每个密钥和哈希） 每个交易输入 每个输入签名数据组件（或见证脚本） 通过检查所有这些组件，可以使用布隆过滤器来匹配公钥哈希，脚本，OP_RETURN值，签名中的公钥或任何将来的智能合约或复杂脚本的组件。 在建立过滤器之后，对等节点会将按照布隆过滤器测试每个交易的输出。只有与过滤器匹配的交易才会发送到节点。 作为对节点的getdata消息的响应，对等节点将发送一条merkleblock消息，该消息仅包含与过滤器匹配的区块的区块头和每个匹配交易的默克尔树路径（参见【9.7 Merkle 树】）。然后，再发送包含过滤器匹配的交易的tx消息。 当全节点向SPV节点发送交易时，SPV节点会丢弃任何误报，并使用正确匹配的交易来更新其UTXO集和钱包余额。随着它更新自己的UTXO集视图，它还会修改布隆过滤器，以匹配任何引用其刚刚发现的UTXO的交易。然后，全节点使用新的布隆过滤器来匹配新交易，并重复整个过程。 设置布隆过滤器的节点可以通过发送filteradd消息将模式交互式添加到过滤器。要清除布隆过滤器，节点可以发送一个filterclear消息。由于无法从布隆过滤器中删除模式，因此如果不再需要该模式，则节点必须清除并重新发送新的布隆过滤器。 BIP-37 (Peer Services)中定义了SPV节点的网络协议和布隆过滤机制。 8.11 SPV节点和隐私 实现SPV的节点的隐私性比全节点弱一些。全节点接收所有交易，因此不会泄露它的钱包中是否使用某个地址。 SPV节点接收与其钱包中的地址相关的经过过滤的列表。因此，它降低了所有者的隐私。 布隆过滤器是减少隐私损失的一种方式。没有它们，SPV节点将不得不明确地列出它感兴趣的地址，造成严重的隐私违规。然而，即使使用过滤器，监控SPV客户端流量的对手或直接连接它的点对点网络中的节点也可以随时随地收集足够的信息来了解SPV客户端的钱包中的地址。 8.12 加密和认证连接 比特币的大多数新用户假想比特币节点的网络通信是加密的。其实，比特币的最初实现完全是明文通信。虽然这不是全节点的主要隐私问题，但SPV节点是一个很大的问题。 作为增加比特币点对点网络隐私性和安全性的方法，有两种解决方案可以提供通信加密：通过BIP-150/151的Tor传输和P2P认证和加密。 8.12.1 Tor网络传输 Tor代表洋葱路由网络The Onion Routing network，是一个软件项目和网络，通过提供匿名，不可追踪和隐私的随机网络路径实现数据的加密和封装。 Bitcoin Core提供了多种配置选项，允许运行通过Tor网络传输流量的比特币节点。此外，Bitcoin Core还可以提供Tor隐藏服务，允许其他Tor节点通过Tor网络直接连接到您的节点。 从Bitcoin Core版本0.12开始，如果能够连接到本地Tor服务，节点将自动提供隐藏的Tor服务。如果您安装Tor并且运行Bitcoin Core进程账户具有足够权限的用户访问Tor的认证cookie，那么就能自动运行。使用debug标志打开Bitcoin Core对于Tor服务的调试，如下所示： $ bitcoind --daemon --debug=tor 你在日志中看到“tor：ADD_ONION success”，表示Bitcoin Core已经向Tor网络添加了隐藏的服务。 您可以在Bitcoin Core文档（docs / tor.md）和各种在线教程中找到有关运行Bitcoin Core作为Tor隐藏服务的更多说明。 8.12.2 点对点认证和加密 BIP-150和BIP-151两个比特币改进方案在比特币网络中增加支持了点对点认证和加密。这两个BIP定义了可由兼容的比特币节点提供的可选服务。 BIP-151为启用BIP-151的两个节点之间的所有通信实现协商加密。 BIP-150提供可选的对等身份认证，允许节点使用ECDSA和私钥验证彼此的身份。 BIP-150要求在认证之前，两个节点按照BIP-151建立了加密通信。 截至2017年1月，BIP-150和BIP-151未在Bitcoin Core中实施。但是，这两个提案已由至少一个名为bcoin的比特币替代客户端实施。 BIP-150和BIP-151允许用户运行连接到受信任的全节点的SPV客户端，使用加密和身份验证来保护SPV客户端的隐私。 此外，可以使用身份验证来创建可信比特币节点的网络，防止中间人攻击。最后，点对点加密如果广泛部署，将加强比特币对流量分析和隐私侵权监控的抵抗力，特别是在互联网使用受到严格控制和监控的极权主义国家。 标准定义在BIP-150 (Peer Authentication) and BIP-151 (Peer-to-Peer Communication Encryption). 8.13 交易池 比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池memory pool, mempool, 或交易池transaction pool。节点们利用这个池来追踪记录那些被网络所知晓、但还未被区块链所包含的交易。例如，钱包节点会利用这个交易池来记录那些网络已经接收但还未被确认的、属于该用户钱包的传入支付。 随着交易被接收和验证，它们被添加到交易池并通知到相邻节点，从而传播到网络中。 有些节点的实现还维护一个单独的孤儿交易池。如果一个交易的输入引用的是一个未知的交易，比如找不到其父交易，该孤儿交易就会被暂时储存在孤儿交易池中直到父交易到达。 当一个交易被添加到交易池中，会同时检查孤儿交易池，看是否有某个孤儿交易引用了此交易的输出（是其子交易）。任何匹配的孤儿交易会被进行验证。如果验证有效，它们会从孤儿交易池中删除，并添加到交易池中，延续以这个父交易开始的链。鉴于新加入交易池的交易不再是孤儿交易，前述过程重复递归寻找进一步的后代，直至所有的后代都被找到。通过这个过程，父交易的到达触发了一个相互依赖的交易链的级联重建，在整个链的下游将孤儿和他们的父交易重新联合起来。 交易池和孤儿交易池（如有实施）都是存储在本地内存中，并不是存储在永久性存储设备里。更准确的说，它们是随网络传入的消息动态填充的。节点启动时，两个池都是空的，随着网络中新交易不断被接收，两个池逐渐被填充。 有些比特币客户端的实现还维护一个UTXO数据库，也称UTXO池，是区块链中所有未花费交易输出的集合。“UTXO 池”的名字听上去与交易池相似，但它代表了不同的数据集。UTXO池不同于交易池和孤立交易池的地方在于，它在初始化时不为空，而是包含了从创世区块以来的数以百万计的所有未花费交易输出条目。UTXO池可能会被安置在本地内存，或者作为一个包含索引的数据库表安置在永久性存储设备中。 交易池和孤儿交易池代表的是单个节点的本地视角。取决于节点的启动时间或重启时间，不同节点的两池内容可能有很大差别。相反地，UTXO池代表的是全网的自发共识，因此，不同节点间UTXO池的内容差别不大。此外，交易池和孤儿交易池只包含未确认交易，而UTXO池只包含已确认输出。 "},"ch09.html":{"url":"ch09.html","title":"第九章 区块链","keywords":"","body":"第9章 区块链 9.1 简介 区块链数据结构是一个有序的、反向链接的包含交易的区块列表。它可以被存储为平面文件（flat file），或是存储在一个简单数据库中。Bitcoin Core客户端使用Google的LevelDB数据库存储区块链元数据。区块被“向后”链接，每个区块都指向链中的前一个区块。区块链经常被视为一个垂直的栈，第一个区块作为栈底的首区块，随后每个区块都被放置在之前的区块之上。区块彼此堆叠在一起这种形象化，可以方便使用一些术语，例如：“高度”来表示区块与首区块之间的距离，以及“顶部”或“顶端”来表示最新添加的区块。 区块链中的每个区块都由一个哈希值标识，该哈希值是对区块头进行SHA256加密哈希算法生成。同时， 每一个区块都可以通过其区块头的“父区块哈希值”字段引用前一区块，叫父区块。也就是说，每个区块头都包含它的父区块哈希值。这样把每个区块链接到各自父区块的哈希值序列就创建了一条链，可以一直追溯到有史以来的第一个区块，叫创世区块。 虽然每个区块只有一个父区块，但可以暂时拥有多个子区块。每个子区块都将同一区块作为其父区块，并且在“父区块哈希值”字段中具有相同的父区块哈希值。一个区块出现多个子区块的情况被称为“区块链分叉”。区块链分叉只是暂时状态，只有当多个不同区块被不同的矿工几乎同时发现时才会发生（参见【10.10.1 区块链分叉】）。最终，只有一个子区块会成为区块链的一部分，区块链分叉的问题就被解决了。尽管一个区块可能会有不止一个子区块，但每一区块只有 一个父区块，这是因为一个区块只有一个“父区块哈希值”字段可以指向它的唯一父区块。 由于区块头里面包含“父区块哈希值”字段，所以也会影响到当前区块的哈希值。如果父区块的标识发生变化，子区块的标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。这将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，以此类推。这种瀑布效应确保了一旦一个区块之后有很多后代，要对其进行修改，就不得不强制重新计算该区块所有后续的区块。正是这样的重新计算需要耗费巨大的计算量（以及由此带来的能量消耗），所以一个长区块链的存在可以让区块链的深度历史无法改变，这也是比特币安全性的一个关键特征。 你可以把区块链想象成地质构造中的地质层或者是冰川岩芯样品。表层可能会随着季节而变化，甚至在沉积之前就被风吹走了。但是越往深处，地质层就变得越稳定。到了几百英尺深的地方，你看到的将是保存了数百万年但依然未受干扰的过去的快照。在区块链里，最近的几个区块可能会由于区块链分叉所引发的重新计算而被修改。最新的六个区块就像几英寸深的表土层。但是，超过这六块后，区块在区块链中的位置越深，被改变的可能性就越小。在100个区块以后，区块链已经足够稳定，这时Coinbase交易（包含新挖出的比特币的交易）可以被花费了。几千个区块（一个月）后的区块链将变成确定的历史，实际上永远不会改变。虽然协议总是允许一条链被较长的链取代，所以任何区块被逆转的可能性总是存在，但这样的事件的概率随着时间的流逝而减小，直到永不可能。 9.2 区块结构 区块是一种容器数据结构，用于聚合要包含在公共分类账簿（区块链）中的交易。它由一个包含元数据的区块头和紧跟其后的占据区块最大空间的一长串交易列表组成。区块头是80字节，而平均每个交易至少是400字节，而且平均每个区块至少包含超过1900个交易。因此，一个包含所有交易的完整区块比区块头大1000倍。表7-1描述了一个区块结构。 表7-1 区块结构 Size| Field| Description | ---- | ---- |---- 4 bytes|Block Size|The size of the block, in bytes, following this field 80 bytes|Block Header|Several fields form the block header 1–9 bytes (VarInt)|Transaction Counter|How many transactions follow Variable|Transactions|The transactions recorded in this block 9.3 区块头 区块头由三组区块元数据组成。首先，有一个对前一个区块哈希的引用，它将此区块连接到区块链中的前一个区块。第二组元数据，即难度difficulty、时间戳timestamp和随机数nonce，与挖矿竞争相关，详见【第10章挖矿】。第三组元数据是默克尔树根，一种用来有效地汇总区块中所有交易的数据结构。表7-2描述了区块头的数据结构。 表7-2 区块头结构 Size| Field| Description | ---- | ---- |---- 4 bytes|Version|A version number to track software/protocol upgrades 32 bytes|Previous Block Hash|A reference to the hash of the previous (parent) block in the chain 32 bytes|Merkle Root|A hash of the root of the merkle tree of this block’s transactions 4 bytes|Timestamp|The approximate creation time of this block (seconds from Unix Epoch) 4 bytes|Difficulty Target|The Proof-of-Work algorithm difficulty target for this block 4 bytes|Nonce|A counter used for the Proof-of-Work algorithm 随机数、难度目标和时间戳会用于挖矿过程，更多细节将在【第10章挖矿】讨论。 9.4 区块标识符：区块头哈希值和区块高度 区块标识符最主要的是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值block hash，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例如:000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是比特币第一个区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。 请注意，一个区块不管是在网络上传输时，还是它作为区块链的一部分被存储在某节点的永久性存储设备上，其区块哈希值实际上都不包含在区块的数据结构里。相反，区块哈希值是由从网络上收到该区块的每个节点计算出来的。区块哈希值可能会作为区块元数据的一部分被单独存储在一个数据库表中，以便于索引和更快地从磁盘检索区块。 第二种识别区块的方式是通过该区块在区块链中的位置，即区块高度block height。第一个区块，其区块高度为 0，和之前哈希值000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f所引用的区块为同一个区块。因此，区块可以通过两种方式被标识：区块哈希值或者区块高度。每一个随后被存储在第一个区块之上的区块在区块链中都比前一区块“高”出一个位置，就像箱子一样,一个接一个堆叠在其他箱子之上。2017年1月1日的区块高度大约是 446,000，说明已经有446,000个区块被堆叠在2009年1月创建的第一个区块之上。 和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度， 但反过来却并不成立，一个区块高度并不总是标识一个唯一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。这种情况在【10.10.1 区块链分叉】一节中有详细讨论。区块高度也不是区块数据结构的一部分， 不被存储在区块里。当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。 区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。 提示一个区块的区块哈希值总是能唯一地标识出一个特定区块。一个区块也总是有特定的区块高度。但是，一个特定的区块高度并不一定总是能唯一地标识一个特定区块。更确切地说，两个或者更多数量的区块也许会为了区块链中的一个位置而竞争。 9.5 创世区块 区块链里的第一个区块创建于2009年，被称为创世区块。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。 因为创世区块被静态编入到比特币客户端软件里，无法改变，所以每一个节点都是从最少包括这个区块的区块链开始。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都有了区块链的起点，一个安全的“根”，从中构建一个可信的区块链。 在chainparams.cpp里可以查看Bitcoin Core客户端里创世区块静态编码。 创世区块的哈希值为： 0000000000 19d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 你可以在任何区块浏览网站搜索这个区块哈希值，如blockchain.info，你会发现一个描述这一区块内容的页面，该页面的链接包含了这个区块哈希值： https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 在命令行使用Bitcoin Core客户端： $ bitcoin-cli getblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f { \"hash\" : \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\", \"confirmations\" : 308321, \"size\" : 285, \"height\" : 0, \"version\" : 1, \"merkleroot\" : \"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\", \"tx\" : [ \"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\" ], \"time\" : 1231006505, \"nonce\" : 2083236893, \"bits\" : \"1d00ffff\", \"difficulty\" : 1.00000000, \"nextblockhash\" : \"00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048\"} 创世区块包含一个隐藏的信息。在其Coinbase交易的输入中包含这样一句话“The Times 03/Jan/2009 Chancellor on brink of second bailout forbanks.”这句话是泰晤士报当天的头版文章标题，引用这句话，是证明该区块最早的创建日期，也可视为半开玩笑地提醒人们一个独立的货币制度的重要性，告诉人们与比特币的发行，同时伴随着一场前所未有的世界性货币危机。该消息是由比特币的创立者中本聪嵌入创世区块中的。 9.6 将区块连成区块链 比特币的全节点在本地保存了区块链从创世区块起的完整副本。随着新的区块的产生，该区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。为建立这种链接，节点将检查传入的区块头并寻找该区块的“父区块哈希值”。 假设，例如一个节点在区块链的本地副本中有277,314个区块。该节点知道最后一个区块为第277,314区块，这个区块的区块头哈希值为： 00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249 然后该比特币节点从网络上接收到一个新的区块，该区块描述如下： { \"size\" : 43560, \"version\" : 2, \"previousblockhash\" : \"00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249\", \"merkleroot\" : \"5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d\", \"time\" : 1388185038, \"difficulty\" : 1180923195.25802612, \"nonce\" : 4215469401, \"tx\" : [ \"257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77\", #[... many more transactions omitted ...] \"05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634\" ] } 对于这一新的区块，节点会在“父区块哈希值”字段里找出包含它的父区块哈希值。对于本节点来说这是已知的哈希值，也就是第 277314块区块的哈希值。故这个新区块是这个链条里的最后一个区块的子区块，因此现有的区块链得以扩展。节点将新的区块添加至链条的尾端，使区块链延长到一个新的高度277315。图9-1显示了通过“父区块哈希值”字段连接三个区块的链。 图9-1 区块通过引用前面的区块头哈希连接成区块链 9.7 默克尔树 区块链中的每个区块都使用默克尔树merkle tree归纳了区块链内的所有交易。 默克尔树是一种二叉哈希树binary hash tree，它是一种有效归纳和验证数据集完整性的数据结构。默克尔树是包含密码哈希的二叉树。术语“树”在计算机学科中常被用来描述一种具有分支的数据结构，但是树常常被倒置显示，“根”在图的上部而“叶子”在图的下部，你会在后续章节中看到相应的例子。 在比特币网络中，默克尔树被用来归纳一个区块中的所有交易，生成整个交易集合的数字指纹，且提供了一种验证某交易是否存在于某个区块的高效方法。生成一棵完整的默克尔树需要递归地对每一对节点进行哈希，直到只剩一个哈希值，它就是根root，或者默克尔树根Merkle root。在比特币的默克尔树中使用的加密散列算法SHA256被应用了两次，因此也被称为双哈希double-SHA256。 当N个数据元素被哈希和归纳到默克尔树中，你至多计算2* log2(N) 次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。 Merkle树是自底向上构建的。在如下的例子中，我们从A、B、C、D四个构成Merkle树树叶的交易开始，如图9-2。这些交易都并不存储在默克尔树中，而是将数据哈希化，然后将哈希值存储至相应的叶子节点。这些叶子节点分别是HA、HB、HC和HD： HA = SHA256(SHA256(Transaction A)) 然后，将两个哈希值连接起来再将它们哈希在一起，这样连续的叶子节点对就被归纳到父节点中。例如，要构造父节点HAB，将子节点的两个32字节哈希值连接起来，创建1个64字节字符串。然后对该字符串进行双哈希运算，生成父节点的哈希： HAB = SHA256(SHA256(HA + HB)) 这个过程一直持续到顶部只剩一个节点，即默克尔树根节点。这个32字节的哈希值存储在区块头中，归纳了所有4个交易中的所有数据。图9-2显示如何通过节点的成对哈希计算出根。 图9-2 计算默克树中的节点 因为默克尔树是一个二叉树，所以它需要偶数个叶子节点。如果要归纳的交易数为奇数，那么就复制最后一个交易哈希，凑够偶数个叶节点，这称为平衡树 balanced tree。图9-3中交易C就被复制了。 图9-3 复制一个数据元素，凑够偶数个数据元素 同样的，从4个交易构造树的方法可以推广到构造任意大小的树。在比特币中，一个区块中有几百到一千多个交易是很常见的，这些交易的归纳方式完全相同，最后只产生1个32字节的数据作为唯一的默克尔树根。在图9-4中，将会看到一个由16个交易组成的树。注意，尽管图中根节点外观看起来比叶节点大，但它的大小完全相同，只有32个字节。无论区块中有一个交易还是十万个交易，默克尔树根总是将它们归纳为32字节。 为了证明一个区块中包含了一个特定的交易，节点只需要进行log2(N)次32字节的哈希计算，就构成了一个连接特定交易到树根的认证路径authentication path或默克尔树路径merkle path。随着交易数量的增加，这一点尤其重要，因为交易数量的以2为底的对数增长要慢得多。这使得比特币节点能够高效地生成10或12个哈希值（320–384字节）的路径，这些哈希值可以在1M字节大小的区块包括的1000多个交易中，提供某一个交易的存在证明。 图9-4 归纳许多数据元素的默克尔树 在下面的图9-5中，节点可以通过生成一个只有4个32字节哈希值（总共128字节）的默克尔树路径来证明交易K包含在该区块中。这条路经包括了4个哈希值（图9-5中的阴影背景部分）：HL, HIJ, HMNOP, and HABCDEF。通过把这4个哈希值作为认证路径，任何节点都可以通过计算另外四个成对哈希值HKL、HIJKL、HIJKLMNOP和默克尔树根（在图中用虚线勾勒）来证明HK（在图的底部黑色背景）包含在默克尔树根中。 图9-5 用于证明包含数据元素的默克尔树路径 下面例9-1中的代码演示如何使用libbitcoin库的辅助函数，创建从叶节点哈希到根节点的默克尔树。 例9-1 创建默克尔树 link:code/merkle.cpp[] 例9-2显示编译和运行上面代码的结果。 例9-2 编译和运行默克尔树示例代码 $ # Compile the merkle.cpp code $ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the merkle executable $ ./merkle Current merkle hash list: 32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d27006 30861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4 Current merkle hash list: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3 Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3 随着规模的增大，默克尔树的效率变得更为明显。表9-3显示用作默克尔树路径交换，证明交易属于区块的数据量。 表9-3 默克尔树效率 Number of transactions Approx. size of block Path size(hashes) Path size (bytes) 16 transactions 4 kilobytes 4 hashes 128 bytes 512 transactions 128 kilobytes 9 hashes 288 bytes 2048 transactions 512 kilobytes 11 hashes 352 bytes 65,535 transactions 16 megabytes 16 hashes 512 bytes 从表中可以看到，虽然区块大小快速增加，从4 KB（包含16个交易）增加到16 MB（容纳65535个交易），但证明包含一个交易所需的默克尔树路径增长就慢得多，仅仅从128字节增加到512字节。使用默克尔树，节点可以只下载区块头（每个区块只有80字节），并且仍然能够通过从全节点检索一个很小的默克尔树路径来识别区块中包含的交易，而无需存储或传输大部分区块链（可能是几GB的大小）。不维护完整区块链的节点称为简单支付验证（SPV）节点，它们使用默克尔树路径验证交易，而无需下载完整的区块。 9.8 默克尔树和简单支付验证（SPV） 默克尔树被SPV节点广泛使用。SPV节点不保存所有交易，也没有下载完整的区块，只存有区块头。为了验证交易是否包含在区块中，而又无需下载区块中的所有交易，它们可以使用验证路径或默克尔树路径。 例如，考虑一个SPV节点，该节点感兴趣的是它的钱包中的收款地址收到的交易。SPV节点在它自己与对等节点的连接上建立一个布隆过滤器（参见[bloom_filters]），只接收与自己感兴趣地址相关的交易。当对等节点看到与布隆过滤器匹配的交易时，会使用merkleblock消息发送这个区块。merkleblock消息包含区块头以及感兴趣的交易连接到区块的默克尔树根的默克尔树路径。SPV节点可以使用这个默克尔树路径将交易连接到区块，并验证该交易是否包含在区块中。SPV节点还使用区块头将区块链接到区块链的其余部分。交易与区块、区块与区块链这两个环节结合起来，就能证明交易已经记录在区块链中。总而言之，SPV节点接收到的区块头和默克尔树路径的数据量将小于1KB，这个比完整区块（目前约为1MB）少了一千倍以上的数据量。 9.9 比特币测试区块链 你可能会惊讶地发现不止有一个比特币区块链。“主”比特币区块链，由中本聪于2009年1月3日创建，与我们在本章研究的创世区块一起被称为比特币区块链“主网mainnet”。还有其他用于测试的比特币区块链：testnet、segnet和regtest。我们逐个了解下。 9.9.1 比特币测试场景Testnet Testnet是用于测试目的的测试区块链、网络和货币的名称。Testnet是一个功能齐全的实时点对点网络，同样有钱包、测试比特币（testnet coins）、挖矿以及主网所具备的其他功能。有两个实质区别：Testnet上的币没有价值，挖矿难度也足够低，任何人都可以相对容易地挖testnet币（让它们毫无价值）。 任何打算在比特币主网上生产使用的软件开发都应该首先在Testnet上用测试币进行测试。这既保护了开发人员免受错误造成的资金损失，也保护了网络免受错误造成的意外行为。 然而，让这些币一文不值，让挖矿变得容易并不简单。尽管有开发者呼吁，一些人还是使用先进的挖矿设备（GPU和ASIC）在Testnet上进行挖矿。这增加了难度，单纯使用CPU已经没办法挖矿，最终使得难以获得测试币，人们开始重视测试币，它们不再是一文不值。因此，时不时地，Testnet必须被废弃，并从一个新的创世区块重新启动，重新设置难度。 当前的Testnet被称为Testnet3，是Testnet的第三次迭代，于2011年2月重新启动，为的是重置以前的Testnet的难度。 请记住，Testnet3是一个大型区块链，在2017年初超过20GB。计算机满负荷完全同步大约需要一天的时间。数据量虽然不如主网，但也不完全是“轻量级”的。运行Testnet节点的一个好方法是将其作为专用与此的虚拟机映像（例如VirtualBox、Docker、云服务器等）。 9.9.1.1 使用Testnet 就像大多数其他客户端软件一样，Bitcoin Core完全支持在Testnet而不只是在主网上运行。Bitcoin Core的所有功能都能在Testnet上工作，包括钱包、挖Testnet币和同步一个完整的Testnet节点。 要在Testnet而不是主网上启动Bitcoin Core，可以使用Testnet开关： $ bitcoind -testnet 在日志中，您应该看到bitcoind正在默认bitcoind目录的Testnet3子目录中构建新的区块链： bitcoind: Using data directory /home/username/.bitcoin/testnet3 要连接到bitcoind，可以使用bitcoin-cli命令行工具，但还必须将其切换到Testnet模式： $ bitcoin-cli -testnet getblockchaininfo { \"chain\": \"test\", \"blocks\": 1088, \"headers\": 139999, \"bestblockhash\": \"0000000063d29909d475a1c4ba26da64b368e56cce5d925097bf3a2084370128\", \"difficulty\": 1, \"mediantime\": 1337966158, \"verificationprogress\": 0.001644065914099759, \"chainwork\": \"0000000000000000000000000000000000000000000000000000044104410441\", \"pruned\": false, \"softforks\": [ [...] 还可以在Testnet3上运行其他全节点实现，例如btcd（用Go编写d的）和bcoin（用JavaScript编写的），使用其他编程语言和框架进行实验和学习。 在2017年初Ttestnet3支持主网的所有特性，包括隔离见证（参见【7.8 隔离见证】）。因此，Testnet3也可以用于测试隔离见证功能。 9.9.2 Segnet:隔离见证测试网 2016年，启动了一个专用测试网，主要用于帮助开发和测试隔离见证（又名segwit，参见【7.8 隔离见证】）。这个测试区块链称为segnet，可以通过运行特殊版本（分支）的Bitcoin Core与它连接。 由于隔离见证被添加到testnet3中，因此不再需要使用segnet来测试隔离见证的功能。 将来，就像segnet一样，我们可能会看到其他专门设计用于测试单个功能或主要架构更改的测试网区块链。 9.9.3 Regtest：本地区块链 Regtest代表“回退测试”，是Bitcoin Core的功能，允许创建用于测试的本地区块链。与Testnet3不同，Testnet3是一个公开和共享的测试区块链，Regtest区块链是运行在本地的封闭的测试系统。你可以使用它从头开始启Rregtest区块链，创建本地创世区块。还可以将其他节点添加到网络中，或者只使用单个节点运行它，测试Bitcoin Core软件。 要在Regtest模式下启动Bitcoin Core，使用regtest标记： $ bitcoind -regtest 与Testnet一样，Bitcoin Core将在比特币默认目录的regtest子目录下初始化一个新的区块链： bitcoind: Using data directory /home/username/.bitcoin/regtest 使用命令行工具时，还需要指定regtest标记。下面尝试getblockchaininfo命令来检查regtest区块链： $ bitcoin-cli -regtest getblockchaininfo { \"chain\": \"regtest\", \"blocks\": 0, \"headers\": 0, \"bestblockhash\": \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\", \"difficulty\": 4.656542373906925e-10, \"mediantime\": 1296688602, \"verificationprogress\": 1, \"chainwork\": \"0000000000000000000000000000000000000000000000000000000000000002\", \"pruned\": false, [...] 就像你看到的，这里还没有区块。可以挖矿一些区块（500个区块）并获得奖励： $ bitcoin-cli -regtest generate 500 [ \"7afed70259f22c2bf11e406cb12ed5c0657b6e16a6477a9f8b28e2046b5ba1ca\", \"1aca2f154a80a9863a9aac4c72047a6d3f385c4eec5441a4aafa6acaa1dada14\", \"4334ecf6fb022f30fbd764c3ee778fabbd53b4a4d1950eae8a91f1f5158ed2d1\", \"5f951d34065efeaf64e54e91d00b260294fcdfc7f05dbb5599aec84b957a7766\", \"43744b5e77c1dfece9d05ab5f0e6796ebe627303163547e69e27f55d0f2b9353\", [...] \"6c31585a48d4fc2b3fd25521f4515b18aefb59d0def82bd9c2185c4ecb754327\" ] 只需几秒钟就可以挖出所有这些区块，这无疑使测试变得容易。如果查看钱包余额，会看到在前400个区块中获得了奖励（创币交易的奖励必须是区块深度达到100个区块才能使用）： $ bitcoin-cli -regtest getbalance 12462.50000000 9.10 使用测试区块链进行开发 比特币的各种区块链（Regtest、segnet、Testnet3、主网）为比特币开发提供了一系列测试环境。无论是针对 Bitcoin Core开发，还是另一个全节点共识客户端，都可以使用测试区块链。可以是应用程序，如钱包、交易所、电子商务网站，甚至是开发最新的智能合约和复杂脚本。 可以使用测试区块链建立开发管道。开发时，可以在Regtest上本地测试代码。一旦具备在公网上进行尝试，可切换到Testnet，将代码公开到一个具有代码和应用程序多样性的动态环境中。最后，确信代码能够按预期工作，就可以切换到主网部署到生产环境中。如果要进行更改、改进、修复错误等，可以再次启动管道，还是先在Regtest上部署每个更改，然后在Testnet上测试，最后部署到生产环境中。 "},"ch10.html":{"url":"ch10.html","title":"第十章 挖矿和共识","keywords":"","body":"第10章 挖矿和共识 10.1 简介 “挖矿”这个词有点误导。一般意义的挖矿类似贵金属的提炼，于是人们将更多的注意力集中到挖矿的回报，也就是每个区块创造的新比特币。虽然挖矿行为会被这种奖励所激励，但挖矿的主要目的不是这个奖励或者产生新币。如果你只把挖矿看作是创比特币的过程，那么你就会误把这个过程中的手段（作为激励）作为目标。挖矿是一种去中心化的交易清算机制，通过这种机制，交易得到验证和清算。挖矿是使得比特币与众不同的发明，是一种去中心化的安全机制，是点对点数字现金的基础。 挖矿确保了比特币系统安全，并且在全网范围实现了没有中央权威机构的共识。挖出新币以及交易费的奖励是一种激励机制，它将矿工的行为与网络的安全性结合起来，同时实施货币供应。 提示：挖矿的目的不是创造新的比特币。这是激励机制。 挖矿是一种使比特币的安全security去中心化decentralized的机制。 矿工验证新交易并将其记录在全球分类账簿上。每10分钟就会有一个新的区块被“挖掘”出来，这个新区块里包含着从上一个区块产生到目前这段时间内发生的交易，这样这些交易就被添加到区块链中了。我们把包含在区块内且被添加到区块链上的交易称为“已确认confirmed”交易，交易经过“确认”之后，新的拥有者才能够花费他在交易中收到的比特币。 矿工们在挖矿过程中会得到两种类型的奖励：创建新区块的新币奖励，以及区块中所含交易的交易费。为了得到这些奖励，矿工们争相完成一种基于加密哈希算法的数学难题，这些难题的解决方案，称为“工作量证明”，包括在新区块中，作为矿工花费大量计算工作的证明。解决工作证明算法在区块链上获得奖励的竞争以及获胜者有权在区块链上记录交易，这二者是比特币安全模型的基石。 这个过程被称为挖矿，是因为奖励机制（新比特币产生）被设计为模拟收益递减模式，类似于贵重金属的挖矿过程。比特币的货币是通过挖矿发行的，类似于央行通过印刷钞票来发行货币。矿工通过创造一个新区块得到的比特币数量大约每四年（或准确说是每210,000个区块）减少一半。开始时为2009年1月每个区块奖励50个比特币，然后到2012年11月减半为每个区块奖励25个比特币。之后在2016年7月减半为每个新区块奖励12.5个比特币。2020年5月，再次减半为5比特币。基于这个公式，比特币挖矿奖励以指数方式递减，直到2140年。届时所有的比特币（20,999,999,980）全部发行完毕。换句话说在2140年之后，不会再有新的比特币产生。 矿工们同时也会获取交易费。每笔交易都可能包含一笔交易费，交易费是每笔交易记录的输入和输出的差额。在挖矿过程中成功“挖出”新区块的矿工可以得到该区块中包含的所有交易“小费”。目前，这笔费用占矿工收入的0.5%或更少，大部分收益仍来自挖矿所得的新比特币奖励。然而随着挖矿奖励的递减，以及每个区块中包含的交易数量增加，交易费在矿工收益中所占的比重将会逐渐增加。在2140年之后，所有的矿工收益都将由交易费构成。 在本章中，我们先来审视比特币的货币发行机制，然后再来了解挖矿的最重要的功能：支撑比特币安全的去中心化的共识机制。 为了了解挖矿和共识，我们将跟随Alice的交易，是如何被矿工Jing的挖矿设备接收并被添加到区块中的。 然后，我们将继续跟踪区块被挖矿，加入区块链，并通过自发共识被比特币网络接受。 10.1.1 比特币经济学和货币创造 比特币是在每一个区块的创建过程中以固定和递减的速度被“铸造出来”的。大约每十分钟产生一个新区块，每一个新区块都伴随着一定数量的全新比特币，它是从无到有的。每开采210,000个区块，或者大约每4年，货币发行速率降低50%。在比特币运行的第一个四年中，每个区块创造出50个新比特币。 2012年11月，比特币的新发行速度降低到每区块25个比特币。2016年7月，降低到12.5比特币/区块。2020年5月，也就是在区块630,000，减半再次发生，下降至每个区块6.25比特币。新币的发行速度会以指数级进行32次“等分”，直到第6,720,000块（大约会在2137年挖出），达到比特币的最小货币单位1聪。最终，在经过693万个区块之后，所有的共 2,099,999,997,690,000聪，或者说接近 2,100万比特币将全部发行完毕。在那之后，新的区块不再包含比特币奖励，矿工的收益全部来自交易费。图10-1展示了在发行速度不断降低的情况下，比特币总流通量与时间的关系。 图10-1 基于发行率几何下降的比特币供应量和时间的关系 注意：比特币挖矿发行的最大数量也就成为挖矿奖励的上限。 在实践中，矿工可能故意挖那些低于全额奖励的区块。已经有这些区块被挖出来了，未来就会有更多被开采，这样导致货币发行总量的下降。 在例10-1的代码中，我们计算了比特币的总发行量 例10-1 比特币发行总量的计算脚本 # Original block reward for miners was 50 BTC = 50 0000 0000 Satoshis start_block_reward = 50 * 10**8 # 210000 is around every 4 years with a 10 minute block interval reward_interval = 210000 def max_money(): current_reward = start_block_reward total = 0 while current_reward > 0: total += reward_interval * current_reward current_reward /= 2 return total print(\"Total BTC to ever be created:\", max_money(), \"Satoshis\") 例10-2显示了运行脚本的输出结果 例10-2 运行上述脚本的输出结果 $ python max_money.py Total BTC to ever be created: 2099999997690000 Satoshis 总量有限并且发行量递减创造了一个固定的货币供应量来抵御通货膨胀。法币可被央行无限制地印刷出来，而比特币却永远不会因超额印发而出现通胀。 通货紧缩 发行总量固定并且递减的最重要和有争议的后果是，货币往往会趋向于内在通货紧缩性deflationary。通缩是一种由于货币的供应和需求不匹配导致的货币价值（和汇率）上涨的现象。与通货膨胀相反，价格通缩意味着随着时间的推移，货币拥有更多的购买力。 许多经济学家认为，通缩经济是一场灾难，应该不惜一切代价避免。这是因为在快速通货紧缩时期，人们预期商品价格会下跌，倾向于囤积货币而不是消费。这种现象在日本“失落的十年”期间出现，需求崩溃将日元推入通缩漩涡。 比特币专家们认为通缩本身并不坏。相反，通货紧缩与需求崩溃联系在一起，因为这是我们必须研究的通货紧缩的唯一例子。对于存在无限印刷可能的法定货币，除非需求完全崩溃，不愿意印刷货币，否则很难进入通缩漩涡。比特币的通缩不是由需求崩溃造成的，而是由可预见的供应受限造成的。 当然，通货紧缩的积极方面是，它与通货膨胀相反。通货膨胀导致货币的缓慢但不可避免的贬值，造成了一种隐藏的税收形式，惩罚储蓄者，解救了债务人（包括政府这个最大的债务人）。政府控制下的货币遭受轻易发债的道德风险，这种风险后来可能会以牺牲储蓄者为代价，通过贬值来抹去债务。 货币的通缩，如果不是由经济快速收缩所推动，那么这是一个问题，还是一个优势，仍有待观察，因为防止通胀和贬值远远大于通缩带来的风险。 10.2 去中心化共识 在上一章中我们研究了区块链，即所有交易的全球公共分类账（列表），比特币网络中的每个人都接受它，把它作为所有权的权威记录。 但在不考虑相信任何人的情况下，网络中的所有人如何就谁拥有什么这一普遍的“真相”达成一致呢？所有传统的支付系统都依赖于一个信任模型，该模型由一个中央机构提供清算服务，验证和清算所有交易。比特币没有中央权威机构，但是所有的全节点都有一份完整的公共账本副本，可以作为权威记录来信任。区块链不是由中央机构创建的，而是由网络中的每个节点独立组装的。网络中的所有节点，依靠着节点间的不安全的网络连接所传输的信息，最终得出同样的结果并共同维护了同一个公共总帐。本章探讨比特币网络在没有中央权威的情况下达成全球共识的过程。 中本聪的主要发明就是这种去中心化的自发共识emergent consensus机制。自发，是指共识没有明确的完成点，没有选举和共识达成的固定时刻。换句话说，共识是数以千计的独立节点遵守了简单的规则通过异步交互自发形成的产物。所有的比特币属性，包括货币、交易、支付以及不依靠中心机构和信任的安全模型等都依赖于这个发明。 比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生： 每个全节点依据一个详尽的标准列表对每个交易进行独立验证 挖矿节点将交易记录独立打包进新区块，通过工作证明算法进行证明计算 每个节点独立的对新区块进行校验并组装进区块链 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链 在接下来的几节中，我们将研究这些过程，了解它们之间如何相互作用并达成全网的自发共识，从而使任意节点组合出它自己的权威、可信、公开的全局总帐副本。 10.3 交易的独立验证 在【第6章交易】中，我们知道了钱包软件通过收集UTXO、提供正确的解锁脚本、构造一个给新所有者的新输出来创建交易。产生的交易随后将被发送到比特币网络临近的节点，从而使得该交易能够在整个比特币网络中传播。 然而，在交易传递到临近的节点前，每一个收到交易的比特币节点都会首先验证该交易，这将确保只有有效的交易才会在网络中传播，而无效的交易将会被遇到的第一个节点废弃掉。 每一个节点在校验每一笔交易时，都需要对照一个长长的标准列表： ▷交易的语法和数据结构必须正确。 ▷输入与输出列表都不能为空。 ▷交易的字节数小于 MAX_BLOCK_SIZE 。 ▷每一个输出值，以及总量，必须在规定值的范围内 （小于2,100万个币，大于dust参数设置的阈值）。 ▷没有哈希等于0，N等于-1的输入（创币交易不应当被传播）。 ▷nLockTime等于 INT_MAX ，或者是根据MedianTimePast要求满足nLocktime和nSequence的值 ▷交易的大小是大于或等于100字节的。 ▷交易中的签名数量(SIGOPS)应小于签名操作数量上限（sigoplimit）。 ▷解锁脚本（scriptSig）只能够将数字压入栈中，并且锁定脚本（ scriptPubkey ）必须要符合isStandard的格式（该格式将会拒绝非标准交易）。 ▷匹配的交易必须存在于交易池或主分支区块中。 ▷对于每一个输入，如果引用的输出存在于交易池中任何别的交易中，该交易将被拒绝。 ▷对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果任何输入缺少输出交易，该交易将成为一个孤儿交易。如果与其匹配的交易还没有出现在池中，那么将被加入到孤儿交易池中。 ▷对于每一个输入，如果引用的输出交易是一个创币交易的输出，该输入必须至少获得COINBASE_MATURITY(100)个确认。 ▷对于每一个输入，引用的输出必须存在并且是未被使用的。 ▷使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内 （小于2100万个币，大于0）。 ▷如果输入值的总和小于输出值的总和，交易将被拒绝。 ▷如果交易费用太低(minRelayTxFee) 以至于无法进入一个空的区块，交易将被拒绝。 ▷每一个输入的解锁脚本必须依据相应的输出锁定脚本来验证。 这些条件可以在Bitcoin Cor客户端下的 AcceptToMemoryPool 、 CheckTransaction 和 CheckInputs 函数中获得更详细的阐述。 请注意，这些条件会随着时间发生变化，为了处理新型拒绝服务攻击，有时候也为交易类型多样化而放宽规则。 在收到交易后，每一个节点都会在全网广播前对这些交易进行独立校验，并以接收时的相应顺序，为有效的新交易建立一个有效交易池（还未确认），这个池可以叫做交易池，或者内存池或者mempool。 10.4 挖矿节点 在比特币网络中，有一些节点是专业节点称为“矿工”。在【第1章比特币介绍】中，我们介绍了Jing，在中国上海的计算机工程专业学生，他就是一位矿工。Jing通过矿机挖矿获得比特币，矿机是专门设计用于挖比特币的计算机硬件系统。Jing的这台专业挖矿设备连接着一个全节点的服务器。与Jing不同，有一些矿工挖矿没有全节点，正如我们在【10.11.2矿池】中所述的。与其他全节点相同，Jing的节点在比特币网络中接收和传播未确认交易。然而，Jing的节点也能够把这些交易打包进入一个新区块。 同其他节点一样，Jing的节点时刻监听着传播到比特币网络的新区块。而这些新加入的区块对挖矿节点有着特殊的意义。矿工间的竞争以新区块的传播而结束，如同宣布谁是最后的赢家。对于矿工们来说，收到一个有效的新区块意味着别人已经赢了，而自己则输掉了这场竞赛。然而，一轮竞赛的结束也代表着下一轮竞赛的开始。新区块并不仅仅是象征着竞赛结束的方格旗；它也是下一个区块竞赛的发令枪。 10.5 打包交易至区块 验证交易后，比特币节点会将这些交易添加到自己的内存池，也称作交易池中，在该池中，交易将一直等待，直到它们被包含（挖矿）到区块中。与其他节点一样，Jing的节点会收集、验证并传播新的交易。而与其他节点不同的是，Jing的节点会把这些交易整合到一个候选区块中。 让我们继续跟随Alice从Bob咖啡店购买咖啡时产生的那个区块（参见【2.1.2买一杯咖啡】）。Alice的交易在区块 277,316。为了演示本章中提到的概念，我们假设这个区块是由Jing的挖矿系统挖出的，并且在这个交易成为了新区块的一部分后继续跟进Alice的交易。 Jing的挖矿节点维护了一个区块链的本地副本。当Alice买咖啡的时候，Jing节点的区块链已经收集到了区块277,314，并继续监听着网络上的交易，在尝试挖掘新区块的同时，也监听着其他节点发现的区块。当Jing的节点在挖矿时，它从比特币网络收到了区块277,315。这个区块的到来标志着终结了产出区块277,315的竞赛，与此同时也是创造区块277,316竞赛的开始。 在上一个10分钟内，当Jing的节点正在寻找区块277,315的解的同时，它也在收集交易为下一个区块做准备。现在它已经在内存池中收集了几百笔交易。在接收到区块277,315并验证它之后，Jing的节点还会把它与内存池中的所有交易进行比较，并删除区块277315中已经包含的任何交易。内存池中保留的任何交易都是未经确认的，正在等待记录到新区块中。 Jing的节点立刻构建一个新的空区块，做为区块277,316的候选区块。称作候选区块是因为它还没有包含有效的工作量证明，不是一个有效的区块，而只有在矿工成功找到一个工作量证明的解之后，这个区块才生效。 现在，Jing的节点从内存池中整合到了全部的交易，新的候选区块包含有418笔交易，总的交易费为0.09094925个比特币。你可以通过Bitcoin Core客户端命令行来查看这个区块，如例10-3所示： 例10-3 使用命令行检索区块277,316 $ bitcoin-cli getblockhash 277316 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 $ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d9\\ 44a9b31b2cc7bdc4 { \"hash\" : \"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4\", \"confirmations\" : 35561, \"size\" : 218629, \"height\" : 277316, \"version\" : 2, \"merkleroot\" : \"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e\", \"tx\" : [ \"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f\", \"b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe\", ... 417 more transactions ... ], \"time\" : 1388185914, \"nonce\" : 924591752, \"bits\" : \"1903a30c\", \"difficulty\" : 1180923195.25802612, \"chainwork\" : \"000000000000000000000000000000000000000000000934695e92aaf53afa1a\", \"previousblockhash\" : \"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569\" } 10.5.1 创币交易 区块中的第一笔交易是笔特殊交易，称为创币交易coinbase transaction。这个交易是由Jing的节点构造，并包含他的挖矿贡献的奖励。 注意:当区块277,316被挖出来时，每个区块的奖励是25个比特币。此后，已经过了两个“减半”时期。 2016年7月的奖励为12.5个比特币。2020年5月是6.25比特币。 Jing的节点会创建“向Jing的地址支付25.09094928个比特币”这样一个交易，支付到自己的钱包。Jing挖出区块获得的奖励总额是创币奖励（25个新比特币）和区块中全部交易的交易费（0.09094928）的总和，如例10-4所示。 例10-4 创币交易 $ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1 { \"hex\" : \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000\", \"txid\" : \"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f\", \"version\" : 1, \"locktime\" : 0, \"vin\" : [ { \"coinbase\" : \"03443b0403858402062f503253482f\", \"sequence\" : 4294967295 } ], \"vout\" : [ { \"value\" : 25.09094928, \"n\" : 0, \"scriptPubKey\" : { \"asm\" : \"02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG\", \"hex\" : \"2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac\", \"reqSigs\" : 1, \"type\" : \"pubkey\", \"addresses\" : [ \"1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N\" ] } } ] } 与常规交易不同，创币交易不消耗作为输入的UTXO。相反它只包含一个被称作coinbase的输入，从零开始创建比特币。创币交易有一个输出，支付到这个矿工的比特币地址。创币交易的输出将这25.09094928个比特币发送到矿工的比特币地址，如本例所示的1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N。 10.5.2 创币奖励与矿工费 为了构造创币交易，Jing的节点需要计算矿工费的总额，将这418个已添加到区块交易的输入和输出分别进行求和，然后用输入总额减去输出总额得到矿工费总额，公式如下： Total Fees = Sum(Inputs) - Sum(Outputs) 在区块277,316中，矿工费的总额是0.09094925个比特币。 紧接着，Jing的节点计算出这个新区块正确的奖励额。奖励额的计算是基于区块高度的，以每个区块50个比特币为开始，每产生210,000个区块减半一次。这个区块高度是277,316，所以正确的奖励额是25个比特币。 详细的计算过程可以参看Bitcoin Core客户端中的GetBlockValue函数，如例10-5所示： 例10-5 计算区块奖励—函数GetBlockValue, Bitcoin Core客户端, main.cpp CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams) { int halvings = nHeight / consensusParams.nSubsidyHalvingInterval; // Force block reward to zero when right shift is undefined. if (halvings >= 64) return 0; CAmount nSubsidy = 50 * COIN; // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years. nSubsidy >>= halvings; return nSubsidy; } 最初的奖励是用“聪satoshis”计算的，用50乘以 COIN 常量（100,000,000聪)，也就是说初始奖励额（nSubsidy）为50亿聪。 紧接着，这个函数用当前区块高度除以减半间隔(SubsidyHalvingInterval 函数)得到已减半次数。每210,000个区块为一个减半间隔，对应本例中的区块27,7316，所以减半次数为1。 变量halvings最大值64，如果超出这个值，则代码只提供零奖励（仅返回交易费）。 然后，接下来，该函数使用二进制右移运算符将每一轮减半的奖励（nSubsidy）除以2。在这个例子中，对于区块277,316，就是将值为50亿聪的奖励额右移一次（减半），得到25亿聪，也就是25个比特币的奖励额。之所以采用二进制右移操作，是因为相比于整数或浮点数除法，右移操作的效率更高。为了避免潜在的错误，在63次减半后右移操作就被跳过，并将奖励设置为0。 最后，将创币奖励额（nSubsidy ）与矿工费(nFee)总额求和，返回这个值。 注意: 如果Jing的挖矿节点把创币交易写入区块，那么如何防止Jing奖励自己100甚至1000比特币？ 答案是，不正确的奖励将被其他人视为无效，也就浪费了Jing用于工作证明的投入。只有这个区块被大家认可，Jing才能使用奖励。 10.5.3 创币交易的结构 经过计算，Jing的节点构造了一个创币交易，支付给自己25.09094928个比特币。 例10-4所示，创币交易的结构比较特殊，与交易输入需要指定一个先前的UTXO不同，它包含一个“coinbase“输入。在【6.3.2.1交易序列化--交易输入中的表6-2】中，我们已经研究了交易输入。现在让我们来比较一下常规交易输入与创币交易输入。表10-1给出了常规交易输入的结构，表10-2给出的是创币交易输入的结构。 表10-1 常规交易输入结构 Size Field Description 32 bytes Transaction Hash Pointer to the transaction containing the UTXO to be spent 4 bytes Output Index The index number of the UTXO to be spent, first one is 0 1–9 bytes (VarInt) Unlocking-Script Size Unlocking-Script length in bytes, to follow Variable Unlocking-Script A script that fulfills the conditions of the UTXO locking script 4 bytes Sequence Number Usually set to 0xFFFFFFFF to opt out of BIP 125 and BIP 68 表10-2 创币交易输入结构 Size Field Description 32 bytes Transaction Hash All bits are zero: Not a transaction hash reference 4 bytes Output Index All bits are ones: 0xFFFFFFFF 1–9 bytes (VarInt) Coinbase Data Size Length of the coinbase data, from 2 to 100 bytes Variable Coinbase Data Arbitrary data used for extra nonce and mining tags. In v2 blocks; must begin with block height 4 bytes Sequence Number Set to 0xFFFFFFFF 在创币交易中，前两个字段设定的值表示不引用UTXO。相反，“Transaction Hash”字段32个字节全部填充0，“Output Index”字段全部填充0xFF(十进制为255)。“解锁脚本”由“Coinbase Data”代替，该字段被矿工使用，接下来会看到。 10.5.4 Coinbase data 创币交易不包含“解锁脚本“(又称作 scriptSig)字段，这个字段被coinbase data字段替代，长度最小2字节，最大100字节。除了开始的几个字节外，矿工可以任意使用coinbase data的其他部分，可以填充任何数据。 以创世区块为例，中本聪在coinbase data中填入了这样的数据“The Times 03/Jan/ 2009 Chancellor on brink of second bailout for banks“(泰晤士报 2009年1月3日 财政大臣将再次对银行施以援手)，作为日期的证明，同时也传递了信息。现在，矿工使用coinbase data实现额外的nonce值，以及标识挖出区块的矿池的字符串。 coinbase前几个字节也曾是可以任意填写的，不过在后来的BIP34中规定了版本2的区块（版本字段设置为2的区块），必须包含其区块高度索引，在coinbase字段开头满足脚本“push”操作。 我们以例10-4中的区块277,316为例，coinbase就是交易输入的“解锁脚本“（或scriptSig）字段，其中包含十六进制值为03443b0403858402062f503253482f。下面让我们来解码这段数据。 第一个字节03指示脚本执行引擎将接下来的三个字节推送到脚本堆栈上（参见【附录2、交易脚本语言操作符，常量和符号中表一内容】）。紧接着的3个字节是0x443b04，是以小端格式(最低有效字节在先)编码的区块高度。翻转字节序得到0x043b44，表示为十进制是277,316。 紧接着的几个十六进制数（03858402062）用于编码额外随机数nonce(参见【10.11.1 额外随机数解决方案】)，或者一个随机值，从而求解工作量证明。 coinbase data结尾部分(2f503253482f)是ASCII编码字符/P2SH/，表示挖出这个区块的挖矿节点支持BIP-16所定义的pay-to-script-hash(P2SH)改进方案。在P2SH功能引入到比特币的时候，要求矿工发出信号，支持BIP-16还是BIP-17。支持BIP-16的矿工将/P2SH/放入coinbase data中，支持BIP-17的矿工将p2sh/CHV放入coinbase data中。最后，BIP-16在选举中胜出，很多矿工继续在他们的coinbase中填写/P2SH/以表示支持这个功能。 例10-6使用了libbitcoin库（参见【3.5 其他可选的客户端、库、工具包】）,从创世区块中提取coinbase data，并显示出中本聪留下的信息。注意libbitcoin库中包含了一份创世块的静态副本，所以这段示例代码可以直接检索库中的创世区块数据。 例10-6 从创世区块中提取coinbase data /* Display the genesis block message by Satoshi. */ #include #include int main() { // Create genesis block. bc::chain::block block = bc::chain::block::genesis_mainnet(); // Genesis block contains a single coinbase transaction. assert(block.transactions().size() == 1); // Get first transaction in block (coinbase). const bc::chain::transaction& coinbase_tx = block.transactions()[0]; // Coinbase tx has a single input. assert(coinbase_tx.inputs().size() == 1); const bc::chain::input& coinbase_input = coinbase_tx.inputs()[0]; // Convert the input script to its raw format. const auto prefix = false; const bc::data_chunk& raw_message = coinbase_input.script().to_data(prefix); // Convert this to a std::string. std::string message(raw_message.begin(), raw_message.end()); // Display the genesis block message. std::cout 例10-7中，我们使用GNU C++编译器编译源代码并运行得到的可执行文件。 例10-7 编译并运行satoshi-words示例代码 $ # Compile the code $ g++ -o satoshi-words satoshi-words.cpp $(pkg-config --cflags --libs libbitcoin) $ # Run the executable $ ./satoshi-words ^D��^A^DEThe Times 03/Jan/2009 Chancellor on brink of second bailout for banks 10.6 构造区块头 为了构造区块头，挖矿节点需要填充六个字段，如表10-3中所示。 表10-3 区块头结构 Size Field Description 4 bytes Version A version number to track software/protocol upgrades 32 bytes Previous Block Hash A reference to the hash of the previous (parent) block in the chain 32 bytes Merkle Root A hash of the root of the merkle tree of this block’s transactions 4 bytes Timestamp The approximate creation time of this block (seconds from Unix Epoch) 4 bytes Target The Proof-of-Work algorithm target for this block 4 bytes Nonce A counter used for the Proof-of-Work algorithm 在区块277,316被挖出的时候，区块结构中用来表示Version的字段值为2，长度为4字节，以小端格式编码值为 0x20000000。 接着，挖矿节点需要填充“Previous Block Hash”，在本例中，这个值为Jing的节点从网络上接收到的区块277,315的区块头哈希值，它是区块277,316候选区块的父区块。区块277,315的区块头哈希值为： 0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569 提示：通过选择候选区块头中的Previous Block Hash字段指定的特定父区块，Jing正在将挖矿能力用于将这个特定区块附加到尾部来扩展区块链。从本质上讲，这就是用他的挖矿权为最长难度的有效链进行的“投票”。 下一步是使用默克尔树归纳所有交易，以便将默克尔树根添加到区块头。创币交易是区块中的第一个交易。然后，在它之后再添加418个交易，在区块中总共添加了419个交易。在【9.7 默克尔树】，我们已经了解，树中必须有偶数个叶子节点，所以需要复制最后一个交易作为第420个叶子节点，每个叶子节点是对应交易的哈希值。这些交易的哈希值成对地组合，再创建每一层树，直到最终组合并成一个根节点。默克尔树根节点将全部交易数据归纳为一个32字节长度的值，例10-3中默克尔树根的值如下： c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e 然后，JING的挖矿节点会继续添加一个4字节的时间戳，以Unix纪元时间编码，即自UTC时间1970年1月1日周四午夜0点以来总共经历的秒数。本例中的1388185914对应的时间是UTC时间2013年12月27日23:11:54，星期五。 接下来，Jing的节点需要填充Target字段（难度目标值），这个字段定义了使该区块有效所需满足的工作量证明。难度目标作为“目标位target bits”度量存储在区块中，该度量以“尾数-指数”格式编码。这种编码用1个字节表示指数，后面的3字节表示尾数(系数)。例如区块277316，难度位的值为0x1903a30c，0x19是指数的十六进制格式，后半部0x03a30c是系数。这部分的概念在后面的【10.7.3 难度目标与难度调整】和【10.7.2 难度表示】有详细的解释。 最后一个字段是随机数nonce，初始值为0。 在所有字段都已填充的情况下，区块头现在已完成，可以开始挖矿过程。挖矿的目标是找到一个使区块头哈希值小于难度目标的随机数nonce。挖矿节点通常需要尝试数十亿甚至数万亿个不同的随机数取值，直到找到一个满足条件的值。 10.7 构建区块 Jing的节点已经构建了一个候选区块，接下来就该Jing的矿机“挖掘”这个新区块，找到一个使该区块有效的工作证明算法的解决方案。从本书中我们已经学习了加密哈希函数可以用在比特币系统的不同方面。比特币挖矿过程使用的是SHA256哈希函数。 用最简单的术语来说，挖矿就是对区块头重复哈希计算，然后不断修改一个参数，直到得到的哈希值与难度目标相匹配的过程。哈希函数的结果不能预先确定，也不能创建生成特定哈希值的模式。哈希函数的这个特性意味着：找到匹配特定难度目标的最终哈希值的唯一方法就是不断的尝试，每次随机修改输入，直到偶然出现所需的哈希值。 10.7.1 工作量证明算法 哈希算法就是输入一个任意长度的数据，输出一个固定长度的确定性值，称之为输入的数字指纹。对于特定输入，结果哈希值每次都一样，任何人都可以用相同的哈希算法，很容易地计算和验证。加密哈希函数的主要特征就是在计算上不可能找到产生相同指纹的两个不同输入（称为碰撞）。因此，除了尝试随机输入之外，不可能选择特定输入产生期望的指纹。 无论输入的大小是多少，SHA256函数的输出的长度总是256bit。在例10-8中，我们将使用Python解释器来计算语句 \"I am Satoshi Nakamoto\" 的SHA256的哈希值。 例10-8 SHA256示例 $ python Python 2.7.1 >>> import hashlib >>> print hashlib.sha256(\"I am Satoshi Nakamoto\").hexdigest() 5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e 在例10-8中， 5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e 是\"I am Satoshi Nakamoto\"的哈希值。这个256位数字是这句短语的哈希或摘要，与短语的每一部分相关。改变原句中的任何一个字母、标点、或增加字母都会产生不同的哈希值。 如果我们改变原句，得到的应该是完全不同的哈希值。 例如，我们在句子末尾加上一个数字，运行例10-9中的简单Python脚本。 例10-9 通过反复修改 nonce 来生成不同哈希值的脚本（SHA256） # example of iterating a nonce in a hashing algorithm's input from __future__ import print_function import hashlib text = \"I am Satoshi Nakamoto\" # iterate nonce from 0 to 19 for nonce in range(20): # add the nonce to the end of the text input_data = text + str(nonce) # calculate the SHA-256 hash of the input (text+nonce) hash_data = hashlib.sha256(input_data.encode()).hexdigest() # show the input and hash result print(input_data, '=>', hash_data) 执行这个脚本就能生成末尾数字不同的语句的哈希值。例10-10 中显示了我们只是增加了这个数字，却得到了完全不同的哈希值。 例10-10 上面例10-9脚本的输出 $ python hash_example.py I am Satoshi Nakamoto0 => a80a81401765c8eddee25df36728d732... I am Satoshi Nakamoto1 => f7bc9a6304a4647bb41241a677b5345f... I am Satoshi Nakamoto2 => ea758a8134b115298a1583ffb80ae629... I am Satoshi Nakamoto3 => bfa9779618ff072c903d773de30c99bd... I am Satoshi Nakamoto4 => bce8564de9a83c18c31944a66bde992f... I am Satoshi Nakamoto5 => eb362c3cf3479be0a97a20163589038e... I am Satoshi Nakamoto6 => 4a2fd48e3be420d0d28e202360cfbaba... I am Satoshi Nakamoto7 => 790b5a1349a5f2b909bf74d0d166b17a... I am Satoshi Nakamoto8 => 702c45e5b15aa54b625d68dd947f1597... I am Satoshi Nakamoto9 => 7007cf7dd40f5e933cd89fff5b791ff0... I am Satoshi Nakamoto10 => c2f38c81992f4614206a21537bd634a... I am Satoshi Nakamoto11 => 7045da6ed8a914690f087690e1e8d66... I am Satoshi Nakamoto12 => 60f01db30c1a0d4cbce2b4b22e88b9b... I am Satoshi Nakamoto13 => 0ebc56d59a34f5082aaef3d66b37a66... I am Satoshi Nakamoto14 => 27ead1ca85da66981fd9da01a8c6816... I am Satoshi Nakamoto15 => 394809fb809c5f83ce97ab554a2812c... I am Satoshi Nakamoto16 => 8fa4992219df33f50834465d3047429... I am Satoshi Nakamoto17 => dca9b8b4f8d8e1521fa4eaa46f4f0cd... I am Satoshi Nakamoto18 => 9989a401b2a3a318b01e9ca9a22b0f3... I am Satoshi Nakamoto19 => cda56022ecb5b67b2bc93a2d764e75f... 每个语句都生成了一个完全不同的哈希值。它们看起来是完全随机的，但你在任何计算机上用Python执行上面的脚本都能重现这些完全相同的哈希值。 上述场景中在语句末尾的变化的数字叫做随机数nonce。随机数是用来改变加密函数输出的，在这个示例中用于改变这个语句的 SHA256指纹。 为了使这个哈希算法变得富有挑战，我们来设定一个目标：找到一个语句，生成的16进制哈希值第一位是0。幸运的是，这很容易！在例10-10中语句 \"I am Satoshi Nakamoto13\" 的哈希值是 0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5 ，刚好满足条件。我们得到它用了13次。从概率的角度来看，如果哈希函数的输出是平均分布的，我们可以期望每16次（十六进制数字从0到F）就可以得到一个以0开头的16进制哈希值。从数字的角度来看，我们要找的是小于 0x1000000000000000000000000000000000000000000000000000000000000000 的哈希值。我们称这个阈值为难度目标Target，我们的目的是找到一个小于这个难度目标的哈希值。如果我们减小这个目标值，那找到一个小于它的哈希值会越来越难。 简单打个比方，想象人们不断扔一对骰子以得到小于一个特定点数的游戏。第一局，目标是12。只要你不扔出两个6， 你就会赢。然后下一局目标为11。玩家只能扔10或更小的点数才能赢，不过也很简单。假如几局之后目标降低为了5。现在有一半机率以上扔出来的骰子点数加起来会超过5，因此无效。随着目标越来越小，要想赢的话，扔骰子的次数会指数级的上升。最终当目标为2时（最小可能点数），只有一个人平均扔36次或扔的次数中的2%，他才能赢。 从一个知道骰子游戏目标为2的观察者的角度来看，如果有人成功投了一个赢的骰子，可以假设他平均投了36次。换句话说，你可以从目标所带来的困难中估算出成功所需的工作量。当该算法基于确定函数（如SHA256）时，输入本身就构成了为产生低于难度目标值的结果而做了一定工作量的证明。因此，称之为工作量证明Proof-of-Work。 提示：尽管每次尝试产生一个随机的结果，但是任何可能的结果的概率可以预先计算。 因此，指定特定难度目标的结果构成了特定的工作量证明。 在例10-10中，成功的随机数为13，且这个结果能被所有人独立确认。任何人将13加到语句 \"I am Satoshi Nakamoto\" 后面再计算哈希值都能确认它比目标值要小。这个成功的结果同时也是工作量证明，因为它证明找到了这个随机数所做的工作。虽然验证这个哈希值只需要一次计算，但是找到有效的随机数却花了13次哈希计算。如果目标值更小（难度更大），那我们需要多得多的哈希计算才能找到合适的随机数，但其他人验证它时只需要一次哈希计算。此外，知道难度目标值后，任何人都可以用统计学来估算其难度，因此就能知道找到一个随机数需要多少工作量。 提示：工作量证明必须产生小于难度目标的哈希值。 更高的目标意味着不难找到低于目标的哈希。较低的目标意味着在目标下方更难找到哈希。目标和难度是成反比。 比特币的工作量证明和例10-10中的挑战非常类似。矿工用一些交易构建一个候选区块。接下来，矿工计算这个区块头的哈希值，看其是否小于当前难度目标值。如果这个哈希值不小于目标值，矿工就会修改随机数（通常将之加1）然后再试一次。按当前比特币系统的难度，矿工得试数万亿次才能找到一个合适的随机数，使区块头哈希值足够小。 例10-11是一个简化很多的工作量证明算法的实现。 例10-11 简化的工作量证明算法 #!/usr/bin/env python # example of proof-of-work algorithm import hashlib import time try: long # Python 2 xrange except NameError: long = int # Python 3 xrange = range max_nonce = 2 ** 32 # 4 billion def proof_of_work(header, difficulty_bits): # calculate the difficulty target target = 2 ** (256 - difficulty_bits) for nonce in xrange(max_nonce): hash_result = hashlib.sha256((str(header) + str(nonce)).encode()).hexdigest() # check if this is a valid result, below the target if long(hash_result, 16) 0: # estimate the hashes per second hash_power = float(long(nonce) / elapsed_time) print(\"Hashing Power: %ld hashes per second\" % hash_power) 你可以任意调整难度值（按二进制bit数来设定，即哈希值开头多少个bit必须是0）。然后执行代码，看看在你的计算机上求解需要多久。在例10-12中，你可以看到该程序在一个普通笔记本电脑上的执行情况。 例10-12 多种难度值的工作量证明算法的运行输出 $ python proof-of-work-example.py* Difficulty: 1 (0 bits) [...] Difficulty: 8 (3 bits) Starting search... Success with nonce 9 Hash is 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1 Elapsed Time: 0.0004 seconds Hashing Power: 25065 hashes per second Difficulty: 16 (4 bits) Starting search... Success with nonce 25 Hash is 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148 Elapsed Time: 0.0005 seconds Hashing Power: 52507 hashes per second Difficulty: 32 (5 bits) Starting search... Success with nonce 36 Hash is 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903 Elapsed Time: 0.0006 seconds Hashing Power: 58164 hashes per second [...] Difficulty: 4194304 (22 bits) Starting search... Success with nonce 1759164 Hash is 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3 Elapsed Time: 13.3201 seconds Hashing Power: 132068 hashes per second Difficulty: 8388608 (23 bits) Starting search... Success with nonce 14214729 Hash is 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3 Elapsed Time: 110.1507 seconds Hashing Power: 129048 hashes per second Difficulty: 16777216 (24 bits) Starting search... Success with nonce 24586379 Hash is 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95 Elapsed Time: 195.2991 seconds Hashing Power: 125890 hashes per second [...] Difficulty: 67108864 (26 bits) Starting search... Success with nonce 84561291 Hash is 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a Elapsed Time: 665.0949 seconds Hashing Power: 127141 hashes per second 你可以看出，随着难度位一位一位地增加，查找正确结果的时间会加倍增长。如果考虑整个256bit数字空间，每次要求多一个0，就把哈希查找空间缩减了一半。在例10-12中，为寻找一个随机数使得哈希值开头的26位值为0，一共尝试了8千多万次。即使笔记本电脑每秒可以达120,000多次哈希计算，找到结果依然需要10分钟。 在写这本书的时候，比特币网络要寻找区块头信息哈希值小于 0000000000000000029AB9000000000000000000000000000000000000000000 可以看出，这个难度目标开头的0多了很多。这意味着可接受的哈希值范围大幅缩减，因而找到正确的哈希值更加困难。网络平均每秒要花费超过1.8个zeta次哈希（千亿个哈希）才能发现下一个区块。这似乎是一项不可能完成的任务，但幸运的是，网络每秒有3exa次哈希（EH/sec）的处理能力，平均10分钟左右就能找到一个区块。 10.7.2 难度表示 在例10-3中，我们看到区块中包含难度目标，其被标为\"目标位\"或简称\"bits\"。在区块277,316中，它的值为 0x1903a30c。 这个标记的值被存为系数/指数格式，前两位16进制数字为指数，接下来6位16进制数字为系数。在这个区块里，0x19为指数，而 0x03a30c为系数。 计算难度目标的公式为： 目标target = 系数coefficient 2(8 (指数exponent – 3)) 由此公式及难度位的值 0x1903a30c，可得： 目标 = 0x03a30c 20x08(0x19-0x03)=> 目标 = 0x03a30c 2(0x080x16)=> 目标 = 0x03a30c * 20xB0 按十进制计算为： => 目标 = 238,348 * 2176=> 目标 = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328 转换为16进制： => 目标 = 0x0000000000000003A30C00000000000000000000000000000000000000000000 也就是说高度为277,316的有效区块的头信息哈希值是小于这个目标值的。这个数字用二进制表示，开头超过60位都是0。在 这个难度上，一个每秒可以处理1万亿次哈希计算的矿工（1 tera-hash每秒简称 1 TH/sec）平均每8,496个区块才能找到一个正确结果，换句话说，平均每59天，才能为某一个区块找到正确的哈希值。 10.7.3 难度目标与难度调整 如前所述，目标决定了难度，进而影响求解工作量证明算法所需要的时间。那么问题来了：为什么这个难度值是可调整的？由谁来调整？如何调整？ 比特币的区块平均每10分钟生成一个。这就是比特币的心跳，是货币发行频率和交易达成速度的基础。不仅在短期内，还要在几十年内都必须要保持恒定。在此期间，计算机性能将飞速提升。此外，参与挖矿的人和计算机也会不断变化。为了能让新区块生成时间保持10分钟，挖矿的难度必须可以根据这些变化进行调整。事实上，工作量证明的难度目标是一个动态的参数，会周期调整以达到每10分钟一个新区块的间隔目标。简单地说，设定目标是为了使当前的挖矿能力产生10分钟的区块间隔。 那么，在一个完全去中心化的网络中，这样的调整是如何做到的呢？重新调整目标是自动发生的，并且是每个节点独立进行的。每2,016个区块，所有节点都会重新调整难度目标。难度目标的调整公式测量了找到最后2016个区块所用的时间，并将其与预期时间20160分钟（2016个区块乘以预期的10分钟区块间隔）进行了比较。首先计算实际时间间隔和所需时间间隔之间的比率，然后对目标进行比例调整（向上或向下）。简单地说，如果网络找到一个区块的速度比10分钟快，难度就会增加（目标减少）。如果区块发现速度慢于预期，则难度降低（目标增加）。 难度（或目标值）调整公式可以总结为如下形式： New Difficulty = Old Difficulty * (20160 minutes / Actual Time of Last 2016 Blocks) New Target = Old Target * (Actual Time of Last 2016 Blocks / 20160 minutes) 例10-13展示了Bitcoin Core客户端中的难度调整代码。 例10-13 源文件pow.cpp中的工作量证明的难度调整CalculateNextWorkRequired()函数 // Limit adjustment step int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime; LogPrintf(\" nActualTimespan = %d before bounds\\n\", nActualTimespan); if (nActualTimespan params.nPowTargetTimespan*4) nActualTimespan = params.nPowTargetTimespan*4; // Retarget const arith_uint256 bnPowLimit = UintToArith256(params.powLimit); arith_uint256 bnNew; arith_uint256 bnOld; bnNew.SetCompact(pindexLast->nBits); bnOld = bnNew; bnNew *= nActualTimespan; bnNew /= params.nPowTargetTimespan; if (bnNew > bnPowLimit) bnNew = bnPowLimit; 注意：虽然目标调整每2,016个区块发生一次，但是由于Bitcoin Core客户端的一个错误，它是基于之前的2,015个区块的总时间（而不是2,016个），导致目标调整出现偏差，向较高难度提高0.05％。 参数Interval(2,016区块)和TargetTimespan(1,209,600秒即两周)的定义在文件chainparams.cpp中。 为了防止难度变化过快波动，每个周期的调整幅度必须小于4倍。如果所需的目标要调整的幅度大于4倍，则按4倍调整，不会超过4倍。任何进一步的调整都将在下一个目标调整期内完成，因为这种不平衡将持续到后面的2016个区块。因此，哈希能力和难度之间的巨大差异可能需要几个2016区块周期来平衡。 提示：寻找一个比特币区块需要整个网络花费10分钟来处理，基于前2016个区块挖矿所需的时间，每2016个区块调整一次。这是通过降低或提高难度目标来实现的。 值得注意的是目标难度与交易的数量和金额无关。比特币安全所需的哈希运算能力以及由此产生的电量也和交易数量无关。比特币可以扩大规模，被更广泛的采用，并保持安全，但不是一定需要增加当前的算力能力水平。随着新矿工进入市场争夺奖金，哈希算力的增加代表了市场力量。只要诚实地追求回报的矿工们保持足够的哈希算力，就足以防止“接管”攻击，因此，确保比特币的安全。 目标难度和挖矿电力消耗与将比特币兑换成现金以支付这些电力之间的关系密切相关。随着当前硅制造技术的发展，高性能挖矿系统将尽可能高效，尽可能高的速度将电能转换为哈希算力。挖矿市场的关键因素就是每千瓦时的比特币电价，因为这决定着挖矿的赢利能力，也因此刺激着人们选择进入或退出挖矿市场。 10.8 成功挖出区块 前面已经看到，Jing的节点创建了一个候选区块，准备用来挖矿。Jing有几台ASIC（专用集成电路）矿机， 上面有成千上万个集成电路可以超高速地并行运行SHA256算法。许多专用机器通过USB或者局域网连接到他的挖矿节点上。接下来，运行在Jing的电脑上的挖矿节点将区块头信息传送给这些硬件，让它们以每秒亿万次的速度进行随机数测试。由于随机数只有32位，在耗尽所有随机数可能性（大约40亿）之后，挖矿硬件更改区块头（调整coinbase额外的随机数空间或时间戳），并重置随机数计数器，测试新的组合。 在对区块277,316的挖矿工作开始大概11分钟后，这些硬件里的其中一个找到了解并发回挖矿节点。 当把这个随机数924,591,752 放进区块头时，就会产生一个区块哈希值： 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4 而这个值小于难度目标值： 0000000000000003A30C00000000000000000000000000000000000000000000 Jing的挖矿节点立刻将这个区块发给它所有的对等节点。这些节点在接收并验证这个新区块后，也会继续传播此区块。当这个新区块在网络中扩散时，每个节点将其添加到自己的区块链副本中，将区块链扩展到277,316个区块的新高度。当挖矿节点收到并验证了这个新区块后，它们会放弃之前对构建这个相同高度区块的计算，使用JING的区块作为父区块，立即开始计算区块链中下一个区块。 在下一节中，我们将查看每个节点验证区块和选择最长链，并以此形成一个去中心化区块链共识的过程。 10.9 验证新区块 比特币共识机制的第三步是网络中的每个节点独立校验每个新区块。当新解出的区块在网络中传播时，每一个节点在将它转发到其节点之前，会进行一系列的测试去验证它。这确保了只有有效的区块会在网络中传播。独立校验还确保了诚实的矿工生成的区块可以被纳入到区块链中，从而获得奖励。行为不诚实的矿工所产生的区块将被拒绝，这不但使他们失去了奖励，而且也浪费了寻找工作量证明解的努力，因而导致电费亏损。 当一个节点接收到一个新的区块，它将对照一个长长的标准清单中列出的必须满足的条件对该区块进行验证，若没有通过验证，这个区块将被拒绝。这些标准可以在Bitcoin Core客户端的CheckBlock函数和CheckBlockHead函数中获得。 它包括： 区块的数据结构语法上有效 区块头的哈希值小于目标难度（确认执行工作量证明） 区块时间戳早于验证时刻未来两个小时（允许时间错误） 区块大小在长度限制之内 第一个交易（且只有第一个）是创币交易 使用【10.3 交易的独立验证】检查清单验证区块内的交易并确保它们的有效性 网络上每个节点对每个新区块的独立验证确保了矿工不会作弊。在前面的章节中，我们看到了矿工们如何去记录一笔交易，以获得在此区块中创造的新比特币和交易费。为什么矿工不为他们自己记录一笔交易去获得数以千计的比特币？这是因为每一个节点根据相同的规则对区块进行校验。一个无效的创币交易将使整个区块无效，这将导致该区块被拒绝，因此，该交易就永远不会成为总账的一部分。矿工们必须基于所有节点共享的规则，构建一个完美的区块，并且根据正确的工作量证明的解决方案进行挖矿，他们要花费大量的电力挖矿才能做到这一点。如果他们作弊，所有的电力和努力都会浪费。这就是独立验证是去中心化共识的重要组成部分的原因。 10.10 区块链的组装与选择 比特币去中心化共识机制的最后一步是将区块组装成区块链，并选择累积最大工作证明的区块链。一旦一个节点验证了一个新的区块，它将尝试通过将它连接到现有的区块链来组装一个区块链。 节点维护三种区块：第一种是连接到主链上的区块，第二种是主链的分支（候选链）的区块，最后一种是在已知链中没有找到父区块的区块（孤块）。在验证过程中，一旦验证标准中任何一条失败，这个区块就会被节点拒绝，所以也不会包含到任何一条链中。 任何时候，主链都是累计了最多工作量证明的有效区块组成的链。在大多数情况下，主链也是包含最多区块的那个链，除非有两个等长的链并且其中一个有更多的工作量证明。主链也会有一些分支，这些分支中的区块与主链上的区块互为“兄弟”区块。这些区块是有效的，但不是主链的一部分。保留这些分支的目的是如果在未来的某个时刻它们中的一个延长了并在工作量上超过了主链，那么后续的区块就会引用它们。在【10.10.1 区块链分叉】，我们将会看到在同样的区块高度，几乎同时挖出区块时，候选链是如何产生的。 当节点接收到新区块，它会尝试将这个区块插入到现有区块链中。节点会看一下这个区块的“previous block hash”字 段，这个字段是该区块对其父区块的引用。然后，新的节点将尝试在已存在的区块链中找出它的父区块。大多数情况下，父区块是主块链的“末端”，这就意味着这个新的区块延长了主链。举个例子，一个新的区块277,316引用了它的父区块277,315。收到277,316区块的大部分节点都已经将277,315最为主链的末端，因此，将会连接这个新区块并延长区块链。 有时候，就像在【10.10.1 区块链分叉】看到的，新区块所延长的区块链并不是主链。在这种情况下，节点将新的区块添加到候选链，同时比较候选链与主链的工作量。如果候选链比主链积累了更多的工作量，节点将收敛于候选链，意味着节点将选择候选链作为其新的主链，而之前那个老的主链则成为了候选链。如果节点是一个矿工，它将开始构造新的区块，来延长这个更新更长的区块链。 如果节点收到了一个有效的区块，而在现有的区块链中却未找到它的父区块，那么这个区块被认为是“孤块”。孤块会被保存在孤块池中，直到它们的父区块被节点收到。一旦收到了父区块并且将其连接到现有区块链上，节点就会将孤块从孤块池中取出，连接到它的父区块，让它作为区块链的一部分。当两个区块在很短的时间间隔内被挖出来，节点接收到它们的顺序可能是相反的（子比父先到），这个时候孤块现象就会出现。 选择了最大难度的区块链后，所有的节点最终在全网范围内达成共识。随着更多的工作量证明被添加到链中，链的暂时性差异最终会得到解决，从而扩展可能的链中的一条。挖矿节点通过挖出下一个区块来选择要扩展的链，从而用它们的挖矿算力进行“投票”。当它们挖出一个新区块并且延长了一个链，新区块本身就代表它们的投票。 在下一节中，我们将研究如何通过独立选择累积最大工作量来解决竞争链（分叉）之间的差异。 10.10.1 区块链分叉 因为区块链是去中心化的数据结构，所以不同副本之间不能总是保持一致。区块有可能在不同时间到达不同节点，导致不同的节点有不同的区块链全貌。解决的办法是，每一个节点总是选择并尝试延长代表累计了最大工作量证明的区块链，也就最长的或最大累计工作链（greatest cumulative work chain）。节点通过累加链上的每个区块的工作量，计算创建这个链所付出的累积工作量。只要所有的节点选择最大累计工作链，整个比特币网络最终会收敛到一致的状态。分叉即在不同版本区块链间发生的临时不一致，当更多的区块添加到了某个分叉中，这个问题会被最终的再收敛解决。 提示 本节中描述的区块链分叉是由于全球网络中的传输延迟而自然发生的。 我们也将在本章稍后再看看故意引起的分叉。 在接下来的几个图表中，我们将通过网络跟踪“分叉”事件的进展。该图是比特币网络的简化表示。为了便于描述，不同的区块被显示为不同的形状（星形，三角形，倒三角形，菱形），遍布网络。 网络中的每个圆表示一个节点。 每个节点都有自己的全局区块链视图。当每个节点从其邻居接收区块时，它会更新自己的区块链副本，选择最大累积工作链。 为便于描述，每个节点包含一个图形形状，表示它认为是主链的顶端的区块。 因此，如果在节点里面看到星形，那就意味着该节点认为星形区块处于主链的顶端。 在第一张图（图10-2）中，网络有一个统一的区块链视角，以星形区块为主链的顶端。 图10-2 分叉前所有节点都有相同的全貌 当有两个候选区块出现竞争同时想要延长最长区块链时，分叉事件就会发生。正常情况下，分叉发生在两名矿工在较短的时间内，各自都算得了工作量证明解的时候。两个矿工在各自的候选区块一发现解，便立即传播自己的“获胜”区块给邻近的节点，后者开始在网络上传播。每个收到有效区块的节点都会将其合并到自己的区块链中，为区块链延长一个区块。如果该节点随后看到另一个候选区块，在扩展同样的父区块，那么节点会将这个区块连接到候选链上。其结果是，一些节点收到了一个候选区块，而另一些节点收到了另一个候选区块，这时两个竞争版本的区块链就出现了。 在图10-3中，我们看到两个矿工（节点X和节点Y）几乎同时挖到了两个不同的区块。这两个区块都是星形区块的子区块，构造在星形区块顶端延长这个区块链。为了方便查看，我们把节点X产生的区块标记为三角形，把节点Y生产的区块标记为倒三角形。 图10-3 区块链分叉事件的可视化：同时找到两个区块 例如，我们假设矿工节点X找到扩展区块链工作量证明的解，即三角形区块，构建在星形父区块的顶端。与此同时，同样进行星形区块扩展的节点Y也找到了扩展区块链工作量证明的解，它使用倒三角形区块作为候选区块。现在有两个可能的区块，节点X的三角形区块和节点Y的倒三角形区块，这两个区块都是有效的，均包含有效的工作量证明解并延长同一个父区块。这个两个区块可能包含了几乎相同的交易，只是在交易的排序上有些许不同。 当两个区块开始在网络传播时，一些节点首先接收到三角形区块，另外一些节点首先接收倒三角形区块。如下图10-4所示，比特币网络被分成了两个不同的区块链视角，一边以三角形区块为顶点，而另一边以倒三角形区块为顶点。 图10-4 区块链分叉事件的可视化：两个区块传播，分割了网络 在图中，假设节点X首先接收到三角形块，并用它扩展星形链。节点X选择三角形区块为主链。之后，节点X也收到倒三角区块。由于是第二次收到，因此它判定这个倒三角形区块是竞争失败的产物。然而，倒三角形的区块不会被丢弃。它被链接到星形链的父区块，并形成候选链。虽然节点X认为自己已经正确选择了获胜链，但是它还会保存“失败”链，使得“失败”链如果可能最终“获胜”，它还具有重新收敛所需的信息。 在网络的另一端，节点Y根据自己的视角构建一个区块链。首先收到倒三角形区块，并选择这条链作为“赢家”。当它稍后收到三角形区块时，它也将三角形区块连接到星形链的父区块作为候选链。 双方都是“正确的”或“不正确的”。两者都是自己关于区块链的有效视角。只有事后，才能理解这两个竞争链如何通过额外的工作量得到延伸。 节点X阵营的其他节点将立即开始以“三角形”作为扩展区块链的顶端，挖掘候选区块。通过将三角形作为候选区块的父区块，它们用自己的哈希算力进行投票。它们的投票表明支持自己选择的链为主链。 同样，节点Y阵营的其他节点，将开始构建一个以倒三角形作为其父节点的候选区块，扩展它们认为是主链的链。比赛再次开始。 分叉问题几乎总是在一个区块内就被解决了。网络中的一部分算力专注于“三角形”区块为父区块；另一部分算力则专注在“倒三角形”区块上。即便算力在这两个阵营中平均分配，也总有一个阵营抢在另一个阵营前发现工作量证明解并将其传播出去。假如工作在“三角形”区块上的矿工找到了一个“菱形”区块延长了区块链(星形-三角形-菱形)，他们会立刻传播这个新区块，整个网络会都会认为这个区块是有效的，如下图10-5所示。 图10-5 区块链分叉事件的可视化：一个新的区块扩展一个分叉，重新收敛网络 所有在上一轮选择“三角形”胜出的节点只需简单地将区块链再扩展一个区块。然而，选择“倒三角”的节点现在将看到两个链：星形-三角形-菱形和星型-到三角形。星形-三角形-菱形这条链现在比其他链条更长（累积更多的工作量）。因此，这些节点将星形-三角形-菱形设置为主链，并将星型-倒三角形链变为候选链，如图10-6所示。这是一个链的重新收敛，因为这些节点被迫修改他们对块链的视角，把新证明纳入更长的链。任何延伸星形-倒三角形的矿工现在都将停止这项工作，因为他们的候选区块是“孤块”，其父区块“倒三角形”不再是最长的链。 “倒三角形”内的交易重新插入到内存池中用来包含在下一个区块中，成为主链的一部分。整个网络重新回到单一链状态，收敛为星形-三角形-菱形，“菱形”成为链中的最后一个区块。所有矿工立即开始研究以“菱形”为父区块的候选块，以扩展这条星形-三角形-菱形链。 图10-6 区块链分叉事件的可视化：网络重新收敛在新的最长链上 从理论上来说，两个区块的分叉是有可能的，这种情况发生在因先前分叉而相互对立起来的矿工，又几乎同时发现了两个不同区块的解。然而，这种情况发生的几率是很低的。单区块分叉每天都会发生，而双区块分叉最多每几周才会出现一次。 比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易清算更快地完成，也会导致更加频繁的区块链分叉。与之相对，更长的间隔会减少分叉数量，却会导致更长的清算时间。 10.11 挖矿和算力竞赛 比特币挖矿是一个极富竞争性的行业。比特币存在的每一年，哈希算力都成指数增长。一些年份的增长反映出技术的变革，比如在2010年和2011年，很多矿工开始从使用CPU升级到使用GPU，进而使用现场可编程门阵列（FPGA）进行挖矿。在2013年，ASIC挖矿的引入，把SHA256算法直接固化在挖矿专用的硅芯片上，导致了算力的另一次巨大飞跃。2010年，第一批这样的芯片可以在一个盒子里提供比整个比特币全网更多的挖矿算力。 下面的列表显示了比特币网络在网的前8年的总哈希算力： 2009 0.5 MH/sec–8 MH/sec (16× growth) 2010 8 MH/sec–116 GH/sec (14,500× growth) 2011 116 GH/sec–9 TH/sec (78× growth) 2012 9 TH/sec–23 TH/sec (2.56× growth) 2013 3 TH/sec–10 PH/sec (450× growth) 2014 10 PH/sec–300 PH/sec (30× growth) 2015 300 PH/sec-800 PH/sec (2.66× growth) 2016 800 PH/sec-2.5 EH/sec (3.12× growth) 在图10-7中，我们可以看到近两年里，比特币网络算力的增长。正如您所看到的，矿工之间的竞争和比特币的发展导致算力（网络中每秒的总哈希值）呈指数级增长。 图10-7 总散列算力（TH/sec） 随着比特币挖矿算力的爆炸性增长，与之匹配的难度也相应增长。图10-8中的难度指标显示了当前难度与最小难度（第一个区块的难度）的比率。 图10-8 比特币挖矿难度指标 近两年，ASIC芯片变得更加密集，已经接近芯片制造业前沿的16纳米特征尺寸。目前，由于挖矿的利润率驱动这个行业以比通用计算更快的速度发展，ASIC制造商的目标是超越通用CPU芯片制造商，设计特征尺寸为14纳米的芯片。对比特币挖矿而言，已经没有更多飞跃的空间，因为这个行业已经触及了摩尔定律的最前沿，摩尔定律是指计算密度每18个月翻一番。尽管如此，随着更高密度的芯片和高密度数据中心的部署竞赛，网络算力继续保持指数级增长，数据中心可以部署数千个这样的芯片。现在的竞争已经不再是比较单一芯片的能力，而是一个矿场能塞进多少芯片，还能处理好散热和供电问题。 10.11.1 额外随机数解决方案 2012年以来，比特币挖矿已经发展到需要解决区块头结构的基本限制。在比特币的早期，矿工可以通过遍历随机数，直到产生的哈希值低于目标值，从而挖到一个区块。难度增长后，矿工们经常循环查找了随机数的全部40亿个值，还是找不到区块。然而，这很容易通过更新区块的时间戳并计算经过的时间来解决。因为时间戳是区块头的一部分，它的变化可以让矿工用不同的随机数再次遍历。但是当挖矿硬件的速度达到了4GH/秒，这种方法变得越来越困难，因为随机数的取值范围在一秒内就被用尽了。当出现ASIC矿机并很快达到了TH/秒的哈希率后，挖矿软件为了找到有效的块，需要更多的空间来储存随机数值。可以把时间戳延后一点，但如果把它移动到太远的将来，会导致区块无效。区块头需要一个新的“更改”随机数值的来源。解决方案是使用创币交易作为额外的随机数值来源，因为创币脚本可以储存2-100字节的数据，矿工们开始使用这个空间作为额外随机数的来源，允许他们去探索一个大得多的区块头取值范围来找到有效的区块。这个创币交易也包含在默克尔树中，这意味着任何创币脚本的变化将导致默克尔树根的变化。8个字节的额外随机数，加上4个字节的“标准”随机数，允许矿工每秒尝试296（8后面跟28个零）种可能性而无需修改时间戳。如果未来矿工用尽了以上所有的可能性，他们还可以通过修改时间戳来解决。同样，创币脚本中也有更多额外的空间可以用于将来随机数的扩展。 10.11.2 矿池 在这个激烈竞争的环境中，个体矿工独立工作（也就是solo挖矿）没有一点机会。他们找到一个区块以抵消电力和硬件成本的可能性非常小，以至于可以称得上是赌博，或是买彩票。就算是最快的消费型ASIC矿机也不能和那些在巨大机房里拥有数万芯片并靠近水电站的商业矿场竞争。现在矿工们合作组成矿池，汇集数以千计参与者们的算力并分享奖励。通过参加矿池，矿工们虽然只能得到整体奖励的一小部分，但通常每天都能得到，因而减少了不确定性。 让我们来看一个具体的例子。假设一名矿工已经购买了算力共计14,000GH/S，或14TH/S的设备，在2017年，它的价值大约是2500美元。该设备运行功率为1375W（1.3KW），每日耗电33度，电价比较低的情况下每日成本1或2美元。以目前的比特币难度，该矿工独立挖矿方式挖出一个区块平均需要4年。我们如何计算出这个概率？这是基于全网哈希速率3EH/sec（2017年）和矿工速率14TH/sec计算的： P = (14 1012 / 3 1018) * 210240 = 0.98 其中210240是4年内的区块数量。根据计算周期初的全网哈希率，该矿工在4年内找到区块的概率为98%。 如果这个矿工确实在这个时限内挖出一个区块，奖励6.25比特币，如果每个比特币价格约为1000美元，可以得到6,250美元的收入，这将产生净利润约750美元。然而，在4年的时间周期内能否挖出一个区块还主要靠矿工的运气。他有可能在4年中找到2个块从而赚到非常大的利润。或者，他可能5年都找不到一个块，从而遭受更大的经济损失。更糟的是，比特币的工作量证明算法的难度可能在这段时间内显著上升，按照目前算力增长的速度，意味着矿工在设备过时而必须被下一代更有效率的矿机取代之前，最多有1年的时间取得盈亏平衡。从财务数据分析，这只有非常低的电力成本（每千瓦不到1美分），非常大的规模时才有意义。 矿池通过专用挖矿协议协调成百上千的矿工。个人矿工在建立矿池账号后，设置他们的矿机连接到矿池服务器。他们的挖矿设备在挖矿时保持和矿池服务器的连接，和其他矿工同步各自的工作。这样，矿池中的矿工共同努力挖矿区块，之后分享奖励。 成功出块的奖励支付到矿池的比特币地址，而不是单个矿工的。一旦奖励达到一个特定的金额，矿池服务器便会定期支付奖励到矿工的比特币地址。通常情况下，矿池服务器会为提供矿池服务收取一定百分比的费用。 参加矿池的矿工把搜寻候选区块的工作量拆分，并根据他们挖矿的贡献赚取“份额”。矿池为赚取“份额”设置了一个较高的目标值（较低难度），通常比比特币网络的难度低1000倍以上。当矿池中有人成功挖出一个区块，矿池获得奖励，并按照矿工们做出算力贡献的份额的比例给他们分配奖励。 矿池对任何矿工开放，无论大小、专业或业余。一个矿池的参与者中，有人只有一台小矿机，而有些人有一车库高端挖矿硬件。有的只用几十度电挖矿，也有的会运营着一个消耗兆瓦级的电量的数据中心。矿池如何衡量每个人的贡献，既能公平分配奖励，又避免作弊的可能？答案是使用比特币的工作量证明算法来衡量每个矿池矿工的贡献，但设置的难度较小，以至于即使是矿池中最小的矿工也经常能分得奖励，这足以激励他们为矿池做出贡献。通过设置一个较低的取得份额的难度，矿池可以计量出每个矿工完成的工作量。每当矿工发现一个小于矿池难度的区块头散列值，就证明了它已经完成了分配给自己的寻找结果所需的哈希计算。更重要的是，寻找份额的工作以一种统计上可测量的方式，有助于找到比比特币网络目标更低的哈希值。成千上万试图寻找低哈希值的矿工最终会找到一个足够低的哈希值，满足比特币网络难度目标。 让我们回到骰子游戏的类比。如果骰子玩家的目标是扔骰子结果都小于4（整体网络难度），矿池可以设置一个更容易的目标，统计有多少次池中的玩家扔出的结果小于8。当池中的玩家扔出的结果小于8（矿池份额目标），他们得到份额，但他们没有赢得游戏，因为没有达到游戏目标（小于4）。但池中的玩家会经常地达到较容易的矿池份额目标，规律地赚取他们的份额，尽管他们没有达到赢得比赛的更难的目标。时不时地，池中的一个成员有可能会扔出一个小于4的结果，矿池就获胜了。然后，收益可以在池中玩家获得的份额基础上分配。尽管目标设置为8或更少并没有赢得游戏，但是这是一个衡量玩家们扔出的点数的公平方法，同时它偶尔会产生一个小于4的结果。 同样的，一个矿池也会设置（更高更容易）矿池难度目标，保证一个单独的矿工能够频繁找到一个小于矿池难度目标的区块头散列值来赢取份额。时不时的，某次尝试会产生一个符合比特币网络难度目标值的区块头散列值，成为一个有效区块，然后整个矿池获胜。 10.11.2.1 托管矿池 大部分矿池是“托管的”，意思是有一个公司或者个人经营一个矿池服务器。矿池服务器的所有者叫矿池经营者pool operator，同时他从矿工的收入中收取一定百分比的费用。 矿池服务器运行专业软件以及协调池中矿工们活动的矿池采矿协议。矿池服务器同时也连接到一个或更多比特币全节点，可以直接访问一个区块链数据库的完整副本。这使得矿池服务器可以代替矿池中的矿工验证区块和交易，缓解他们运行全节点的负担。对于矿池中的矿工，这是一个重要的考虑因素，因为一个全节点要求是一个拥有最少100-150GB的永久储存空间（磁盘）和最少2GB到4GB内存（RAM）的专用计算机。此外，运行一个全节点的比特币软件需要监控、维护和频繁升级。由于缺乏维护或资源导致的任何宕机都会伤害到矿工的利润。对于很多矿工来说，不需要运行一个全节点就能采矿，也是加入托管矿池的一大好处。 矿工使用挖矿协议比如Stratum（STM）或者 GetBlockTemplate（GBT）连接到矿池服务器。一个旧标准GetWork（GWK）自从2012年底已经基本上过时了，因为它不支持在算力超过4GH/S时挖矿。STM和GBT协议都创建包含候选区块头模板的区块模板。矿池服务器通过打包交易、添加创币交易（具有额外的随机数空间）、计算默克尔树根，并链接到父区块散列，来构造一个候选区块。这个候选区块的头部作为模板分发给每个矿工。矿工用这个区块模板以比比特币网络的难度目标更高（更容易）为目标进行挖矿，并发送任何成功的结果给矿池服务器以赚取份额。 10.11.2.2 点对点矿池（(P2Pool） 托管矿池存在管理员作弊的可能，管理员可以利用矿池进行双重支付或使区块无效。（参见【10.12 共识攻击】）。此外，中心化的矿池服务器代表着单点故障。如果因为拒绝服务攻击导致服务器宕机或者反应减慢，池中所有矿工就都不能挖矿。在2011年，为了解决由中心化造成的这些问题，提出和实施了一个新的矿池挖矿方法：P2Pool，它是一个点对点的矿池，没有中心管理员。 P2Pool通过将矿池服务器的功能去中心化，实现一个并行的类区块链系统，名叫份额链share chain。一个份额链是一个难度低于比特币区块链的区块链系统。份额链允许池中矿工在一个去中心化的池中合作，以每30秒一个份额区块的速度在份额链上挖矿，获得份额。份额链上的每个区块都记录了贡献工作的矿工的份额，并且继承了上一个份额区块上的份额记录。当其中一个份额区块达到了比特币网络的难度目标时，它将被广播并包含到比特币的区块链上，并奖励所有已经在份额链区块中取得份额的池中矿工。本质上说，比起用一个矿池服务器记录矿工的份额和奖励，份额链使用的是允许所有矿工通过类似比特币区块链系统的去中心化的共识机制跟踪所有份额。 P2P矿池挖矿方式比在中心化矿池中挖矿要复杂的多，因为它要求矿工运行空间、内存、带宽充足的专用计算机来支持一个比特币的全节点和P2P矿池节点软件。P2P矿池矿工连接他们的挖矿硬件到本地P2P矿池节点，节点通过发送区块模板到矿机来模拟矿池服务器的功能。在P2P矿池中，矿工需要独自创建自己的候选区块，打包交易，非常类似于独立矿工，但是他们在份额链上合作采矿。与单独挖矿相比，P2P矿池是一种混合方式，有更精细的支出优势，但是不会像托管矿池那样给管理人太多权力。 即使P2P矿池减少了采矿池运营商的中心化程度，但也很容易受到针对份额链本身的51％攻击。广泛采用P2P矿池并不能解决比特币本身的51％攻击问题。相反，作为多样化挖矿生态系统的一部分，P2P矿池使得比特币整体更加强大。 10.12 共识攻击 至少理论上，比特币的共识机制是容易受到矿工（或矿池）试图使用自己的算力欺骗破坏进行攻击的。就像我们前面讲的，比特币的共识机制依赖于这样一个前提，那就是绝大多数的矿工，出于自己利益最大化的考虑，都会通过诚实地挖矿来维持整个比特币系统。然而，当一个或者一群矿工拥有了整个系统中足够算力之后，他们就可以攻击比特币的共识机制，从而破坏比特币网络的安全性和可靠性。 值得注意的是，共识攻击只能影响整个区块链未来的共识，或者说，最多能影响最近的区块的共识（最多影响过去几十个块）。而且随着时间的推移，整个比特币区块链被篡改的可能性越来越低。理论上，一个区块链分叉可以是任意深度，但实际上，要想实现一个非常深度的区块链分叉需要的算力非常非常大，这使得旧的区块几乎根本无法改变。同时，共识攻击也不会影响用户的私钥以及签名算法（ECDSA）。共识攻击也不能从其他的钱包窃取比特币、没有签名情况下支付比特币、改变比特币支付方向、改变过去的交易或者改变比特币持有纪录。共识攻击只能影响最近的区块，通过拒绝服务来破坏未来区块的生成。 共识攻击的典型场景就是“51%攻击”。想象这么一个场景，一群矿工控制了整个比特币网络大多数（51％）的算力，他们串通起来攻击整个比特币系统。由于这群矿工有生成绝大多数的区块的算力，他们就可以故意制造区块链分叉和“双重支付”，或者针对特定的交易或者特定的钱包地址进行拒绝服务攻击。区块链分叉/双重支付攻击指的是攻击者通过从指定区块之前的区块开始分叉，导致其后的已经确认的区块无效，然后重新收敛这些区块到一个替代的区块链。有了充足算力的保证，一个攻击者可以一次性篡改最近的6个或者更多的区块，从而使得这些区块包含的本应无法篡改的交易（6个确认）无效。值得注意的是，双重支付只能针对攻击者拥有的钱包所发生的交易，因为只有钱包的拥有者才能生成一个合法的签名。如果攻击者可以通过使交易无效获得不可逆的兑换支付或者商品，而且不用付费，这种双重支付攻击就是有利可图的。 让我们看一个“51%攻击”的实际案例。在第1章我们讲到，Alice和Bob之间使用比特币完成了一杯咖啡的交易。咖啡店老板Bob愿意在Alice给自己的转账交易未经确认（区块挖矿）的时候就向其提供咖啡，这是因为与顾客购物的即时性便利性相比，一杯咖啡的双重支付风险很低。这就和大部分的咖啡店对低于25美元的信用卡消费不会向顾客索要签名是一样的，因为和信用卡退款的风险比起来，由于向用户索要信用卡签名导致交易延迟的成本更高。相比之下，使用比特币支付的大额交易被双重支付的风险就高得多了，因为买家（攻击者）可以通过在全网广播一个和真实交易的UTXO一样的伪造交易，以达到取消真实交易的目的。双重支付的发生有两种方式：要么是在交易被确认之前，要么攻击者通过区块链分叉来撤销几个区块。进行51%攻击的人，在新分叉链上双重支付自己的交易，从而撤销在旧链上的交易。 再举个例子：攻击者Mallory在Carol的画廊购买了将中本聪描绘为普罗米修斯的三联组画（名为The Great Fire），Carol出售给Mallory的价格是25万美元的比特币。在等到一个而不是六个或更多的交易确认之后，Carol将这幅组画包好，交给了Mallory。这时，Mallory的一个同伙，一个拥有大量算力的矿池的Paul，在这笔交易写进区块链的时候，开始了51%攻击。首先，Paul指示矿池使用同样的区块高度重新对包含这笔交易的区块进行挖矿，并且在新区块里将原来的交易替换成了双重支付给Mallory相同输入的另外一笔交易。这笔双重支付交易使用了跟原有交易一致的UTXO，但收款人被替换成了Mallory的钱包地址而不是Carol的，实际上就是Mallory继续持有自己的比特币。然后，Paul指示矿池在伪造的区块的基础上，又计算出一个更新的块，这样，包含这笔双重支付交易的区块链比原有的区块链高出了一个区块（导致从包含Mallory交易之后的区块开始分叉）。到此，高度更高的分叉区块链取代了原有的区块链，双重支付交易取代了原来给Carol的交易，Carol既没有收到价值25万美金的比特币，原本拥有的组画也被Mallory拿走了。在整个过程中，Paul矿池里的其他矿工可能自始至终都没有觉察到这笔双重支付交易有什么异样，因为挖矿程序都是自动在运行，并且不会时时监控每一个区块中的每一笔交易。 为了避免这类攻击，售卖大宗商品的商家应该在交易得到全网的6个确认之后再交付商品。或者，商家应该使用托管多重签名签名的账户进行交易，并且也要等到托管账户收到资金并获得全网多个确认之后再交付商品。一条交易的确认数越多，越难被攻击者通过51%攻击篡改。对于大宗商品的交易，即使在付款24小时之后，也就是这笔交易的全网确认数将达到至少144个，再发货，对买卖双方来说使用比特币支付也是方便并且有效率的。 共识攻击中除了“双重支付”攻击，还有一种攻击场景就是拒绝对某个特定参与者（特定比特币地址）提供服务。一个拥有了系统中绝大多数算力的攻击者，可以轻易地忽略某一笔特定的交易。如果这笔交易存在于另一个矿工所产生的区块中，该攻击者可以故意分叉，然后重新产生这个区块，并且把想忽略的交易从这个区块中移除。这种攻击造成的结果就是，只要这名攻击者拥有系统中的绝大多数算力，那么他就可以持续地干预某一个或某一批特定钱包地址产生的所有交易，从而达到拒绝为这些地址服务的目的。 需要注意的是，51%攻击并不是像它的名字说的那样，攻击者需要至少51%的算力才能发起，实际上，即使其拥有不到51%的系统算力，依然可以尝试发起这种攻击。之所以命名为51％攻击，只是因为在攻击者的算力达到51%这个阈值的时候，其发起的攻击尝试几乎肯定会成功。本质上来看，共识攻击，就像是针对下一个区块的拔河比赛，强壮的组最可能赢。随着算力的降低，成功的可能性降低，因为其他矿工以“诚实”的挖矿能力控制着一些区块的产生。从另一个角度讲，一个攻击者拥有的算力越多，其故意创造的分叉区块链就可能越长，可能被篡改的过去最近的区块或者受其控制的未来的区块就会越多。一些安全研究组织利用统计模型得出的结论是，算力达到全网的30%，各种类型的共识攻击都是可能的。 全网算力的急剧增长已经使得比特币系统不再可能被某一个矿工攻击。独立矿工不可能控制总算力的哪怕是很小一部分。但是中心化控制的矿池则带来了矿池操作者出于利益而施行攻击的风险。矿池运营者控制了候选区块的生成，同时也控制哪些交易会被放到新生成的区块中。这样一来，矿池操作者就拥有了剔除特定交易或者双重支付的权力。如果这种权利被矿池操作者以微妙而有节制的方式滥用的话，那么矿池操作者就可以在不为人知的情况下发动共识攻击并获益。 但是，并不是所有的攻击者都是为了利益。一个潜在的场景就是，攻击者仅仅是为了破坏整个比特币系统而发动攻击，而不是为了利益。这种意在破坏比特币系统的攻击者需要巨大的投入和精心的计划，因此可以想象，很有可能来自资金充足、最有可能由国家资助的攻击者发起的。或许，这类资金充足的攻击者或许也会聚敛矿机，勾结矿池运营者，对其他矿池施行拒绝服务等共识攻击。但是，随着比特币网络的算力呈指数级快速增长，上述这些理论上可行的攻击场景，实际操作起来已经越来越困难了。 毫无疑问，一次严重的共识攻击事件势必会降低人们对比特币系统的信心，进而可能导致比特币价格的跳水。然而，比特币系统和相关软件也一直在持续改进，所以比特币社区也势必会对任何一次共识攻击快速做出响应，使整个比特币系统比以往更加稳健和可靠。 10.13 改变共识规则 共识规则决定交易和区块的有效性。这些规则是所有比特币节点之间协作的基础，并负责将整个网络中所有不同角色的本地观点融合为一条一致的区块链。 虽然共识规则在短期内是不变的，并且在所有节点之间必须一致，但长期来看它们并不总是不变的。为了演进和发展比特币系统，规则必须随时改变以适应新功能、改进或修复错误。然而，与传统软件开发不同，升级到共识系统要困难得多，需要所有参与者之间的协调。 10.13.1 硬分叉 在【10.10.1 区块链分叉】，我们研究了比特币网络如何短暂地分叉，网络中的两个部分在短时间内处于区块链的两个不同分支。我们看到这个过程是如何自然发生的，作为网络的正常运行的一部分，以及如何在一个或多个区块被挖掘之后，网络在一个统一的区块链上重新收敛。 另一种情况是，网络也可能会分叉到两条链，这是由于共识规则的变化。这种分叉称为硬分叉hard fork，因为这种分叉后，网络不会重新收敛到统一区块链上。相反，这两条区块链独立发展。当比特币网络的一部分节点按照与网络的其余部分节点不同的共识规则运行时，硬分叉就会发生。这可能是由于错误或者是对共识规则实施的故意修改。 硬分叉可用于改变共识规则，但需要在系统中所有参与者之间进行协调。没有升级到新的共识规则的任何节点都不能参与共识机制，并且在硬分叉的那一刻都被迫进入一条单独的链。因此，硬分叉引入的变化可以被认为不是“前向兼容”，因为未升级的系统不能再处理新的共识规则。 让我们来通过一个特定例子来检查下硬分叉的机制。 下图10-9显示区块链出现两个分叉。在区块高度4处，发生单一区块分叉。这是我们在【10.10.1 区块链分叉】中看到的自发分叉的类型。经过区块5的挖掘，网络在一条链上重新收敛，分叉被解决。 图10-9 分叉的区块链 然而，后来在区块高度6处发生了硬分叉。我们假设原因是由于一个新功能的客户端随着共识规则的改变而发布。从区块高度7开始，运行新的版本的矿工，需要接受新类型的数字签名，我们称之为“Smores”签名，它不是基于ECDSA的签名。紧接着，运行新版本的节点创建了一笔包含Smores签名的交易，一个更新了软件的矿工挖矿出了包含此交易的区块7b。 任何尚未升级验证Smores签名的软件的节点或矿工现在都无法处理区块7b。从他们的角度来看，包含Smores签名的交易和包含该交易的区块7b都是无效的，因为它们是根据旧的共识规则进行评估的。这些节点将拒绝该笔交易和区块，并且不会传播它们。正在使用旧规则的任何矿工都不接受块7b，并且将继续挖掘其父区块6的候选区块。实际上，如果遵守旧规则的矿工连接的所有节点都是遵守旧的规则，那么他们甚至可能接收不到区块7b，因此也不会传播这个区块。最终，他们将挖出区块7a，这个在旧规则是有效的，其中不包含使用Smores签名的任何交易。 这两个链条从这一点继续分裂。 ”b”链的矿工将继续接受并开采含有Smores签名的交易，而“a”链上的矿工将继续忽视这些交易。即使区块8b不包含任何Smores签名的交易，“a”链上的矿工也无法处理。对他们来说，它似乎是一个孤立的区块，因为它的父区块“7b”不被识别为一个有效的区块。 10.13.2 硬分叉：软件，网络，挖矿和链 对于软件开发人员来说，术语“分叉”具有另一个含义，对“硬分叉”一词增加了混淆。在开源软件中，当一组开发人员选择遵循不同的软件路线图并启动开源项目的竞争实现时，会发生分叉。我们已经讨论了导致硬分叉的两种情况：共识规则中的错误，以及对共识规则的故意修改。在故意改变共识规则的情况下，软件叉要比硬分叉先发生。但是，对于这种类型的硬分叉，新的共识规则必须通过开发，采用和启动新的软件实现。 试图改变共识规则的软分叉的例子包括Bitcoin XT，Bitcoin Classic和最近的Bitcoin Unlimited。但是，这些软分叉都没有产生硬分叉。虽然软分叉是一个必要的前提条件，但它本身不足以发生硬分叉。为了实现硬分叉，矿工、钱包和中间节点必须采用竞争实现并激活新规则。相反，有许多Bitcoin Core的替代实现方案，甚至还有软分叉，这些没有改变共识规则，只是去除错误，也可以在网络上共存并交互操作，最终并未导致硬分叉。 共识规则会在交易或区块的验证中表现出明确清晰的不同之处。比如共识规则适用于比特币脚本或数字签名的加密原语时，这种差别可能以微妙的方式表现。最后，由于系统限制或实现细节所产生的隐含共识约束，共识规则还可能以意外的方式有所不同。比如后者的例子是在将Bitcoin Core 0.7升级到0.8中过程中，出现意外的硬分叉，这是由于用于存储区块的Berkley DB实现的限制引起的。 从概念上讲，我们可以将硬分叉看成四个阶段：软分叉，网络分叉，挖矿分叉和区块链分叉。 当开发人员使用修改后的共识规则创建客户端的替代实现时，该流程就开始了。 当这个分叉实现的客户端部署在网络中时，一定比例的矿工，钱包用户和中间节点可以采用并运行该版本客户端。产生的分叉将取决于新的共识规则是否适用于区块，交易或系统其他方面。如果新的共识规则与交易有关，那么根据新规则创建交易的钱包可能会导致网络分叉，随后在交易被挖掘到区块中时发生硬分叉。如果新规则与区块有关，那么当一个区块根据新规则被挖掘时，硬分叉流程开始。 首先，是网络分叉。基于旧的共识规则的节点将拒绝根据新规则创建的任何交易和区块。此外，遵循旧的共识规则的节点将暂时禁止和断开与发送这些无效交易和区块的任何节点的连接。因此，网络将分为两部分：旧节点只连接到旧节点，新节点只连接到新节点。基于新规则的单个交易或区块将通过网络发生连锁反应，导致网络被分裂成了两个。 一旦使用新规则的矿工开采了一个块，挖矿算力和区块链也将分叉。新的矿工将在新区块之上挖掘，而老矿工将根据旧的规则挖掘一个单独的链。分裂的网络使得按照各自共识规则运行的矿工不会接收彼此的块，因为它们连接到两个独立的网络。 10.13.3 分离矿工和难度 随着分裂的矿工们开始开采两条不同的链，链上的算力也被分裂。两个链之间的挖矿算力可以按任意比例分配。新的规则可能只有少数矿工跟随，也可能是绝大多数矿工遵循新规则。 我们假设，例如是80％和20％比例的分配，大多数挖矿算力使用新的共识规则。我们还假设分叉在重新设定难度目标阶段后立即出现。 这两条链将各自继承重定难度目标阶段之后的难度。新的共识规则得到了以前可用的挖矿算力中80％的承诺。从这个链的角度来看，与上一阶段相比，挖矿算力突然下降了20％。平均每12.5分钟就会发现一个区块，这意味着可以扩展这条链的挖矿算力下降了20％。这个区块发行速度将持续下去（除非有任何改变算力的因素出现），直到挖到第2016个区块，这将需要大约25,200分钟（每个区块需要12.5分钟）或17.5天。17.5天后，重定难度目标将再次发生，基于此链中算力的减少量将难度调整（减少20％）到每10分钟产生一个区块。 少数人认可的那条链，根据旧规则继续挖矿，现在只有20％的算力，将面临更加艰巨的任务。在这条链上，平均每隔50分钟挖出一个区块。这个难度将不会在2016个区块之前进行调整，这将需要100,800分钟，或大约10周的时间。假设每个区块具有固定容量，这也将导致交易容量减少5倍，因为每小时可用于记录交易的区块大幅减少了。 10.13.4 有争议的硬分叉 这是共识软件开发的黎明。正如开源开发改变了软件的方法和产品，创造了新的方法论，新工具和新社区，共识软件开发也代表了计算机科学的新前沿。在比特币发展路线图的争论、实验和磨难中，我们将看到新的开发工具、实践、方法论和社区的出现。 硬分叉被视为有风险，因为它们迫使少数人被迫选择升级或是必须保留在少数派链条上。将整个系统分为两个竞争系统被许多人认为是不可接受的风险。结果，许多开发人员不愿使用硬分叉机制来实现对共识规则的升级，除非整个网络都能达成一致。任何没有被所有人支持的硬分叉建议都被认为是“有争议”的，都是不可能不危及系统分裂的尝试。 硬分叉的问题在比特币开发社区也是非常有争议的，尤其是与控制区块大小限制的共识规则的任何相关提议。一些开发人员反对任何形式的硬分叉，认为它太冒险了。另一些人认为硬分叉机制是提升共识规则的重要工具，避免了“技术债务”，并与过去进行了一个干净的了断。最后，还有些开发人员认为硬分叉应该作为一种很少使用的机制，只有经过认真的计划，并且在近乎一致的共识下才建议使用。 我们已经看到出现了新的方法论来解决硬分叉的危险。在下一节中，我们将看一下软分叉，以及BIP-34和BIP-9，用于发送信号和激活共识修改。 10.13.5 软分叉 并非所有共识规则的变化都会导致硬分叉。只有前向不兼容的共识规则的变化才会导致分叉。如果共识规则的改变也能够让未修改的客户端仍然按照先前的规则对待交易或者区块，那么就可以在不进行分叉的情况下实现共识修改。 这就是术语软分叉soft fork，区别于之前的硬分叉升级方法。实际上软分叉不是分叉。软分叉是对共识规则的前向兼容的改变，允许未升级的客户端程序继续在新的共识规则下工作。 软分叉的一个不是很明显的方面就是，软分叉只能用于增加共识规则约束，而不能扩展它们。为了向前兼容，根据新规则创建的交易和区块也必须在旧规则下有效，但是反之不然。新规则只能增加约束条件，否则如果放宽了约束条件，那么新规则所产生的区块（或者交易）在旧规则下被拒绝时，还是会触发硬分叉。 软分叉可以通过多种方式实现，所谓软分叉并不特指某种单一的方法，而是很多种方法，它们都有一个共同点：不要求所有节点升级，也不强制非升级节点脱离共识。 10.13.5.1 软分叉重新定义NOP操作码 基于对NOP操作码的重新解释，比特币已经实现了许多软分叉。比特币脚本有10个操作码保留供将来使用，NOP1到NOP10。根据共识规则，这些操作码在脚本中的存在被解释为无效的运算符，这意味着它们不会产生任何影响。在NOP操作码之后继续执行，就好像它不存在一样。 因此，软分叉可以修改NOP代码的语义给它新的含义。例如，BIP-65（CHECKLOCKTIMEVERIFY）重新解释了NOP2操作码。实施BIP-65的客户端将NOP2解释为OP_CHECKLOCKTIMEVERIFY，针对在锁定脚本中包含该操作码的UTXO，添加绝对锁的共识规则。这种变化是一个软分叉，因为在BIP-65下有效的交易在任何没有实现（不识别）BIP-65的客户端上也是有效的。对于旧的客户端，该脚本包含一个NOP代码，这被忽略。 10.13.5.2 其他方式软分叉升级 NOP操作码的重新解释既是共识升级的规划，同时也是一种明显的升级机制。然而，最近，引入了另一种软分叉机制，其不依赖于NOP操作码来进行特定类型的共识更改。这在【7.8 隔离见证】中有更详细的说明。隔离见证是一个交易结构的体系架构变化，它将解锁脚本（见证）从交易内部移动到外部数据结构（将其隔离）。隔离见证最初被设想为硬分叉升级，因为它修改了一个基本的结构（交易）。在2015年11月，一位致力于Bitcoin Core的开发人员提出了一种机制，通过这种机制，可以将隔离见证作为软分叉引入。此机制是在隔离见证规则下对于UTXO的锁定脚本的修正，使得未升级的客户端将锁定脚本视为可用任何解锁脚本进行兑换。因此，可以不需要每个节点必须升级或从链中脱离就可以引入隔离见证：这就是软分叉。 有可能还有其他尚未被发现的机制，通过这种机制可以用前向兼容的方式作为软分叉进行升级。 10.13.6 对软分叉的批评 基于NOP操作码的软分叉是相对无争议的。NOP操作码被放置在比特币脚本中，明确的目的就是允许无中断升级。 然而，许多开发人员担心软分叉升级的其他方法会产生不可接受的妥协。对软分叉的常见批评包括： 技术性债务 由于软分叉在技术上比硬分叉升级更复杂，所以引入了技术性债务，这是指由于过去的设计权衡而增加未来代码维护的成本。代码复杂性又增加了错误和安全漏洞的可能性。 验证放松 未经修改的客户端将交易视为有效，而无需评估已修改的共识规则。实际上，未经修改的客户端不会使用所有共识规则来验证，因为它们对新规则视而不见。这适用于基于NOP的升级，以及其他软分叉升级。 不可逆转升级 因为软分叉产生额外的共识约束的交易，所以它们在实践中成为不可逆转的升级。如果软分叉升级在激活后被回退，那么任何根据新规则创建的交易都可能导致在旧规则下的资金损失。例如，如果根据旧规则对CLTV交易进行评估，则不存在任何时间锁定约束，并且可以随时花费。因此，批评人士认为，由于错误而不得不回退的失败的软分叉几乎肯定会导致资金的损失。 10.14 使用区块版本发出软分叉信令 由于软分叉允许未经修改的客户在共识内继续工作，“激活”软分叉是通过矿工发出的准备就绪信号：大多数矿工必须同意，准备并愿意执行新的共识规则。为了协调他们的行动，有一个信令机制，使他们能够表达对共识规则改变的支持。该机制是在2013年3月激活BIP-34后引入的，并在2016年7月被BIP-9激活取代。 10.14.1 BIP-34信令和激活 在BIP-34中，第一次实现使用区块版本字段来允许矿工通过信令表示特定的共识规则改变。在BIP-34之前，将区块版本设定为”1”是由于惯例，而不是来自于执行共识。 BIP-34定义了一个共识规则变更，要求在创币交易的coinbase字段（相当于普通交易的输入字段）中包含区块高度。在BIP-34之前，矿工可以在coinbase中填充任意数据。在BIP-34激活之后，有效区块必须在coinbase的开头包含特定的区块高度，并且使用大于或等于“2“的版本号进行标识。 为了通知BIP-34的更改和激活，矿工们将区块版本设置为“2”而不是“1”。这没有立即使版本“1”区块无效。一旦激活，版本“1”的区块将变得无效，并且所有版本“2”的区块需要在coinbase中包含区块高度才能有效。 BIP-34基于1000个区块的滚动窗口定义了两步激活机制。矿工将以“2”作为版本号来构建区块，从而表示他或她已经准备好使用BIP-34。严格来说，由于共识规则尚未被激活，这些区块还无须遵守新的共识规则，也就是不必将区块高度包括在创币交易中。共识规则分为两个步骤激活： 如果75％（最近1000个区块中的750个）标有版本“2”，则版本“2”的区块的创币交易中必须包含区块高度，否则这些区块被会拒绝导致无效。版本“1”的区块仍然被网络接受，不需要包含块高度。这个时期新旧共识规则共存。 当95％（最近1000区块中的950）是版本“2”时，版本“1”的区块不再被视为有效。版本“2”的区块只有当它们在coinbase字段中包含区块高度（根据先前阈值）时才有效。此后，所有区块必须符合新的共识规则，所有有效区块必须在创币交易中包含区块高度。 在成功发出信令并激活BIP-34规则后，该机制又被使用过两次以激活软分叉： 通过BIP-34类型的信令以及区块版本“3”，BIP-66严格DER编码签名被激活，版本“2”的区块无效。 通过BIP-34类型的信令以及区块版本“4”，BIP-65 CHECKLOCKTIMEVERIFY被激活，版本“3”的区块无效。 BIP-65激活后，BIP-34的信令和激活机制退出，并被下面描述的BIP-9信令机制代替。这个标准在BIP-34（Block v2, Height in Coinbase）中定义。 10.14.2 BIP-9信令和激活 BIP-34，BIP-66和BIP-65使用的机制成功地激活了三个软分叉。然而，它被替换是因为它有几个限制： 由于区块版本使用的是整数值，一次只能激活一个软分叉，因此需要在软分叉提议之间进行协调，并就其优先级和排序达成一致。 此外，由于区块版本增加，所以机制并没有提供一种直接的方式来拒绝变更，然后提出一个不同的建议。如果老客户端仍然在运行，他们可能会错误地把新的变更的支持信号，当成旧的变更的拒绝信号。 每个新的更改不可逆转地减少了将来可用于变更的区块版本号。 提出BIP-9用来克服这些困难，提升未来实施变更的速度和便利。 BIP-9将区块版本解释为位字段而不是整数。因为区块版本最初作为整数：版本1到4，因此只有29位可用作为位字段。这样就有了29位，可用于独立和同时发出29个不同提案的准备就绪信号。 BIP-9还设置了发信令和激活的最大时间。这样矿工们不需要永远发出信号。如果一个提案在TIMEOUT期限内（这个值在提案中定义）未激活，则该提案视为被拒绝。该提案可以使用不同位的信令重新提交，更新激活周期。 此外，在TIMEOUT已经过去并且特征被激活或被拒绝之后，信令位可以被再次用于另一个特征而不会混淆。因此，多达29次更改信号可以并行发出，而且超时后可将这些位“再循环”以提出新的更改。 注意 虽然只要投票周期不重叠，信令位可以重复使用或循环使用，但是BIP-9的作者还是建议仅在必要时重复使用位，主要是由于旧软件中的错误，可能会发生意想不到的行为。总之，在全部29位都被使用过一次前，我们不期望看到重复使用。 用于提案变更的数据结构包含以下字段： 名称（name） 用于区分提案的简短描述。通常，BIP将该提案描述为“bipN”，其中N是BIP编号。 位（bit） 0到28，在区块版本中矿工使用这个位用于表示对提案的批准。 开始时间（starttime） 信令开始的时间（基于Median Time Past或MTP），之后该位的值被解释为提案的准备就绪信令。 结束时间（endtime） 该时间（基于MTP），如果尚未达到激活阈值，则认为该更改被拒绝。 与BIP-34不同，BIP-9在2016个区块的难度目标调整周期内，计算激活信号的数量。在每个难度调整周期内，如果针对某个提案的信令区块总数超过95％（2016中的1916），则该提案将在下一个难度调整周期内激活。 BIP-9提供了一个提案状态图，以说明一个提案的各个阶段和转换，如图10-10所示。 一旦参数在比特币软件中已知（定义），提案就以定义（DEFINED）状态开始。对于MTP时间在开始时间之后的区块，提案状态转换为开始（STARTED）。如果在难度调整周期内，投票数超过了阈值，并且尚未超时，则提案状态转换为锁定（LOCKED_IN）。一个难度调整周期后，提案变为激活（ACTIVE）。一旦达到该状态，提案会永久保持激活状态。如果投票还没有达到阈值前，超时时间已到，那么提案状态更改为失败（FAILED），这表示提案被拒绝了。一个失败（FAILED）的提案会永久保持在这个状态。 图10-10 BIP-9状态转换图 BIP-9首次实施用于激活CHECKSEQUENCEVERIFY和相关的BIP（68,112,113）。名为“csv”的提案在2016年7月成功激活。 该标准在BIP-9（带有超时和延时的版本位）中定义。 10.15 共识软件发展 共识软件不断发展，对于改变共识规则的各种机制进行了很多讨论。就其本质而言，比特币在协调和共识变化方面树立了非常高的标杆。作为一个去中心化的系统，不存在凌驾于网络参与者之上的“权威”。权力分散在多个支持者，如矿工，核心开发者，钱包开发者，交易所，商家和最终用户之间。这些支持者不能单方面做出决定。例如，尽管矿工在理论上可以使用过半数（51％）来改变规则，但受到其他支持者准许的限制。如果他们单方面行事，其他参与者可能会拒绝遵从，使其经济活动保持在少数链上。如果没有经济活动（交易，商人，钱包，交易所），矿工们只能用空的区块开采一个毫无价值的货币。这种权力的分散意味着所有参与者必须协作，否则任何改变都不能实现。现状就是这个系统是稳定的，如果大多数人有强烈的共识，才可能会有一些变化。软分叉中的95％阈值就反映了这一现实。 重要的是要认识到，对于共识发展没有完美的解决办法。硬分叉和软分叉都涉及权衡。对于某些类型的更改，软分叉可能是一个更好的选择；对于另外一些情况，硬分叉又可能更好。没有完美的选择，都带有风险。共识软件发展的一个不变特征是变革是困难的，共识促成了妥协。有些人认为这是共识制度的弱点。 一些人认为这是共识体系的弱点。随着时间的推移，你可能会像我一样，把它视为系统的最强大的优势。 "},"ch11.html":{"url":"ch11.html","title":"第十一章 比特币安全","keywords":"","body":"第11章 比特币安全 确保比特币安全是一项挑战，因为比特币不像银行账户中的余额那样是对价值的抽象引用。比特币非常像数字现金或黄金。你可能听过这样一句话：“现实占有,十诉九胜”。好吧，对于比特币，所有权就是百分之百的规则。拥有解锁比特币的密钥就相当于拥有现金或金银珠宝。你也可能会丢失，放错地方，被盗，或者不小心给错了钱。发生以上每一种情况，用户都会失去追索权，就像在大街上丢了现金一样。 但是，比特币具有现金、黄金和银行账户所不具备的功能。一个包含你密钥的比特币钱包，可以像任何文件一样备份。它可以存储有多个副本，甚至打印在纸上进行硬备份。你没有办法“备份”现金、黄金或银行账户。比特币与以往的任何东西都有很大的不同，我们需要用一种全新的方式来考虑比特币的安全性。 11.1 安全准则 比特币的核心准则是去中心化，这一点对安全性具有重要意义。在中心化的模式下，例如传统的银行或支付网络，需要依赖于访问控制和审查制度将不良行为者拒之门外。相比之下，比特币这样的去中心化系统则将责任和控制权都移交给了用户。由于网络的安全性是基于工作量证明而非访问控制，比特币网络可以对所有人开放，也无需对比特币传输进行加密。 在一个传统的支付网络中，例如信用卡系统，支付是无限制的，因为它包含了用户的私有标识（信用卡号）。在初次支付后，任何能获得该标识的人都可以从所有者那里反复“提取”资金。因此，该支付网络必须采取端对端加密的方式，以确保没有任何窃听者或中间人损害正在转账或存储（静止）的支付交易。可以在资金流通或存储过程中将交易数据截获。如果坏人获得该系统的控制权，他将能破获当前的的交易以及发起新交易的支付令牌。更糟的是，当客户数据被泄露时，顾客的个人身份信息也暴露给盗窃者，这时必须立即采取措施，以防失窃帐户被盗窃者用于欺诈。 比特币则截然不同，比特币交易只授权向指定接收方发送一个指定数额，并且不能被修改或伪造。它不会透露任何个人信息，例如当事人的身份，也不能用于权限外的支付。因此，比特币的支付网络并不需要加密或防窃听保护。事实上，你可以在任何公开的网络上广播比特币交易的数据，例如在不安全的WIFI或蓝牙网络上公开传播比特币交易的数据，这对安全性没有任何影响。 比特币的去中心化安全模型很大程度上将权力移交到用户手上，随之而来的是用户们保管好密钥的责任。这对于大多数 用户来说并非一件易事，特别是在像智能手机或笔记本电脑这种能能时刻联网的通用设备上。虽然比特币的去中心化模型避免了常见的信用卡盗用等情况，但很多用户由于无法保管好密钥从而一次又一次被黑客攻击。 11.1.1 比特币系统安全开发 对于比特币开发者而言最重要的是去中心化原则。大多数开发者对中心化的安全模型很熟悉，并可能试图将中心化的模型运用到比特币的应用中去，这将给比特币带来灾难性影响。 比特币的安全性依赖于通过密钥的去中心化控制，以及矿工们各自独立的交易验证。如果你想利用好比特币的安全性，你需要确保处于比特币的安全模型中。简而言之，不要将用户的密钥控制权拿走，也不要让交易离开区块链。 例如，许多早期的比特币交易所将所有用户的资金集中在一个包含着私钥的“热钱包”里，并存放在服务器上。这样的设计夺取了用户的掌控权，通过单一系统中心化控制密钥。很多这样的系统都被黑客攻破了，并给客户带来灾难性后果。 另一个常见的错误是为了减少交易费或加速交易处理速度，接受“链下交易”。“链下交易”系统将交易数据记录在一个内部的中心化账本上，然后偶尔将它们同步到比特币区块链中。这种做法，再一次用专制和中心化的方式取代比特币的去中心化安全模型。当交易处于链下的时候，担保不当的中心化账本里的资金可能不为人知情况下被伪造、被挪用、被消耗。 除非你是准备大力投资运营安全，叠加多层访问控制，或（像传统的银行那样）加强审计，否则在脱离比特币的去中心化安全场景范围之外抽调资金之前，你应该慎重考虑一番。即使你有足够的资金和规则去实现一个可靠的安全模型，这样的设计也仅仅是复制了一个脆弱不堪，深受账户盗窃威胁、贪污和挪用公款困扰的传统金融网络而已。要想充分利用比特币特有的去中心化安全模型，你必须避免中心化架构的常见诱惑，虽然中心化架构大家都熟知，但它最终将破坏比特币的安全性。 11.1.2 信任根 传统的安全体系结构是基于一个被称为信任根root of trust的概念，它是一个可信核心，它是整个系统或应用程序安全的基础。安全架构是围绕信任根开发的，它是一系列同心圆，就像洋葱的层，从中心向外扩展信任。每一层都构建于更可信的内层之上，通过访问控制，数字签名，加密和其他安全方式确保可信。随着软件系统变得越来越复杂，它们更可能出现问题，安全更容易受到威胁。其结果是，软件系统变得越复杂，安全就越难得到保障。信任根的概念确保绝大多数的信任被置于一个不是过于复杂系统的一部分，因此该系统的这部分也相对坚固，而更复杂的软件则被层层包围。这种安全体系结构以不同的规模重复出现，首先在单个系统的硬件中建立信任根，然后通过操作系统将该信任根扩展到更高级别的系统服务，最后跨多个以信任递减的同心圆分层的服务器。 比特币的安全体系与这不同。在比特币里，共识系统创建了一个可信的完全去中心化的公开账本。正确验证过的区块使用创世区块作为信任根，建立一条至当前区块的可信任链。比特币系统可以也应该使用区块链作为它们的信任根。在设计由许多不同系统上的服务组成的复杂比特币应用程序时，应仔细检查安全体系结构，以确定信任的位置。最终，唯一值得明确信任的是一个经过充分验证的区块链。如果您的应用程序显式或隐式地信任区块链以外的任何东西，则应该引起关注，因为它会引入漏洞。评估应用程序安全体系结构的一个好方法是单独考量每个组件，设想该组件被完全攻破并被坏人掌控的场景，依次取出应用程序的每个组件，并评估它被攻破时对整体安全的影响。如果组件受损时您的应用程序不再安全，则表明您对这些组件的信任出现错位。一个没有漏洞的比特币应用程序应该只容易受到比特币共识机制的损害，这意味着它的信任根是比特币安全架构中最强大的部分。 无数个被黑客攻击的比特币交易所的例子都是因为轻视了这一点，他们的安全体系和设计甚至无法通过基本的审查。这种中心化的实现方式将信任置于比特币区块链之外的诸多组件之上，例如热钱包，中心化的账本数据库，简易加密的密钥，以及许多类似的方案。 11.2 用户最佳安全实践 人类使用物理安全控制已有数千年的历史。相比之下，我们在数字安全方面的经验还不到50年。现代通用操作系统不太安全，也不特别适合存储数字货币。我们的电脑经常通过互联网连接受到外部威胁。它们运行来自数百名作者的数千个软件组件，通常可以无限制地访问用户的文件。一个流氓软件，在你电脑上安装的成千上万个软件中，可以破坏你的键盘和文件，窃取钱包应用程序中存储的任何比特币。想要杜绝病毒和木马对电脑的威胁，用户要达到一定的计算机维护水平，只有小部分人能做到。 尽管信息安全经过了数十年的研究和发展，数字资产在绵延不绝的攻势下还是十分脆弱。纵使是像金融服务公司，情报机构或国防承包商这样拥有高度防护和限制的系统，也经常会被攻破。比特币创造了具有内在价值的数字资产，它可以被窃取，并立即转移给他人而无法撤回。这让黑客有了强烈的作案动机。至今为止，黑客都不得不在套现后更换身份信息或帐户口令，例如信用卡或银行账户。尽管掩饰和洗白这部分财务信息的难度不小，但越来越多的窃贼从于此道。而比特币使这个问题加剧了，因为它不需要掩饰或洗白，它本身就是具有内在价值的数字资产。 幸运的是，比特币也有着激励机制，以提高计算机的安全性。以前，计算机受威胁的风险是模糊的，间接的，而比特币让这些风险变得清晰而明显。把比特币放在电脑上可以让用户的注意力集中在提高电脑安全性的需求上。比特币和其它数字货币得以传播和扩散的直接结果就是，我们看到黑客技术和安全解决方案都在升级。简单来说，黑客现在看到的是非常诱人的目标，而用户也有明确的激励性去保卫自己。 在过去的三年里，随着比特币不断被接纳，直接的结果就是，我们已经看到信息安全领域取得了巨大创新，例如硬件加密，密钥存储和硬件钱包，多重签名技术和数字托管。在下面的章节中，我们将研究实现用户安全的各种最佳实践。 11.2.1 比特币物理存储 相比数字信息的安全，大多数用户对物理安全更加熟悉，一个非常有效保护比特币的方法是，将它们转换为物理形式。 比特币密钥不过是串长数字而已。这意味着它们可以以物理形式存储起来，如印在纸上或蚀刻成金属硬币上。这样保护密钥就变成了简单地保护印着比特币密钥的物理实体。一组打印在纸上的比特币密钥被称为“纸钱包”，有许多可以用来创建它们的免费工具。我个人将大部分（99％以上）的比特币存储在纸钱包上，并用BIP-38加密，复制了多份并锁在保险箱里。将比特币离线保存的方法被称为冷存储cold storage，它是最有效的安全技术之一。冷存储系统是在一个离线系统（一个从来没有连接过互联网的系统）上生成密钥，并离线存储到纸上或者U盘等电子媒介上。 11.2.2 硬件钱包 从长远来看，比特币安全将越来越多地以硬件防篡改钱包的形式出现。与智能手机或台式电脑不同，一个比特币硬件钱包只有一个目的，安全地存储比特币。没有通用软件的妥协，硬件钱包只提供了有限的接口，从而可以给非专业用户提供近乎万无一失的安全等级。我期望看到硬件钱包成为比特币储存的主要方式。硬件钱包的实例，请查阅TREZOR。 11.2.3 平衡风险 虽然大多数用户都非常关注比特币防盗，其实还有一个更大的风险存在。数据文件丢失的情况时有发生。如果其中包括比特币，损失将会痛苦更多。为了保护好比特币钱包，用户必须非常小心不要过于走极端，否则也会丢失比特币。在2011年7月，一个著名的比特币意识教育项目损失了近7,000枚比特币。为了防止盗窃，拥有着们实施了一系列复杂的加密备份。最后，他们意外地丢失了加密密钥，使备份一文不值，损失了一大笔钱。就像把钱藏在沙漠里一样，如果你把比特币保护得太好，你可能就再也找不到了。 11.2.4 分散风险 你会将你的全部家当换成现金放在钱包里随身携带么？大多数人会认为这非常不明智，但比特币用户经常会将所有的比特币放在一个钱包里。用户应该将风险分散到不同类型的比特币钱包。审慎的用户应该只留一小部分（或许低于5%）的比特币在一个在线的或手机钱包，就像零用钱一样，其余的部分应该采用不同存储机制分散开来，诸如电脑钱包和离线（冷存储）钱包。 11.2.5 多重签名和治理 当一个公司或个人持有大量比特币时，他们应该考虑采用多重签名的比特币地址。多重签名比特币地址需要多个签名才能支付，从而保证资金的安全。多重签名的密钥应存储在多个不同的地方，并由不同的人掌控。比如，在企业环境中，密钥应该分别生成并由若干公司管理人员持有，以确保没有任何一个人可以独自占有资金。多重签名的地址也可以提供冗余，例如一个人持有多个密钥，并将它们分别存储在不同的位置。 11.2.6 生存能力 一个非常重要却又常常被忽视的安全性考虑是可用性，尤其是在密钥持有者丧失能力或死亡的情况下。比特币的用户被告知应该使用复杂的密码，并保证他们的密钥安全且不为他人所知。不幸的是，这种做法使得在用户无法解锁时， 用户的家人几乎无法将该财产恢复。事实上，比特币用户的家人可能完全不知道这笔比特币资金的存在。 如果你有很多的比特币，你应该考虑与一个值得信赖的亲属或律师分享解密的细节。可以搞一个更复杂的比特币恢复计划，可以通过设置多重签名，做好遗产规划，并通过专门的“数字资产执行者”律师处理后事。 11.3 总结 比特币是一项全新的，前所未有的，复杂的技术。随着时间的推移，我们将开发出更好的安全工具，而且更容易被非专业人士使用。而现在，比特币用户可以使用许多这里所讨论的技巧，享受安全而无困扰的比特币体验。 "},"ch12.html":{"url":"ch12.html","title":"第十二章 比特币应用","keywords":"","body":"第12章 区块链应用 现在，让我们把比特币作为一个应用平台application platform，进一步加深理解。现在很多人使用“区块链”这个词来表示任何共享了比特币设计原则的应用平台。 该术语经常被滥用，并被应用于许多不能提供比特币区块链主要功能的事情。 在本章中，我们将介绍比特币区块链作为应用平台所提供的功能。 我们将考虑应用程序的开发要素primitives，即组成任何区块链应用程序的开发模块。我们将研究使用这些要素的几个重要应用程序，例如支付（状态）渠道和路由支付通道（闪电网络）。 12.1 介绍 比特币系统被设计为一个去中心化的货币及支付系统。然而，它的大部分功能都是从底层的概念派生出来的，这些概念被更广泛用于许多应用程序。比特币不是由帐户，用户，余额和付款等组件构建的。相反的，就像我们在【第6章交易】中看到的，它使用的是具有低级加密函数的交易脚本语言。就像账户，余额和付款这些更高级的概念可以从基本要素衍生出来一样，许多其他复杂的应用也是如此。 因此，比特币区块链可以成为一个向诸如智能合同等应用程序提供信任服务的应用平台，远远超出了作为数字货币和支付的最初目的。 12.2 开发模块（要素） 当比特币系统长期稳定运行时，它就提供了一定的保证，可以作为开发模块来创建应用程序。 这些包括： 杜绝双重支付 比特币去中心化共识算法的最根本保证是确保同一UTXO不会被花费两次。 不可篡改性 一旦交易被记录在区块中，并且随后的区块中添加了足够的工作量，该交易数据就变得不可篡改。不可篡改性是由能源进行保证的，因为重写区块链需要花费能源才能产生工作量证明。随着在包含交易的区块之后被提交的工作量增加，所需的能源以及由此带来的不篡改的程度也在增加。 中立 去中心化的比特币网络传播有效的交易，而不管这些交易的来源或内容如何。这意味着任何人都可以支付足够的费用来创建有效的交易，并相信别人会随时传输该交易并将其包含在区块链中。 安全时间戳 共识规则拒绝任何时间戳距离现在太远的区块，包括过去或将来。这可以确保区块上的时间戳是可信的。区块上的时间戳意味着一种保证，保证交易包含的全部输入之前都是未花费的。 授权 在去中心化网络中验证过的数字签名可提供授权保证。未经脚本中隐含的私钥的持有人的授权，包含数字签名要求的该脚本就不能被执行。 审计能力 所有交易都是公开的，可以被审计。所有的交易和交易所属的区块都可以在一个完整的链中链接回到创世区块。 会计 在任何交易中（创币交易除外），输入的金额等于输出的金额加上交易费。在交易中不可能创建或销毁比特币价值。输出不能超过输入。 永不过期 有效的交易永远不会过期。如果今天有效，它在将来仍然有效，只要那个输入未被花费，共识规则没有改变。 公正性 使用SIGHASH_ALL签名的比特币交易或由另外的SIGHASH类型签名的交易的部分，不能在未使签名无效的情况下被修改，如果修改将导致交易本身无效。 交易原子性 比特币交易是原子性的。 它们要么是有效的并且经过确认的（挖矿），要么不是。不存在挖出不完整的交易，交易也不存在过渡状态。在任何时间点，交易要么被挖出，要么没有被挖出。 离散（不可分割）价值单位 交易输出是离散和不可分割的价值单位。它们要么整体被花费，要么未被花费，不能被分割或者部分被花费。 法定人数控制 脚本中的多重签名约束强制执行多重签名方案中预定义的法定人数授权。M/N要求由共识规则执行。 时间锁/老化 任何包含相对或绝对时间锁的脚本子句只能在其期限超过指定时间后执行。 复制 区块链的去中心化存储确保了在交易在被挖出之后，经过充分的确认，它被复制到整个网络上，就变成永久性的，并且能够抵御断电，数据丢失等的影响。 伪造保护 每笔交易只能花费现有的经过验证的输出。不可能创建或伪造价值。 一致性 在没有矿工分区的情况下，记录在区块链中的区块将根据记录深度进行重组，或者其不一致的可能性将以指数递减。一旦被记录在深层，如果想要改变，所需的计算和能量将大到几无可能。 记录外部状态 每个交易可以通过OP_RETURN提交一个值，表示外部状态机中的状态转换。 可预测发行量 总计不到2100万个比特币将会以可以预测的速度发行。 上述开发模块的列表并不完整，还会有新功能将被介绍添加到比特币中。 12.3 源于开发模块的应用 由比特币提供的开发模块是可信平台的组成部分，可用于构成各种应用程序。以下是今天在用的应用程序的一些示例及其使用的开发模块： 存在证明（数字公证）Proof-of-Existence（Digital Notary） 不可篡改性+时间戳+永久性。数字指纹可以通过一个交易提交给区块链，证明在记录时存在一个文档（时间戳）。数字指纹不能在事后修改（不可篡改性），证据将被永久保存（永久性）。 众筹（Lighthouse项目）Kickstarter（Lighthouse） 一致性+原子性+完整性。如果您签署了一个众筹交易的输入和输出（完整性），其他人可以为资金众筹做出贡献，但在目标（就是输出值）获得资金（一致性）之前，不能使用（原子性）。 支付通道Payment Channels 法定人数控制+时间锁+杜绝双重支付+永不过期+耐审查+授权。带有时间锁（Timelock）的2/2（法定人数）多重签名被作为支付通道的“结算”交易时，可以被持有（永不过期）或者在任何时间由任何一方（授权）的情况下（耐审查）进行花费。然后双方可以创建更短的时间锁（Timelock）的承诺交易，双重支付（杜绝之前的双重支付）该结算交易。 12.4 合约币（Counterparty） 合约币是在比特币之上建立的协议层。“合约币协议”提供了创建和交易虚拟资产和代币的能力。此外，合约币提供了去中心化的资产交换。合约币还在实施基于Ethereum虚拟机（EVM）的智能合约。 合约币使用OP_RETURN操作码或1/N多重签名的公钥地址将元数据嵌入到比特币交易中，该地址用于代替公共密钥进行元数据编码。使用这些机制，合约币实现了在比特币交易中编码的协议层。额外的协议层可以由能理解合约币的应用程序来解读，如钱包和区块链浏览器，或使用合约币库（library）构建的任何应用程序。 反过来合约币可以用作给其他应用程序和服务的平台。例如，Tokenly是一个建立在合约币之上的平台，允许内容创作者，艺术家和公司发行表示数字所有权的代币，并可用于租赁，访问，交易或购买内容，产品和服务。利用交易合约币的其他应用包括游戏（Spells of Genesis）和网格计算项目（(Folding Coin）。 更多关于合约币的内容参见https://counterparty.io。开源项目可以在https://github.com/CounterpartyXCP中找到。 12.5 支付通道和状态通道 支付通道Payment channels是在比特币区块链之外，双方交换比特币交易的无信任机制。这些交易，如果在比特币区块链上结算，则是有效的，然而他们却是在链外被持有的，以期票promissory notes的形式等待最终批量结算。由于交易尚未结算，因此可以在没有通常的结算延迟的情况下进行交换，从而可以满足极高的交易吞吐量，低（亚毫秒）延迟和精细（satoshi级）粒度。 实际上，通道channel 一词是一个比喻。状态通道是区块链外，由双方之间的交换状态代表的虚拟构想。实际上没有“通道”，底层数据传输机制也并不是通道。我们使用通道这个术语来表示链外双方之间的关系和共享状态。 为了进一步解释这个概念，想一想TCP流。从高层协议的角度来看，它是一个横跨互联网连接两个应用程序的“socket”。但是，如果您查看网络流量，TCP流只是IP数据包之上的虚拟通道。TCP流的每个端点通过排序并组装IP数据包以产生字节流的错觉。实际上在背后，所有的数据包都是断开分散的。同理，支付通道只是一系列交易。如果妥善排序和连接，它们会创建可赎回的合约，即使您不信任通道的另一方，也可以信任这些合约。 在本节中，我们将介绍各种形式的支付通道。首先，我们将研究用于构建计量小额支付服务（如流媒体视频）的单行（单向）支付通道的机制。然后，我们将扩大这一机制，引入双向支付通道。最后，我们将看看首先在 闪电网络Lightning Network 中提出的，如何在路由网络中端到端地连接双向通道以形成多跳通道。 支付通道是更广泛的状态通道state channel概念的一部分，状态通道代表了链外状态的变化，通过最终在区块链上结算得到保障。支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。 12.5.1 状态通道基本概念和术语 通过在区块链上锁定共享状态的交易，在交易两方之间建立了一个状态通道。这被称为注资交易funding transaction或锚点交易anchor transaction。这笔交易必须传送到网络并被挖矿确认，才能建立通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）。 随后双方交换已签名的交易，这被称为承诺交易commitment transactions。承诺交易会改变初始状态。这些交易是有效的交易，因为它们可以被任何一方提交进行结算，但是在通道关闭之前，每一方都会将其在链下保留。状态更新的创建速度可以与每一方创建、签名并将交易传输给另一方的速度一样快。实际上，这意味着每秒可以交换数千笔交易。 当交换承诺交易时，双方同时废止之前的状态，这样最新的承诺交易总是唯一可以兑换的承诺交易。这样可以防止任何一方在通道中某个先前状态比最新状态更有利于己方的时候通过单方面关闭通道来进行欺骗。我们将在本章的其余部分中研究可用于无效先前状态的各种机制。 最后，通道可以协商关闭，即向区块链提交最后的结算交易settlement transaction，或者由任何一方单方面提交最后承诺交易到链上。单方面关闭的选项是必要的，以防万一交易中的一方意外断开连接。结算交易代表通道的最终状态，并在链上进行结算。 在通道的整个生命周期中，只有两个交易需要提交给链上进行挖矿：注资交易和结算交易。在这两个状态之间，双方可以交换任何数量的承诺交易，任何其他人永远不会看到，也不会提交到链上。 下图12-1说明了Bob和Alice之间的支付通道，显示了注资交易，承诺交易和结算交易。 图12-1 Bob和Alice之间的支付通道，展示了注资交易，承诺交易和结算交易 12.5.2 简单支付通道示例 要说明状态通道，我们必须从一个非常简单的例子开始。 我们展示一个单向通道，意味着价值只向着一个方向流动。为了便于解释，我们以一个天真的假设开始，假设没有人要试图欺骗他人。一旦我们解释了基本的通道概念，我们将研究如何使其不可信，以便双方都不能作弊，即使他们试图作弊。 对于这个例子，我们假设两个参与者：Emma和Fabian。Fabian提供视频流服务，使用微支付通道按秒计费。Fabian每秒视频收费0.01毫比（millibits）（0.00001 BTC），相当于每小时视频收费36毫比（0.036 BTC）。Emma从Fabian这里购买流媒体视频服务。下图12-2显示Emma使用支付通道从Fabian购买视频流服务。 图12-2 Emma使用以秒计费的支付通道从Fabian购买视频流服务 在这个例子中，Fabian和Emma使用专门的软件来处理支付通道和视频流。Emma在浏览器中运行软件，Fabian从服务器端运行软件。这个软件包括基本的比特币钱包功能，可以创建和签署比特币交易。“支付通道”的概念和术语对于用户都是完全不可见的。他们看到的是以秒为单位付费的视频。 为了设置支付通道，Emma和Fabian建立了一个2/2的多重签名地址，双方各持一个密钥。从Emma的角度来看，她的浏览器中的软件提供了一个带有P2SH地址的二维码（以“3”开头），并要求她提交最多1小时视频的“押金”。Emma向该地址支付资金。Emma支付给该多重地址的交易，就是支付通道的注资交易或叫锚点交易。 就这个例子而言，我们假设Emma支付了36个毫比（0.036 BTC）到通道中。这将允许Emma消费长达1小时的流媒体视频。这笔注资交易设定了可以在这个通道上发送的最大数量（数据量），即设置了通道容量 channel capacity。 注资交易从Emma的钱包中消耗一个或多个输入以汇集资金。它创建一个价值为36毫比的输出，支付给Emma和Fabian之间共同控制的2/2多重签名地址。它也可能有一个作为找零到Emma的钱包的额外输出。 一旦注资交易得到确认，Emma可以开始观看视频。Emma的软件创建并签署一笔承诺交易，改变通道余额，将0.01毫比归入Fabian的地址，并退回给Emma35.99毫比。Emma签署的交易消耗了由注资交易创造的36毫比输出，并创建了两个输出：一个用于找钱，另一个用于Fabian的付款。交易只是部分被签署了，它需要两个签名（2/ 2），但现在只有Emma的签名。当Fabian的服务器接收到此交易时，它会添加第二个签名（用于2/2输入），并将其与时长1秒的视频一起返回给Emma。现在双方都有谁都可以兑换的完全签署的承诺交易，这个承诺交易代表着通道中的最新正确余额。双方都不会将此交易广播到网络中。 在下一轮，Emma的软件创建并签署另一个承诺交易（2号承诺交易），该交易从资金交易中消耗相同的2/2输出。2号承诺交易分配0.2毫比的一个输出到Fabian的地址，还有一个输出为35.98毫比，作为找零返回给Emma的地址。这个新交易支付的是累积两秒的视频内容。Fabian的软件签署并返回第二个承诺交易，再加上另一秒视频。 利用上述的方法，Emma的软件继续向Fabian的服务器发送承诺交易，以换取流媒体视频。因为Emma观看了更多秒数的视频，通道中属于Fabian的钱逐渐累积变多。假设Emma观看600秒（10分钟）的视频，创建和签署600笔承诺交易。最后的承诺交易（600号承诺交易）将有两个输出，将通道的余额分成两半，分别为6毫比属于Fabian和30毫比属于Emma。 最后，Emma点击“停止”停止流媒体视频。 Fabian或Emma现在可以发送最终状态交易以进行结算。最后一笔交易即为结算交易，向Fabian支付所有Emma消费的视频，并退还给Emma注资交易中剩余的资金。 图12-3显示了Emma和Fabian之间的通道以及更新通道余额的承诺交易。 最后，只有两个交易记录在块上：建立通道的注资交易和在两个参与者之间正确分配最终余额的结算交易。 图12-3 Emma和Fabian之间的支付通道，承诺交易不断的更新通道余额 12.5.3 制造无需信任的通道 我们刚才描述的渠道是有效的，但前提是双方合作，没有任何失败或欺骗企图。我们来看看破坏这个通道的一些场景，并且看看需要什么来解决这些问题： 一旦注资交易发生，Emma需要Fabian的签名才能收回自己的任何资金。如果Fabian消失，Emma的资金将被锁定在2/2中，造成实际损失。这个通道一旦建立，如果在双方共同签署至少一个承诺交易之前，有任何一方断开，就会导致资金的流失。 当通道正在运行时，Emma可以把Fabian已经会签的任何承诺交易，提交到区块链上。如果她可以发送1号承诺交易，只需支付1秒的视频，为什么还要支付600秒的视频？通道失败是因为Emma可以通过广播对她比较有利的之前的承诺交易来欺骗。 这两个问题都可以用时间锁(timelocks)来解决，下面看看如何使用交易级时间锁（nLocktime）。 除非有退款保证，否则Emma不能冒风险支付到2/2多重签名地址。为了解决这个问题，Emma同时建立了注资交易和退款交易。她只是签名了注资交易，但暂时不发送给任何人。Emma只将退款交易传送给Fabian，并获得他的签名。 退款交易作为第一个承诺交易，其时间锁规定了通道生命的上限。在这种情况下，Emma可以将nLocktime设置为30天或将来的第4320个区块。所有后续承诺交易必须具有较短的时间锁，以便在退款交易之前能把它们兑换。 现在，Emma已经有一个完全签署的退款交易，她可以自信地发送签署过的注资交易，因为她知道最终可以在时间到期后赎回退款交易，即使Fabian消失也不会有问题。 在通道生命中双方交换的每一个承诺交易都会被时间锁锁进未来的时间点。但是每个承诺交易的延迟时间会稍短一点，因此最近的承诺可以在先前的承诺失效之前兑现。由于nLocktime，任何一方都只有其时间锁到期后才能成功传播任何承诺交易。如果一切顺利，他们将协商并通过结算交易正常关闭通道，这样就无需发送中间的承诺交易了。如果发生意外，则可以传播最近的承诺交易进行账户结算，并使以前的所有承诺交易都失效。 例如，如果1号承诺交易被时间锁锁定到未来的第4320个区块，则2号承诺交易被时间锁锁定到未来的4319个块。就是说在1号承诺交易变为有效之前还有600个区块时，600号承诺交易就可以被花费了。 图12-4显示每个承诺交易设置较短的时间锁，允许在它在之前的承诺变为有效前被花费 图12-4 每个承诺交易设置较短的时间锁，允许在它在之前的承诺变为有效前被花费 每个后续承诺交易必须具有较短的时间锁，以便可以在上一个承诺交易和退款交易之前进行广播。提前广播承诺的能力可以确保只有它最先能够花费资金输出，并阻止任何其他承诺交易通过花费输出实现兑换。比特币区块链提供的担保，即防止双重支出和强制执行时间锁，有效地允许每个承诺交易废止其上一个承诺交易。 状态通道使用时间锁跨时间维度强制执行智能合约。在这个例子中，我们看到时间维度如何保证最近的承诺交易必须在任何之前的承诺之前先行有效。所以，才可以先发送最近的承诺交易，花费输入，并且使先前的承诺交易无效。执行绝对时间锁的智能合约可以防止其中任何一方的欺骗。实现这个只需要绝对的交易级时间锁（nLocktime）。接下来，我们将看到如何使用脚本级时间锁，CHECKLOCKTIMEVERIFY和CHECKSEQUENCEVERIFY来构建更灵活，有用和复杂的状态通道。 2015年，阿根廷的一个开发团队将第一种单向支付渠道作为视频流应用的原型进行了演示。你可以在streamsium.io看到它。 时间锁并不是使之前的承诺交易无效的唯一方法。在接下来的章节中，我们将看到如何使用撤销密钥来实现相同的结果。时间锁是有效的，但其有两个明显的缺点。在通道首次打开时建立最大时间锁，这限制了通道的使用寿命。更糟糕的是，允许通道长时间保留，和如果其中一位参与者提前关闭通道需要等待很长时间才能退款，它们迫使通道要在这二者之间实现一种平衡。例如，如果退款时间设置为30天，那么就是允许通道保持开放30天，如果其中一方立即消失，则另一方必须等待30天才能退款。终点设置越远，退款时间越远。 第二个问题是，由于每个后续的承诺交易必须缩短时间锁，所以在双方之间可以交换的承诺交易数量有明确的限制。例如，一个30天的通道，设置了位于未来第4320个区块的时间锁，在必须被关闭前这段时间只能容纳4320个承诺交易。将时间锁承诺交易的间隔设置为1个区块存在风险。如果将承诺交易之间的时间锁设置为1个区块，开发者会给通道参与者带来了非常高的负担，参与者必须保持警惕，保持在线并监视，并随时准备传送正确的承诺交易。 现在我们了解如何使用时间锁来使先前的承诺无效，我们可以看到协商关闭通道和通过广播承诺交易单方面关闭通道之间的区别。所有承诺交易都是时间锁定的，因为广播承诺交易总是要等待时间锁到期。但是，如果双方同意最后的余额是多少，并且知道双方都持有最终使该余额成为现实的承诺交易，那么他们就可以构建一个结算交易，而不需要代表相同余额的时间戳。在协商关闭中，任一方都接受最近的承诺交易，并建立一个各方面完全相同的结算交易，唯一差别就是它省略了时间锁。双方都可以签署这笔结算交易，因为知道无法作弊以得到更多的余额。通过协商签署和发送结算交易，可以关闭通道并立即兑换余额。最差的情况下，当事人之一可能是卑鄙小人，拒绝合作，强迫另一方单方面关闭最近的承诺交易。但是如果他们这样做，他们也必须一直等待他们的资金。 12.5.4 不对称可撤销承诺 处理先前承诺状态的更好方法是明确撤销它们。但是，这不容易实现。比特币的一个关键特征是，一旦交易有效，它一直有效，不会过期。取消交易的唯一方法是在交易被挖矿前用另一笔交易双重支出它的输入。这就是为什么我们在上述简单支付通道示例中使用时间锁，以确保最新的承诺交易可以在旧承诺生效之前被花费。然而，把承诺在时间上排序造成了许多限制，使得支付通道难以使用。 虽说一个交易无法取消，但是它可以被构造成无法再使用的样子。我们这样做的方法是通过给予每一方一个撤销密钥，如果对方试图欺骗，可以用来进行惩罚。撤销先前承诺交易的这种机制首先被作为闪电网络的一部分提出。 为了解释撤销密钥，我们将在由Hitesh和Irene经营的两个交易所之间构建一个更加复杂的支付通道。 Hitesh和Irene分别在印度和美国运营比特币交易所。 Hitesh的印度交易所的客户经常向Irene的美国交易所的客户发送付款，反之亦然。目前，这些交易发生在比特币链上，但这需要支付交易费还要等待几个区块进行确认。在交易所之间设置支付通道将大大降低成本并加快交易流程。 Hitesh和Irene通过合作建立注资交易来启动通道，每人向通道注资5个比特币。初始余额为Hitesh有5比特币且Irene有5比特币。注资交易将通道状态锁定在2/2多重签名中，就像在简单支付通道的例子中一样。 注资交易可能有一个或多个输入（加起来5个比特币或更多）来自Hitesh，以及Irene的一个或多个输入（同样加起来5个比特币或更多）。为了足够支付交易费用，输入必须略微超过通道容量。该交易有一个输出，将总共10个比特币锁定到由Hitesh和Irene控制的2/2多重地址中。如果他们的输入超过他们需要的金额，注资交易也可能有一个或多个输出将找零返回给Hitesh和Irene。这是由双方提供和签署的输入形成的单一交易。在发送之前，必须合作构建并由各方签署。 接着，Hitesh和Irene创建了两个不对称的asymmetric承诺交易，而不是创建一个双方都签署的单一承诺交易。 Hitesh有一个带有两个输出的承诺交易。第一个输出是立即支付欠Irene的5比特币。第二个输出是支付欠Hitesh自己的5比特币，但条件是只有在1000个区块的时间锁之后。交易输出如下所示： Input: 2-of-2 funding output, signed by Irene Output 0 : CHECKSIG Output 1: CHECKSEQUENCEVERIFY DROP CHECKSIG Irene也有带有两个输出的不同的承诺交易。第一个输出支付欠Hitesh的5比特币。 第二个输出支付给欠Irene自己的5比特币，但同样必须经过1000个区块的时间锁。 Irene持有的承诺交易（由Hitesh签署）看起来像这样： Input: 2-of-2 funding output, signed by Hitesh Output 0: CHECKSIG Output 1: CHECKSEQUENCEVERIFY DROP CHECKSIG 这样一来，双方各有一笔承诺交易，可以花费2/2的资金输出。该承诺交易的输入是由对方署的。在任何时候，持有承诺交易的一方都可以签字（完成2/2签名）并进行广播。然而，如果他们广播承诺交易，承诺交易会立即支付对方，而他们自己的资金则必须等待时间锁到期。通过强制延迟兑换其中一方的输出，我们可以做到让各方在选择单方面广播承诺交易时处于轻微的不利地位。 但是单靠时间延迟还不足以鼓励公平的行为。 下图12-5显示两个不对称承诺交易，其中承诺持有人的输出被延迟 图12-5 显示两个不对称承诺交易，其中承诺持有人的输出被延迟 现在我们介绍这个方案的最后一个要素：一个防止作弊者广播过期承诺的撤销密钥，它允许被欺诈的一方通过占有通道的所有余额来惩罚骗子。 撤销密钥由两个密语组成，每个密语由每个通道参与者独立生成。它类似于2/2的多重签名，使用椭圆曲线算法构造。虽然双方都知道撤销公钥，但其实每一方只知道撤销密钥的一半。 在每一轮交易中，双方都将其撤销密语的一半透露给另一方，从而使另一方（现在双方都有）在广播此撤销的交易时，可以要求获得惩罚输出。 每个承诺交易都有一个“延迟”的输出，该输出的兑换脚本允许一方在1000个区块后兑换它，或者另一方如果拥有撤销密钥也可兑换它。 所以当Hitesh为Irene签署承诺交易时，他将在1000个区块之后把第二个输出定支付给自己，或者支付给撤销公钥（他只知道其中一半的密语）。Hitesh构建了这个交易，他只会在准备改变通道状态，并希望撤销这一承诺交易时，才会把半个撤销密语透露给Irene。 第二个输出脚本如下所示： Output 0 : CHECKSIG Output 1 : IF # Revocation penalty output ELSE CHECKSEQUENCEVERIFY DROP ENDIF CHECKSIG Irene可以自信地签署这笔交易，因为一旦被发送，它将立即首先支付欠她的款。Hitesh持有交易，但知道如果自己单方面关闭通道发送交易，将不得不等待1000个区块才能获得付款。 当通道进入下一个状态时，Hitesh必须在Irene同意签署下一个承诺交易之前撤销此承诺交易。要做到这一点，他所要做的就是将撤销密语发送给Irene。一旦Irene拥有这一承诺的两个半部分撤销密语，她就可以自信地签署下一个承诺。她知道，如果Hitesh试图通过发布先前的承诺交易来作弊，她可以使用撤销密钥来兑换Hitesh的延迟输出。如果Hitesh作弊，Irene会得到两部分输出。同时，Hitesh只有该撤销公钥的一半撤销密语，并且在1000个区块之前无法兑换输出。Irene可以在1000个区块过去之前兑换输出并惩罚Hitesh。 撤销协议是双边的，这意味着在每一轮中，随着通道状态的推进，双方交换新的承诺，并且交换之前承诺的撤销密语，签署双方新的承诺交易。当他们接受新的状态时，他们通过给予对方必要的撤销密语来惩罚任何作弊行为，使先前的状态不可用。 我们来看一个它是如何工作的。Irene的一个客户希望向Hitesh的一个客户发送2比特币。要通过通道传输2比特币，Hitesh和Irene必须更新通道状态以反映新的余额。他们将提交一个新的状态（状态号2），通道的10个比特币被分割，7个比特币属于Hitesh和3个比特币属于Irene。为了更新通道的状态，他们将各自创建反映新通道余额的新承诺交易。 如上述内容所说，这些承诺交易是不对称的，所以每一方所持的承诺交易都迫使他们等待兑换。至关重要的是，在签署新的承诺交易之前，他们必须首先交换撤销密语以使先前的承诺无效。在这种情况下，Hitesh的利益与通道的真实状态是一致的，因此他没有理由广播先前的状态。然而，对于Irene来说，状态号1中留给她的余额比状态2中的更高。当Irene把她以前的承诺交易（状态号1）的撤销密语提供给Hitesh时，她实际上放弃了恢复通道状态到前一状态而从中获益的权利。因为有了撤销密语，Hitesh可以毫不迟疑地兑换先前承诺交易的两个输出。也就是说一旦Irene广播先前的状态，Hitesh可以行使他的权利，占有所有的输出。 重要的是，撤销不会自动发生。虽然Hitesh有能力惩罚Irene的作弊行为，但他必须认真观察区块链中作弊的迹象。如果他看到先前的承诺交易广播，他有1000个区块时间采取行动，并使用撤销密语来阻止Irene的欺骗行为，并占有所有余额，也就是全部10比特币来惩罚她。 带有相对时间锁（CSV）的不对称可撤销承诺是实现支付通道的更好方法，也是区块链技术非常重要的创新。通过这种结构，通道可以无限期地保持开放，并且可以拥有数十亿的中间承诺交易。在闪电网络的原型实现中，承诺状态由48位索引识别，允许在任何单个通道中有超过281万亿（2.8×1014）个状态转换！ 12.5.5 哈希时间锁合约（HTLC） 支付通道可以通过特殊类型的智能合约进一步扩展，该合约允许参与者将资金用于可兑换的有到期时间的密钥。此功能称为哈希时间锁定合约Hash Time Lock Contract或HTLC，用于双向和可路由的支付通道。 首先我们来解释HTLC的“哈希”部分。要创建一个HTLC，预期的收款人将首先创建一个密钥（secret）R。他们然后计算这个R的哈希H： H = Hash(R) 这步产生可以包含在输出的锁定脚本中的哈希H。知道这个密钥的任何人可以用它来兑换输出。密钥R也被称为哈希函数的原像preimage。原像就是用作哈希函数输入的数据。 HTLC的第二部分是“时间锁”组件。如果密钥一直没有被泄露，HTLC的付款人可以在一段时间后得到“退款”。这是通过使用绝对时间锁CHECKLOCKTIMEVERIFY来实现的。 实现HTLC的脚本可能如下所示： IF # Payment if you have the secret R HASH160 EQUALVERIFY ELSE # Refund after timeout. CHECKLOCKTIMEVERIFY DROP CHECKSIG ENDIF 任何知道密钥R，其哈希值等于H的人，都可以通过行使IF语句的第一个子句来兑换该输出。 如果密钥R没有被透露，HTLC中写明了，在一定数量的区块之后，付款人可以使用IF语句中的第二个子句申请退款。 这是HTLC的基本实现。任何拥有秘密R的人都可以兑换这种类型的HTLC。通过对脚本进行略微变化，HTLC可以采用许多不同的形式。例如，在第一个子句中添加一个CHECKSIG运算符和一个公钥来将哈希值的兑换限制为指定收款人，这个人还必须知道密钥R。 12.6 可路由的支付通道（闪电网络） 闪电网络是一种端到端连接的双向支付通道的可路由网络。这样的网络可以允许任何参与者在不信任任何中间人的情况下将支付从一个通道路由到另一个通道。2015年2月，Joseph Poon和Thadeus Dryja首次对闪电网络进行了描述【参见闪电网络白皮书】，该网络建立在许多其他人提出和阐述的支付通道概念的基础上。 “闪电网络”是指路由支付通道网络的具体设计，现已由至少五个不同的开源团队实现。这些独立的实现由一组互操作性标准进行协调，这些互操作性标准在【闪电技术（BOLT）基础白皮书】中进行了描述。 闪电网络的原型实施已经由几个团队发布。 闪电网络是实现可路由支付通道的一种可能方式。还有其他几种旨在实现类似目标的设计，如Teechan和Tumblebit。 12.6.1 闪电网络示例 让我们看看它是如何工作的。 在这个例子中，我们有五个参与者：Alice, Bob, Carol, Diana, and Eric。这五名参与者已经彼此之间开设了支付通道。Alice和Bob有支付通道。Bob连接Carol，Carol连接到Diana，Diana连接Eric。为了简单起见，我们假设每个通道每个参与者都注资2个比特币资金，每个通道的总容量为4个比特币。 下图12-6显示了闪电网络中的五个参与者，通过双向支付通道连接，可以连接到从Alice到Eric的支付。 图12-6 闪电网络中的五个参与者，通过双向支付通道连接，可以连接到从Alice到Eric的支付 Alice想要支付给Eric1个比特币。但是，Alice并没有直接连接Eric的支付通道。创建支付通道需要注资交易，而这笔交易必须首先提交给比特币区块链。Alice不想建立一个新的支付通道还要支出更多的手续费。有没有办法间接支付给Eric？ 下图12-7显示了通过在连接各方参与者的支付通道上通过一系列HTLC承诺将付款从Alice路由到Eric的一步步过程。 图12-7 闪电网络中支付路由的步骤 Alice正在运行闪电网络（LN）节点，该节点正在跟踪其向Bob的支付通道，并且能够发现支付通道之间的路由。Alice的LN节点还可以通过互联网连接到Eric的LN节点。 Eric的LN节点使用随机数生成器创建一个密钥R。Eric的节点不会向任何人泄漏这个密钥。Eric的节点计算密钥R对应的哈希H，并将此哈希H发送到Alice的节点（请参阅图12-10步骤1）。 现在Alice的LN节点构建了Alice的LN节点和Eric的LN节点之间的路由。所使用的路由算法将在后面进行更详细的解释，但现在我们假设Alice节点可以找到一个有效的路由。 然后，Alice的节点构造一个HTLC，支付到哈希H，具有10个区块时间的退款超时（当前块+10），金额为1.003比特币（参见图12-10的步骤2）。额外的0.003将用于补偿参与此支付路由的中间节点。Alice将此HTLC提供给Bob，从和Bob之间的通道余额中扣除1.003比特币，并将其提交给HTLC。该HTLC具有以下含义：“如果Bob知道密钥，Alice将其通道余额的1.003支付给Bob，或者如果超过10个区块后，则退还入Alice的余额”。Alice和Bob之间的通道余额现在由承诺交易表示，其中有三个输出：Bob的2比特币余额，Alice的0.997比特币余额，Alice的HTLC中承诺的1.003比特币。Alice的余额中减少了在HTLC中承诺的金额。 Bob现在有一个承诺，如果他能够在接下来的10个区块内拿到密钥R，他就可以获得Alice锁定的1.003。手上有了这一承诺，Bob的节点在和Carol的支付通道上构建了一个HTLC。Bob的HTLC提交1.002比特币到哈希H共9个区块时间，这个HTLC中如果Carol有密钥R，她可以兑换（参见图12-10步骤3）。Bob知道，如果Carol要获取他的HTLC，她必须出示密钥R。如果Bob在9个区块的时间内拿到R，自己就可以用它来获得Alice的HTLC。通过承诺自己的通道余额9个区块的时间，他也赚了0.001比特币。如果Carol无法获取他的HTLC，那么他也无法获取Alice的HTLC，那么一切都将恢复到以前的通道余额，没有人会亏损。Bob和Carol之间的通道余额现在是：2比特币给Carol，0.998给Bob，1.002由Bob承诺给HTLC。 Carol现在有一个承诺，如果她在接下来的9个区块时间内拿到R，就可以获取Bob锁定的1.002比特币。现在她可以在她与Diana的通道上构建HTLC承诺。她提交了一个1.001比特币的HTLC到哈希H，共计8个区块时间，如果Diana有密钥R ，她就可以兑换（参见图12-10步骤4）。从Carol的角度来看，如果能够实现，她就可以获得的0.001比特币，否则也没有失去任何东西。她提交给Diana的HTLC，只有在拿到R的情况下才可行，到那时候她可以从Bob那里索取HTLC。Carol和Diana之间的通道余额现在是：2给Diana，0.999给Carol，1.001由Carol承诺给HTLC。 最后，Diana可以提供给Eric一个HTLC到哈希H，承诺1比特币，7个区块时间（参见图12-10的步骤5）。Diana与Eric之间的通道余额现在是：Eric有2个，Diana有1个，还有Diana承诺给HTLC的1个。 不过，在这一跳路由上，Eric拥有密钥R，他可以获取Diana提供的HTLC。他将R发送给Diana，并获取1个比特币，添加到他的通道余额中（参见图12-10的步骤6）。通道平衡现在是：1给Diana，3给Eric。 现在，Diana有密钥R，因此，她现在可以获取来自Carol的HTLC。Diana将R发送给Carol，并将1.001比特币添加到其通道余额中（参见图12-10的步骤7）。现在Carol与Diana之间的通道余额是：0.999给Carol，3.001给Diana。Diana已经“赚了”参与这个付款路线0.001比特币。 通过路由回传，秘密R允许每个参与者获取未完成的HTLC。Carol从Bob那里获取1.002个比特币，将他们通道余额设为：0.998给Bob，3.002给Carol（参见图12-10的步骤8）。最后，Bob获取来自Alice的HTLC（参见图12-10的步骤9）。他们的通道余额更新为：0.997给Alice，3.003给Bob。 在没有和Eric创建新支付通道的情况下，Alice实现了支付给了Eric 1个比特币。付款路线中的中间方不必要互相信任。在他们的通道内做一个短时间的资金承诺，他们可以赚取一小笔费用，唯一的风险是，如果通道关闭或路由付款失败，退款有段短短的延迟时间。 12.6.2 闪电网络传输和路由 LN节点之间的所有通信都是点对点加密的。另外，节点有一个长期公钥，它们用作标识符并且彼此认证对方。 每当节点希望向另一个节点发送支付时，它必须首先通过连接具有足够容量的支付通道来构建通过网络的路径。节点公布路由信息，包括他们已经打开了什么通道，每个通道拥有多少容量，以及他们收取多少路由支付费用。路由信息可以以各种方式共享，并且随着闪电网络技术的进步，可能会出现不同的路由协议。一些闪电网络实施使用IRC协议作为节点公布路由信息的一种方便的机制。路由发现的另一种实现方式是使用P2P模型，其中节点在“洪水泛滥”模型中，将通道公告传播给他们的对等体，这类似于比特币传播交易的方法。未来的计划包括一个名为Flare的建议，它是一种具有本地节点“邻居”和远程信标节点的混合路由模型。 在我们前面的例子中，Alice的节点使用这些路由发现机制中的一个，来查找将她的节点连接到Eric的节点的一个或多个路径。一旦Alice的节点构建了路径，她将通过网络初始化该路径，传播一系列加密和嵌套的指令来连接每个相邻的支付通道。 重要的是，这个路径只有Alice的节点才知道。付款路线上的所有其他参与者只能看到相邻的节点。从Carol的角度来看，这看起来像是从Bob到Diana的付款。 Carol不知道Bob实际上是转发Alice的汇款。她也不知道Diana将会向Eric转款。 这是闪电网络的一个重要特征，因为它确保了付款的隐私，并且使得应用监视，审查或黑名单变得很困难。但是，Alice如何建立这种付款路径，而不向中间节点透露任何内容呢？ 闪电网络实现了一种基于称为Sphinx方案的洋葱路由协议。该路由协议确保支付发送者可以通过闪电网络构建路径和在路径上通信，使得： 中间节点可以验证和解密其部分路由信息，并找到下一跳。 除了上一跳和下一跳，他们无法了解作为路径一部分的任何其他节点。 他们无法识别支付路径的长度，或者他们自己在该路径中的位置。 路径的每个部分被加密，使得网络级攻击者不能将来自路径的不同部分的数据包彼此关联。 不同于Tor（互联网上的洋葱路由匿名协议），没有可以被监视的“退出节点”。付款不需要传输到比特币区块链，节点只是更新通道余额。 使用这种洋葱路由协议，Alice将路径的每个元素包裹在加密层中，从尾端开始倒过来工作。她用Eric的公钥加密了Eric的消息。该消息包裹在给Diana的加密消息中，将Eric标识为下一个收件人。给Diana的消息包裹在给Carol的公钥的加密消息中，并将Diana识别为下一个收件人。对Carol的消息被Bob的密钥加密。这样一来，Alice已经构建了这个加密的多层“洋葱”的消息。她把这个发送给Bob，Bob只能解密和解开外层。在里面，Bob发现一封给Carol的消息，他可以转发给Carol，但不能自己破译。沿着路径，消息被转发，解密，转发等，一路到Eric那里。每个参与者只知道各自这一跳的前一个和下一个节点。 路径的每个元素包含承载于HTLC的必须扩展到下一跳的信息，HTLC中的要发送的数量，要包括的费用以及CLTV锁到期时间（以区块为单位）。随着路由信息的传播，节点将HTLC承诺转发到下一跳。 在这一点上，您可能会想知道节点为什么不知道路径的长度及其在该路径中的位置。毕竟，他们收到一个消息，并将其转发到下一跳。难道它不会将路径缩短，或者允许他们推断出路径大小和位置？为了防止这种情况，路径总是固定在20跳，并用随机数据填充。每个节点都会看到下一跳和一个要转发的固定长度的加密消息。只有最终的收件人看得到没有下一跳。对于其他人来说，似乎总是有20多跳要走。 12.6.3 闪电网络优势 闪电网络是第二层路由技术。它可以应用于支持一些基本功能的任何区块链，如多重签名交易，时间锁定和基本的智能合约。 如果闪电网络在比特币网络上实现，那么比特币网络可以大大提高容量，隐私性，颗粒度和速度，而不会牺牲无中介机构的无信任操作原则： 隐私 闪电网络付款比比特币区块链的付款更私密，因为它们不是公开的。虽然路由中的参与者可以看到在其通道上传播的付款，但他们并不知道发件人或收件人。 可替代性 闪电网络使得在比特币上应用监视和黑名单变得更加困难，从而增加了货币的可替代性。 速度 使用闪电网络的比特币交易将以毫秒为单位，而不是分钟，因为HTLC在不用提交交易到区块就进行结算的。 粒度 闪电网络可以使支付至少与比特币“灰尘”限制一样小，甚至更小。一些议案还允许以子聪级增加。 容量 闪电网络将比特币系统的容量提高了几个数量级。每秒可以通过闪电网络路由的付费数量没有具体上限，因为它仅取决于每个节点的容量和速度。 无信任操作 闪电网络使用节点之间的比特币交易，这些节点作为对等节点运行，彼此不信任。因此，闪电网络保留了比特币系统的原理，同时显著扩大了其运行参数。 当然，如前所述，闪电网络协议不是实现路由支付通道的唯一方法。其他被提出的系统包括Tumblebit和Teechan。然而，当前，闪电网络已经部署在testnet上了。几个不同的团队已经开发了正在竞争的LN实现，并且正在努力实现一个通用的互操作性标准（称为BOLT）。闪电网络很可能是第一个部署在生产中的路由支付通道网络。 12.7 结论 我们仅研究了几个新兴应用程序，它们都是使用比特币区块链作为信任平台构建的。这些应用程序将比特币的范围扩大到支付和金融工具之外，涵盖了信任至关重要的许多应用程序。通过去中性化的信任基础，比特币区块链将会是一个在各种行业中催生许多革命性应用的平台。 "},"appdx-bitcoinwhitepaper.html":{"url":"appdx-bitcoinwhitepaper.html","title":"附录A-1 比特币白皮书吴忌寒翻译","keywords":"","body":"附录A-1、比特币白皮书：一种点对点的电子现金系统 原文作者：中本聪（Satoshi Nakamoto） 作者邮箱：Satoshin@gmx.com 执行翻译：8btc.com 巴比特 QQagent [摘要]：本文提出了一种完全通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。虽然数字签名（Digital signatures）部分解决了这个问题，但是如果仍然需要第三方的支持才能防止双重支付（double-spending）的话，那么这种系统也就失去了存在的价值。我们(we)在此提出一种解决方案，使现金系统在点对点的环境下运行，并防止双重支付问题。该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条。这个系统本身需要的基础设施非常少。信息尽最大努力在全网传播即可，节点(nodes)可以随时离开和重新加入网络，并将最长的工作量证明链条作为在该节点离线期间发生的交易的证明。 1. 简介 互联网上的贸易，几乎都需要借助金融机构作为可资信赖的第三方来处理电子支付信息。虽然这类系统在绝大多数情况下都运作良好，但是这类系统仍然内生性地受制于“基于信用的模式”(trust based model)的弱点。我们无法实现完全不可逆的交易，因为金融机构总是不可避免地会出面协调争端。而金融中介的存在，也会增加交易的成本，并且限制了实际可行的最小交易规模，也限制了日常的小额支付交易。并且潜在的损失还在于，很多商品和服务本身是无法退货的，如果缺乏不可逆的支付手段，互联网的贸易就大大受限。因为有潜在的退款的可能，就需要交易双方拥有信任。而商家也必须提防自己的客户，因此会向客户索取完全不必要的个人信息。而实际的商业行为中，一定比例的欺诈性客户也被认为是不可避免的，相关损失视作销售费用处理。而在使用物理现金的情况下，这些销售费用和支付问题上的不确定性却是可以避免的，因为此时没有第三方信用中介的存在。 所以，我们非常需要这样一种电子支付系统，它基于密码学原理而不基于信用，使得任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。杜绝回滚(reverse)支付交易的可能，这就可以保护特定的卖家免于欺诈；而对于想要保护买家的人来说，在此环境下设立通常的第三方担保机制也可谓轻松加愉快。在这篇论文中，我们(we)将提出一种通过点对点分布式的时间戳服务器来生成依照时间前后排列并加以记录的电子交易证明，从而解决双重支付问题。只要诚实的节点所控制的计算能力的总和，大于有合作关系的(cooperating)攻击者的计算能力的总和，该系统就是安全的。 2. 交易(Transactions) 我们定义，一枚电子货币（an electronic coin）是这样的一串数字签名：每一位所有者通过对前一次交易和下一位拥有者的公钥(Public key) 签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾，电子货币就发送给了下一位所有者。而收款人通过对签名进行检验，就能够验证该链条的所有者。 该过程的问题在于，收款人将难以检验，之前的某位所有者，是否对这枚电子货币进行了双重支付。通常的解决方案，就是引入信得过的第三方权威，或者类似于造币厂(mint)的机构，来对每一笔交易进行检验，以防止双重支付。在每一笔交易结束后，这枚电子货币就要被造币厂回收，而造币厂将发行一枚新的电子货币；而只有造币厂直接发行的电子货币，才算作有效，这样就能够防止双重支付。可是该解决方案的问题在于，整个货币系统的命运完全依赖于运作造币厂的公司，因为每一笔交易都要经过该造币厂的确认，而该造币厂就好比是一家银行。 我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。从逻辑上看，为了达到目的，实际上我们需要关注的只是于本交易之前发生的交易，而不需要关注这笔交易发生之后是否会有双重支付的尝试。为了确保某一次交易是不存在的，那么唯一的方法就是获悉之前发生过的所有交易。在造币厂模型里面，造币厂获悉所有的交易，并且决定了交易完成的先后顺序。如果想要在电子系统中排除第三方中介机构，那么交易信息就应当被公开宣布（publicly announced）[1] ，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在交易期间绝大多数的节点都认同该交易是首次出现。 3. 时间戳服务器(Timestamp server) 本解决方案首先提出一个“时间戳服务器”。时间戳服务器通过对以区块(block)形式存在的一组数据实施随机散列而加上时间戳，并将该随机散列进行广播，就像在新闻或世界性新闻组网络（Usenet）的发帖一样[2][3][4][5] 。显然，该时间戳能够证实特定数据必然于某特定时间是的确存在的，因为只有在该时刻存在了才能获取相应的随机散列值。每个时间戳应当将前一个时间戳纳入其随机散列值中，每一个随后的时间戳都对之前的一个时间戳进行增强(reinforcing)，这样就形成了一个链条（Chain）。 4. 工作量证明（Proof-of-Work） 为了在点对点的基础上构建一组分散化的时间戳服务器，仅仅像报纸或世界性新闻网络组一样工作是不够的，我们还需要一个类似于亚当•柏克（Adam Back）提出的哈希现金（Hashcash）[6] 。在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作，比方说SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，而对结果进行检验则仅需要一次随机散列运算。 我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。 同时，该工作量证明机制还解决了在集体投票表决时，谁是大多数的问题。如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，则该机制就被破坏了。而工作量证明机制的本质则是一CPU一票。“大多数”的决定表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。如果想要对业已出现的区块进行修改，攻击者必须重新完成该区块的工作量外加该区块之后所有区块的工作量，并最终赶上和超越诚实节点的工作量。我们将在后文证明，设想一个较慢的攻击者试图赶上随后的区块，那么其成功概率将呈指数化递减。 另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一个预定的平均数。如果区块生成的速度过快，那么难度就会提高。 5. 网络 运行该网络的步骤如下： 1) 新的交易向全网进行广播； 2) 每一个节点都将收到的交易信息纳入一个区块中； 3) 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明； 4) 当一个节点找到了一个工作量证明，它就向全网进行广播； 5) 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性； 6) 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。 节点始终都将最长的链条视为正确的链条，并持续工作和延长它。如果有两个节点同时广播不同版本的新区块，那么其他节点在接收到该区块的时间上将存在先后差别。当此情形，他们将在率先收到的区块基础上进行工作，但也会保留另外一个链条，以防后者变成最长的链条。该僵局（tie）的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为是较长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的链条上工作。 所谓“新的交易要广播”，实际上不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。而区块的广播对被丢弃的信息是具有容错能力的。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了某个区块，也就可以提出自己下载该区块的请求。 6. 激励 我们约定如此：每个区块的第一笔交易进行特殊化处理，该交易产生一枚由该区块创造者拥有的新的电子货币。这样就增加了节点支持该网络的激励，并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。这种将一定数量新货币持续增添到货币系统中的方法，非常类似于耗费资源去挖掘金矿并将黄金注入到流通领域。此时，CPU的时间和电力消耗就是消耗的资源。 另外一个激励的来源则是交易费（transaction fees）。如果某笔交易的输出值小于输入值，那么差额就是交易费，该交易费将被增加到该区块的激励中。只要既定数量的电子货币已经进入流通，那么激励机制就可以逐渐转换为完全依靠交易费，那么本货币系统就能够免于通货膨胀。 激励系统也有助于鼓励节点保持诚实。如果有一个贪婪的攻击者能够调集比所有诚实节点加起来还要多的CPU计算力，那么他就面临一个选择：要么将其用于诚实工作产生新的电子货币，或者将其用于进行二次支付攻击。那么他就会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。 7. 回收硬盘空间 如果最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。为了同时确保不损害区块的随机散列值，交易信息被随机散列时，被构建成一种Merkle树（Merkle tree）[7] 的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。 不含交易信息的区块头（Block header）大小仅有80字节。如果我们设定区块生成的速率为每10分钟一个，那么每一年产生的数据位4.2MB。（80 bytes 6 24 * 365 = 4.2MB）。2008年，PC系统通常的内存容量为2GB，按照摩尔定律的预言，即使将全部的区块头存储于内存之中都不是问题。 8. 简化的支付确认（Simplified Payment Verification） 在不运行完整网络节点的情况下，也能够对支付进行检验。一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支通向它被加上时间戳并纳入区块的那次交易。节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。 当此情形，只要诚实的节点控制了网络，检验机制就是可靠的。但是，当全网被一个计算力占优的攻击者攻击时，将变得较为脆弱。因为网络节点能够自行确认交易的有效性，只要攻击者能够持续地保持计算力优势，简化的机制会被攻击者焊接的（fabricated）交易欺骗。那么一个可行的策略就是，只要他们发现了一个无效的区块，就立刻发出警报，收到警报的用户将立刻开始下载被警告有问题的区块或交易的完整信息，以便对信息的不一致进行判定。对于日常会发生大量收付的商业机构，可能仍会希望运行他们自己的完整节点，以保持较大的独立完全性和检验的快速性。 9. 价值的组合与分割（Combining and Splitting Value） 虽然可以单个单个地对电子货币进行处理，但是对于每一枚电子货币单独发起一次交易将是一种笨拙的办法。为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。 10. 隐私（Privacy） 传统的造币厂模型为交易的参与者提供了一定程度的隐私保护，因为试图向可信任的第三方索取交易信息是严格受限的。但是如果将交易信息向全网进行广播，就意味着这样的方法失效了。但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起，也就是说，公众难以确信，这些人究竟是谁。这同股票交易所发布的信息是类似的，股票交易发生的时间、交易量是记录在案且可供查询的，但是交易双方的身份信息却不予透露。 作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。 11. 计算 设想如下场景：一个攻击者试图比诚实节点产生链条更快地制造替代性区块链。即便它达到了这一目的，但是整个系统也并非就此完全受制于攻击者的独断意志了，比方说凭空创造价值，或者掠夺本不属于攻击者的货币。这是因为节点将不会接受无效的交易，而诚实的节点永远不会接受一个包含了无效信息的区块。一个攻击者能做的，最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。 诚实链条和攻击者链条之间的竞赛，可以用二叉树随机漫步（Binomial Random Walk)来描述。成功事件定义为诚实链条延长了一个区块，使其领先性+1，而失败事件则是攻击者的链条被延长了一个区块，使得差距-1。 攻击者成功填补某一既定差距的可能性，可以近似地看做赌徒破产问题（Gambler’s Ruin problem）。假定一个赌徒拥有无限的透支信用，然后开始进行潜在次数为无穷的赌博，试图填补上自己的亏空。那么我们可以计算他填补上亏空的概率，也就是该攻击者赶上诚实链条，如下所示[8] ： 假定p>q，那么攻击成功的概率就因为区块数的增长而呈现指数化下降。由于概率是攻击者的敌人，如果他不能幸运且快速地获得成功，那么他获得成功的机会随着时间的流逝就变得愈发渺茫。那么我们考虑一个收款人需要等待多长时间，才能足够确信付款人已经难以更改交易了。我们假设付款人是一个支付攻击者，希望让收款人在一段时间内相信他已经付过款了，然后立即将支付的款项重新支付给自己。虽然收款人届时会发现这一点，但为时已晚。 收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。这将可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。当此情形，只要交易一旦发出，攻击者就开始秘密地准备一条包含了该交易替代版本的平行链条。 然后收款人将等待交易出现在首个区块中，然后在等到z个区块链接其后。此时，他仍然不能确切知道攻击者已经进展了多少个区块，但是假设诚实区块将耗费平均预期时间以产生一个区块，那么攻击者的潜在进展就是一个泊松分布，分布的期望值为： 当此情形，为了计算攻击者追赶上的概率，我们将攻击者取得进展区块数量的泊松分布的概率密度，乘以在该数量下攻击者依然能够追赶上的概率。 化为如下形式，避免对无限数列求和： 写为如下C语言代码： #include double AttackerSuccessProbability(double q, int z){double p = 1.0 - q;double lambda = z * (q / p);double sum = 1.0;int i, k;for (k = 0; k 对其进行运算，我们可以得到如下的概率结果，发现概率对z值呈指数下降。 当q=0.1时 z=0 P=1.0000000 z=1 P=0.2045873 z=2 P=0.0509779 z=3 P=0.0131722 z=4 P=0.0034552 z=5 P=0.0009137 z=6 P=0.0002428 z=7 P=0.0000647 z=8 P=0.0000173 z=9 P=0.0000046 z=10 P=0.0000012 当q=0.3时 z=0 P=1.0000000 z=5 P=0.1773523 z=10 P=0.0416605 z=15 P=0.0101008 z=20 P=0.0024804 z=25 P=0.0006132 z=30 P=0.0001522 z=35 P=0.0000379 z=40 P=0.0000095 z=45 P=0.0000024 z=50 P=0.0000006 求解令P 为使P 12.结论 我们在此提出了一种不需要信用中介的电子支付系统。我们首先讨论了通常的电子货币的电子签名原理，虽然这种系统为所有权提供了强有力的控制，但是不足以防止双重支付。为了解决这个问题，我们提出了一种采用工作量证明机制的点对点网络来记录交易的公开信息，只要诚实的节点能够控制绝大多数的CPU计算能力，就能使得攻击者事实上难以改变交易记录。该网络的强健之处在于它结构上的简洁性。节点之间的工作大部分是彼此独立的，只需要很少的协同。每个节点都不需要明确自己的身份，由于交易信息的流动路径并无任何要求，所以只需要尽其最大努力传播即可。节点可以随时离开网络，而想重新加入网络也非常容易，因为只需要补充接收离开期间的工作量证明链条即可。节点通过自己的CPU计算力进行投票，表决他们对有效区块的确认，他们不断延长有效的区块链来表达自己的确认，并拒绝在无效的区块之后延长区块以表示拒绝。本框架包含了一个P2P电子货币系统所需要的全部规则和激励措施。 注释 W Dai（戴伟）,a scheme for a group of untraceable digital pseudonyms to pay each other with money and to enforce contracts amongst themselves without outside help（一种能够借助电子假名在群体内部相互支付并迫使个体遵守规则且不需要外界协助的电子现金机制）, “B-money”, http://www.weidai.com/bmoney.txt, 1998↵ H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,”（在最小化信任的基础上设计一种时间戳服务器） In 20th Symposium on Information Theory in the Benelux, May 1999.↵ S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” （怎样为电子文件添加时间戳）In Journal of Cryptology, vol 3, No.2, pages 99-111, 1991.↵ D. Bayer, S. Haber, W.S. Stornetta, “Improving the efficiency and reliability of digital time-stamping,”（提升电子时间戳的效率和可靠性） In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.↵ S. Haber, W.S. Stornetta, “Secure names for bit-strings,”（比特字串的安全命名） In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. on Computer and Communications Security, pages 28-35, April 1997.↵ A. Back, “Hashcash – a denial of service counter-measure,”（哈希现金——拒绝服务式攻击的克制方法）http://www.hashcash.org/papers/hashcash.pdf, 2002.↵ R.C. Merkle, “Protocols for public key cryptosystems,” （公钥密码系统的协议）In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980. S. Haber, W.S. Stornetta, “Secure names for bit-strings,”（比特字串安全命名） In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. on Computer and Communications Security, pages 28-35, April 1997. H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,”（在最小化信任的条件下设计一种时间戳服务器） In 20th Symposium on Information Theory in the Benelux, May 1999.↵ W. Feller, “An introduction to probability theory and its applications,” （概率学理论与应用导论）1957 "},"bitcoin-whitepaper-cn.html":{"url":"bitcoin-whitepaper-cn.html","title":"附录A-2 比特币白皮书李笑来翻译","keywords":"","body":"附录A-2、比特币白皮书（李笑来中英文对照版） 2008 年 10 月 31 日，中本聪发布了《比特币白皮书》。 网上有若干个版本的《比特币白皮书》中文翻译版本： tiehexue 翻译版本 shdxiang 翻译版本 QQagent（吴忌寒）翻译版本 金晓翻译版本（含注解） 若干年来，《比特币白皮书》我不知道读了多少遍，但在自己动手翻译之前，从未在网上阅读过中文版 —— 因为对我来说没有这个必要。2018 年 10 月 31 日的几天前，我动手翻译了一遍，放在这里。 翻译这个事情，从来都没有“最好的” —— 信达雅也通常只不过是一厢情愿而已。我之所以动手翻译，并非出自于自认为翻译得更好，仅仅是出于一时兴起而已，前后耗费一整天的时间。翻译过程中也参照了以上提到的几个版本，期间，霍炬（@virushuo）和老猫提供了大量的帮助。发布之后，很快 @x1angli 提交了几处很好的更正…… 白皮书中所使用的 svg 格式图片，来自 dhimmel 的代码仓库，@dhimmel 为 Bitcoin Whitepaper 重新制作了版式更好的英文版 html 版本和 pdf 版本。 《比特币白皮书英中对照版》一共有三个文件格式： markdown html pdf 很遗憾，在 github 上直接浏览 markdown 文件时，其中的数学公式不能正确显示。本页面右上部有绿色的按钮Clone or download，下载 ZIP 之后解压缩在本地电脑，即可正常翻阅。MacOS 上比较好用的 Markdown 编辑器是：Typora，.md 文件可以用它阅读，以上的 pdf/html 版本就是使用 Typora 导出的。 您也可以直接点击这里在线阅读。 希望对大家有所帮助！ 其实吧，我知道，这东西真没几个人认真看的…… 十年过来，一如既往地如此。 Bitcoin: A Peer-to-Peer Electronic Cash System 比特币：一种点对点电子现金系统 Abstract. A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone. 概要：一个纯粹的点对点版本的电子现金系统，将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名虽然提供了部分解决方案，但，若是仍然需要被信任的第三方来防止双重支出的话，那么电子支付的主要优势就被抵消了。我们提出一个方案，使用点对点网络去解决双重支出问题。点对点网络将为每笔交易标记时间戳，方法是：把交易的散列数据录入一个不断延展的、以散列为基础的工作证明链上，形成一个如非完全重做就不可能改变的记录。最长链，一方面用来证明已被见证的事件及其顺序，与此同时，也用来证明它来自于最大的 CPU 算力池。只要绝大多数 CPU 算力被良性节点控制 —— 即，它们不与那些尝试攻击网络的节点合作 —— 那么，良性节点将会生成最长链，并且在速度上超过攻击者。这个网络本身需要最小化的结构。信息将以最大努力为基本去传播，节点来去自由；但，加入之时总是需要接受最长的工作证明链作为它们未参与期间所发生之一切的证明。 1. 简介 (Introduction) Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party. 　　互联网商业几乎完全依赖金融机构作为可信第三方去处理电子支付。虽然针对大多数交易来说，这个系统还算不错，但，它仍然被基于信任的模型所固有的缺陷所拖累。完全不可逆转的交易实际上并不可能，因为金融机构不能避免仲裁争议。仲裁成本增加了交易成本，进而限制了最小可能交易的规模，且干脆阻止了很多小额支付交易。除此之外，还有更大的成本：系统无法为那些不可逆的服务提供不可逆的支付。逆转的可能性，造成了对于信任的需求无所不在。商家必须提防着他们的顾客，麻烦顾客提供若非如此（如若信任）就并不必要的更多信息。一定比例的欺诈，被认为是不可避免的。这些成本和支付不确定性，虽然在人与人之间直接使用物理货币支付的时候是可以避免的；但，没有任何一个机制能在双方在其中一方不被信任的情况下通过沟通渠道进行支付。 What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes. 　　我们真正需要的是一种基于加密证明而非基于信任的电子支付系统，允许任意双方在不需要信任第三方的情况下直接交易。算力保障的不可逆转交易能帮助卖家不被欺诈，而保护买家的日常担保机制也很容易实现。在本论文中，我们将提出一种针对双重支出的解决方案，使用点对点的、分布式的时间戳服务器去生成基于算力的证明，按照时间顺序记录每条交易。此系统是安全的，只要诚实节点总体上相对于相互合作的攻击者掌握更多的 CPU 算力。 2. 交易 (Transactions) We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership. 　　我们将一枚电子硬币定义为一个数字签名链。一位所有者将一枚硬币交给另一个人的时候，要通过在这个数字签名链的末尾附加上以下数字签名：上一笔交易的哈希（hash，音译，亦翻译为“散列值”），以及新所有者的公钥。收款人可以通过验证签名去验证数字签名链的所属权。 The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank. 　　这个路径的问题在于收款人无法验证曾经的所有者之中没有人双重支付过。常见的解决方案是引入一个可信的中心化权威方，或称“铸币厂”，让它去检查每一笔交易是否存在双重支付。每一次发生交易之后，硬币必须返回到铸币厂，铸币厂再发行一枚新的硬币。进而，只有铸币厂直接发行的硬币才是可信的、未被双重支付过的。这个解决方案的问题在于，整个货币系统的命运被拴在运营铸币厂的那个公司（就好像银行那样）身上，每一笔交易必须通过它。 We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which To accomplish this without a trusted party, transactions must be publicly announced, and we need a system for participants to to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received. 　　我们需要一种方式，可以让收款人确认之前的所有者并没有在任何之前的交易上签名。就我们的目的而言，只有最早的交易是算数的，所以，我们并不关心其后的双重支付企图。确认一笔交易不存在的唯一方法是获悉所有的交易。在铸币厂模型之中，铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。为了能在没有“被信任的一方”参与的情况下完成以上任务，交易记录必须被公开宣布[1]，进而我们需要一个系统能让参与者们认同它们所接收到的同一个唯一的交易历史。收款人需要证明在每笔交易发生之时，大多数节点能够认同它是第一个被接收的。 3. 时间戳服务器 (Timestamp Server) The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. 　　本解决方案起步于一种时间戳服务器。时间戳服务器是这样工作的：为一组（block）记录（items）的哈希打上时间戳，而后把哈希广播出去，就好像一份报纸所做的那样，或者像是在新闻组（Usenet）里的一个帖子那样[2-5]。显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链；每一个新的时间戳被添加到之前的时间戳之后。 4. 工作证明 (Proof-of-Work) To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash, rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash. 　　为了实现一个基于点对点的分布式时间戳服务器，我们需要使用类似亚当·伯克的哈希现金那样的一个工作证明系统，而不是报纸或者新闻组帖子那样的东西。所谓的工作证明，就是去寻找一个数值；这个数值要满足以下条件：为它提取散列数值之后 —— 例如使用 SHA-256 计算散列数值 —— 这个散列数值必须以一定数量的 0 开头。每增加一个 0 的要求，将使得工作量指数级增加，并且，这个工作量的验证却只需通过计算一个哈希。 For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it. 　　在我们的时间戳网络中，我们是这样实现工作证明的：不断在区块之中增加一个随机数（Nonce），直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。一旦 CPU 的耗费算力所获的的结果满足工作证明，那么这个区块将不再能被更改，除非重新完成之前的所有工作量。随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。 The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added. 　　工作证明同时解决了如何决定谁能代表大多数做决定的问题。如果所谓的“大多数”是基于“一个IP地址一票”的方式决定的话，那么任何一个可以搞定很多 IP 地址的人就可以被认为是“大多数”。工作证明本质上来看，是“一个CPU一票”。所谓的“大多数决定”是由最长链所代表的，因为被投入最多工作的链就是它。如果大多数 CPU 算力被诚实的节点所控制，那么诚实链成长最为迅速，其速度会远超其他竞争链。为了更改一个已经产生的区块，攻击者将不得不重新完成那个区块以及所有其后区块的的工作证明，而后还要追上并超过诚实节点的工作。后文展示为什么一个被拖延了的攻击者能够追上的可能性将随着区块的不断增加而指数级降低。 To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases. 　　为了应对硬件算力综合的不断增加，以及随着时间推进可能产生的节点参与数量变化，工作证明难度由此决定：基于平均每小时产生的区块数量的一个移动平均值。如果区块生成得过快，那么难度将会增加。 5. 网络 (Network) The steps to run the network are as follows: New transactions are broadcast to all nodes. Each node collects new transactions into a block. Each node works on finding a difficult proof-of-work for its block. When a node finds a proof-of-work, it broadcasts the block to all nodes. Nodes accept the block only if all transactions in it are valid and not already spent. Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash. 　　运行网络的步骤如下： 所有新的交易向所有节点广播； 每个节点将新交易打包到一个区块； 每个节点开始为此区块找一个具备难度的工作证明； 当某个区块找到其工作证明，它就要将此区块广播给所有节点； 众多其他节点当且只当以下条件满足才会接受这个区块：其中所有的交易都是有效的，且未被双重支付； 众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。 Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one. 　　节点始终认为最长链是正确的那个，且会不断向其添加新数据。若是有两个节点同时向网络广播了两个不同版本的“下一个区块”，有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个。这种情况下，节点将在它们先接收到的那个区块上继续工作，但也会把另外一个分支保存下来，以防后者成为最长链。当下一个工作证明被找到，而其中的一个分支成为更长的链之后，这个暂时的分歧会被打消，在另外一个分支上工作的节点们会切换到更长的链上。 New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one. 　　新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。 6. 奖励 (Incentive) By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended. 　　按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 CPU 工作时间和它们所用的电力。 The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free. 　　奖励还可以来自交易费用。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀。 The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth. 　　奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。 7. 回收硬盘空间 (Reclaiming Disk Space) Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree [@doi:10.1109/sp.1980.10006; @tag:massias; @doi:10.1145/266420.266430], with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. 　　如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树[7、2、5]之中，而只有树根被纳入该区块的哈希之中。通过砍掉树枝方法，老区块即可被压缩。内部的哈希并不需要被保存。 A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes 6 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory. 　　一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。 8. 简化版支付确认 (Simplified Payment Verification) It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it. 　　即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。 As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification. 　　只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。 9. 价值的组合与分割 (Combining and Splitting Value) Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender. 　　尽管逐个地处理硬币是可能的，但为每分钱设置一个单独的记录是很笨拙的。为了允许价值的分割与合并，交易记录包含多个输入和输出。一般情况下，要么是一个单独的来自于一个相对大的之前的交易的输入，要么是很多个输入来自于更小金额的组合；与此同时，最多有两个输出：一个是支付（指向收款方），如果必要的话，另外一个是找零（指向发款方）。 It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction's history. 　　值得注意的是，“扇出”在这里并不是问题 —— 所谓“扇出”，就是指一笔交易依赖于数笔交易，且这些交易又依赖于更多笔交易。从来就没有必要去提取任何一笔交易的完整独立的历史拷贝。 10. 隐私 (Privacy) The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the \"tape\", is made public, but without telling who the parties were. 　　传统的银行模型通过限制他人获取交易者和可信第三方的信息而达成一定程度的隐私保护。出于对将所有交易记录公开的需求否决了这种方法。但是，维持隐私可通过于另一处的切断信息流来实现——公钥匿名。公众可以看到某某向某某转账了一定的金额，但是，没有任何信息指向某个确定的人。这种水平的信息发布有点像股市交易，只有时间和各个交易的金额被公布，但是，没有人知道交易双方都是谁。 As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner. 　　还有另外一层防火墙。交易者应该针对每一笔交易启用一对新的公私钥，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。 11. 计算 (Calculations) We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent. 　　假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不会使当前系统置于模棱两可的尴尬境地，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。 The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1. 　　诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了 ；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了 。 The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows: 　　攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率[8]，如下： $$ \\begin{eqnarray} \\large p &=& \\text{ 诚实节点找到下一个区块的概率}\\ \\large q &=& \\text{ 攻击者找到下一个区块的概率}\\ \\large q_z &=& \\text{ 攻击者落后 $z$ 个区块却依然能够赶上的概率} \\end{eqnarray} $$ $$ \\large q_z = \\begin{Bmatrix} 1 & \\textit{if}; p \\leq q\\ (q/p)^z & \\textit{if}; p > q \\end{Bmatrix} $$ Given our assumption that , the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind. 　　既然我们已经假定 , 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地做一个前移步刺，那么他的胜率将在他进一步落后的同时消弭殆尽。 We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late. 　　现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。 The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction. 　　收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。 The recipient waits until the transaction has been added to a block and blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value: 　　收款人等到此笔交易被打包进区块，并已经有 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为： $$ \\large \\lambda = z \\frac qp $$ To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point: 　　为了算出攻击者依然可以赶上的概率，我们要把每一个攻击者已有的进展的帕松密度乘以他可以从那一点能够追上来的概率： $$ \\large \\sum_{k=0}^{\\infty} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\cdot \\begin{Bmatrix} (q/p)^{(z-k)} & \\textit{if};k\\leq z\\ 1 & \\textit{if} ; k > z \\end{Bmatrix} $$ Rearranging to avoid summing the infinite tail of the distribution... 为了避免对密度分布的无穷级数求和重新整理… $$ \\large 1 - \\sum_{k=0}^{z} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\left ( 1-(q/p)^{(z-k)} \\right ) $$ Converting to C code... 转换为 C 语言程序…… #include double AttackerSuccessProbability(double q, int z) { double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k Running some results, we can see the probability drop off exponentially with . 获取部分结果，我们可以看到概率随着 的增加指数级下降： q=0.1 z=0 P=1.0000000 z=1 P=0.2045873 z=2 P=0.0509779 z=3 P=0.0131722 z=4 P=0.0034552 z=5 P=0.0009137 z=6 P=0.0002428 z=7 P=0.0000647 z=8 P=0.0000173 z=9 P=0.0000046 z=10 P=0.0000012 q=0.3 z=0 P=1.0000000 z=5 P=0.1773523 z=10 P=0.0416605 z=15 P=0.0101008 z=20 P=0.0024804 z=25 P=0.0006132 z=30 P=0.0001522 z=35 P=0.0000379 z=40 P=0.0000095 z=45 P=0.0000024 z=50 P=0.0000006 Solving for P less than 0.1%... 若是 P 小于 0.1%…… P 12. 结论 (Conclusion) We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism. 　　我们提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。 参考文献 (References) W. Dai, \"b-money,\" http://www.weidai.com/bmoney.txt, 1998. H. Massias, X.S. Avila, and J.-J. Quisquater, \"Design of a secure timestamping service with minimal trust requirements,\" In 20th Symposium on Information Theory in the Benelux, May 1999. S. Haber, W.S. Stornetta, \"How to time-stamp a digital document,\" In Journal of Cryptology, vol 3, no 2, pages 99-111, 1991. D. Bayer, S. Haber, W.S. Stornetta, \"Improving the efficiency and reliability of digital time-stamping,\" In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993. S. Haber, W.S. Stornetta, \"Secure names for bit-strings,\" In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. A. Back, \"Hashcash - a denial of service counter-measure,\" http://www.hashcash.org/papers/hashcash.pdf, 2002. R.C. Merkle, \"Protocols for public key cryptosystems,\" In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980. W. Feller, \"An introduction to probability theory and its applications,\" 1957. "},"appdx-scriptops.html":{"url":"appdx-scriptops.html","title":"附录B 交易脚本的操作符、常量和符号","keywords":"","body":"附录B、交易脚本语言操作符，常量和符号 以下的表和描述参见https://en.bitcoin.it/wiki/Script 表1.脚本压入堆栈 符号 值 (十六进制) 描述 OP_0 or OP_FALSE 0x00 一个字节空串被压入堆栈中 1-75 0x01-0x4b 把接下来的N 个字节压入堆栈中，N 的取值在1 到75 之间 OP_PUSHDATA1 0x4c 下一个脚本字节包括N，会将接下来的N 个字节压入堆栈 OP_PUSHDATA2 0x4d 下两个脚本字节包括N，会将接下来的N 个字节压入堆栈 OP_PUSHDATA4 0x4e 下四个脚本字节包括N，会将接下来的N 个字节压入堆栈 OP_1NEGATE 0x4f 将脚本-1 压入堆栈 OP_RESERVED 0x50 终止- 交易无效（除非在未执行的OP_IF语句中） OP_1 or OP_TRUE 0x51 将脚本1 压入堆栈 OP_2 to OP_16 0x52 to 0x60 将脚本N 压入堆栈，例如OP_2 压入脚本“2” 表2.有条件的流控制的操作符 符号 值 (十六进制) 描述 OP_NOP 0x61 无操作 OP_VER 0x62 终止- 交易无效（除非在未执行的OP_IF 语句中） OP_IF 0x63 如果栈项元素值为0，语句将被执行 OP_NOTIF 0x64 如果栈项元素值不为0，语句将被执行 OP_VERIF 0x65 终止- 交易无效 OP_VERNOTIF 0x66 终止- 交易无效 OP_ELSE 0x67 如果前述的OP_IF 或OP_NOTIF 或OP_ELSE 未被执行，这些语句就会被执行 OP_ENDIF 0x68 终止OP_IF, OP_NOTIF, OP_ELSE 区块 OP_VERIFY 0x69 如果栈项元素值非真，则标记交易无效 OP_RETURN 0x6a 标记交易无效 表3.时间锁操作符 符号 值 (十六进制) 描述 OP_CHECKLOCKTIMEVERIFY (previously OP_NOP2) 0xb1 如果栈顶元素比交易锁定时间字段大，则将交易标记为无效。否则脚本评测将像OP_NOP操作一样继续执行。交易在一下4种之一的情况下是无效的：1.堆栈是空的；2.栈顶元素是负数；3.当交易锁定时间字段值少于500000000时，栈顶元素大于等于500000000，反之亦然；4.输入序列字段等于0xffffffff。具体内容详见BIP-65。 OP_CHECKSEQUENCEVERIFY (previously OP_NOP3) 0xb2 如果输入值(BIP 0068强制规定的顺序)的相对锁定时间不等于或多于栈顶元素值时，将交易标记为无效。具体内容详见BIP-112。 表4.堆栈操作符 符号 值 (十六进制) 描述 OP_TOALTSTACK 0x6b 从主堆栈中取出元素，推入辅堆栈。 OP_FROMALTSTACK 0x6c 从辅堆栈中取出元素，推入主堆栈 OP_2DROP 0x6d 移除栈顶两个元素 OP_2DUP 0x6e 复制栈顶两个元素 OP_3DUP 0x6f 复制栈顶三个元素 OP_2OVER 0x70 把栈底的第三、第四个元素拷贝到栈顶 OP_2ROT 0x71 移动第五、第六元素到栈顶 OP_2SWAP 0x72 将栈顶的两个元素进行交换 OP_IFDUP 0x73 如果栈项元素值不为0，复制该元素值 OP_DEPTH 0x74 Count the items on the stack and push the resulting count OP_DROP 0x75 删除栈顶元素 OP_DUP 0x76 复制栈顶元素 OP_NIP 0x77 删除栈顶的下一个元素 OP_OVER 0x78 复制栈顶的下一个元素到栈顶 OP_PICK 0x79 把堆栈的第n 个元素拷贝到栈顶 OP_ROLL 0x7a 把堆栈的第n 个元素移动到栈顶 OP_ROT 0x7b 翻转栈顶的三个元素 OP_SWAP 0x7c 栈顶的三个元素交换 OP_TUCK 0x7d 拷贝栈顶元素并插入到栈顶第二个元素之后 表5.字符串接操作 符号 值 (十六进制) 描述 OP_CAT 0x7e 连接两个字符串，已禁用 OP_SUBSTR 0x7f 返回字符串的一部分，已禁用 OP_LEFT 0x80 在一个字符串中保留左边指定长度的子串，已禁用 OP_RIGHT 0x81 在一个字符串中保留右边指定长度的子串，已禁用 OP_SIZE 0x82 把栈顶元素的字符串长度压入堆栈 表6.二进制算术和条件 符号 值 (十六进制) 描述 OP_INVERT 0x83 所有输入的位取反，已禁用 OP_AND 0x84 对输入的所有位进行布尔与运算，已禁用 OP_OR 0x85 对输入的每一位进行布尔或运算，已禁用 OP_XOR 0x86 对输入的每一位进行布尔异或运算，已禁用 OP_EQUAL 0x87 如果输入的两个数相等，返回1，否则返回0 OP_EQUALVERIFY 0x88 与OP_EQUAL 一样，如结果为0，之后运行OP_VERIFY OP_RESERVED1 0x89 终止- 无效交易（除非在未执行的OP_IF 语句中） OP_RESERVED2 0x8a 终止-无效交易（除非在未执行的OP_IF 语句中） 表7.数值操作 符号 值 (十六进制) 描述 OP_1ADD 0x8b 栈顶值加1 OP_1SUB 0x8c 栈顶值减1 OP_2MUL 0x8d 无效（栈顶值乘2） OP_2DIV 0x8e 无效（栈顶值除2） OP_NEGATE 0x8f 栈顶值符号取反 OP_ABS 0x90 栈顶值符号取正 OP_NOT 0x91 如果栈顶值为0 或1，则输出1或0；否则输出0 OP_0NOTEQUAL 0x92 输入值为0 输出0；否则输出1 OP_ADD 0x93 弹出栈顶的两个元素，压入二者相加结果 OP_SUB 0x94 弹出栈顶的两个元素，压入二者相减（第二项减去第一项）结果 OP_MUL 0x95 禁用（栈顶两项的积） OP_DIV 0x96 禁用（输出用第二项除以第一项的倍数） OP_MOD 0x97 禁用（输出用第二项除以第一项得到的余数） OP_LSHIFT 0x98 禁用（左移第二项，移动位数为第一项的二进制位数） OP_RSHIFT 0x99 禁用（右移第二项，移动位数为第一项的二进制位数） OP_BOOLAND 0x9a 布尔与运算，两项都不为0，输出1，否则输出0 OP_BOOLOR 0x9b 布尔或运算，两项有一个不为0，输出1，否则输出0 OP_NUMEQUAL 0x9c 两项相等则输出1，否则输出为0 OP_NUMEQUALVERIFY 0x9d 与NUMEQUAL 相同，如结果为0运行OP_VERIFY OP_NUMNOTEQUAL 0x9e 如果栈顶两项不是相等数的话，则输出1 OP_LESSTHAN 0x9f 如果第二项小于栈顶项，则输出1 OP_GREATERTHAN 0xa0 如果第二项大于栈顶项，则输出1 OP_LESSTHANOREQUAL 0xa1 如果第二项小于或等于第一项，则输出1 OP_GREATERTHANOREQUAL 0xa2 如果第二项大于或等于第一项，则输出1 OP_MIN 0xa3 输出栈顶两项中较小的一项 OP_MAX 0xa4 输出栈顶两项中较大的一项 OP_WITHIN 0xa5 如果第三项的数值介于前两项之间，则输出1 表8.加密和散列操作 符号 值 (十六进制) 描述 OP_RIPEMD160 0xa6 返回栈顶项的RIPEMD160 哈希值 OP_SHA1 0xa7 返回栈顶项SHA1 哈希值 OP_SHA256 0xa8 返回栈顶项SHA256 哈希值 OP_HASH160 0xa9 栈顶项进行两次HASH，先用SHA-256，再用RIPEMD-160 OP_HASH256 0xaa 栈顶项用SHA-256 算法HASH 两次 OP_CODESEPARATOR 0xab 标记已进行签名验证的数据 OP_CHECKSIG 0xac 交易所用的签名必须是哈希值和公钥的有效签名，如果为真，则返回1 OP_CHECKSIGVERIFY 0xad 与CHECKSIG 一样，但之后运行OP_VERIFY OP_CHECKMULTISIG 0xae 对于每对签名和公钥运行CHECKSIG。所有的签名要与公钥匹配。实现中存在一个BUG，会从堆栈中弹出一个前缀为OP_0的值。 OP_CHECKMULTISIGVERIFY 0xaf 与CHECKMULTISIG 一样，但之后运行OP_VERIFY 表9.非操作符 符号 值 (十六进制) 描述 OP_NOP1-OP_NOP10 0xb0-0xb9 无操作忽略 表10.仅供内部使用的保留关键字 符号 值 (十六进制) 描述 OP_SMALLDATA 0xf9 代表小数据域 OP_SMALLINTEGER 0xfa 代表小整数数据域 OP_PUBKEYS 0xfb 代表公钥域 OP_PUBKEYHASH 0xfd 代表公钥哈希域 OP_PUBKEY 0xfe 代表公钥域 OP_INVALIDOPCODE 0xff 代表当前未指定的操作码 "},"appdx-bips.html":{"url":"appdx-bips.html","title":"附录C：比特币改进提案（BIP）","keywords":"","body":"附录C、比特币改进提案（BIPs） 比特币改进提案是向比特币社区提供信息的设计文档，或用于描述比特币的新功能，流程或环境。 根据BIP-01，也就是BIP目的和指南（BIP Purpose and Guidelines）的规定，有三种BIP： 标准（Standard）类BIP 描述影响大多数或所有比特币实现的任何更改，例如网络协议的更改，区块或交易有效性规则的更改，或影响使用比特币的应用程序的互操作性的任何更改或附加。 信息（Informational）类BIP 描述比特币设计问题，或向比特币社区提供一般准则或信息，但不提出新功能。信息类BIP不一定代表比特币社区的共识或建议，因此用户和实施者可以忽略信息类BIP或遵循他们的建议。 过程（Process）类BIP 描述一个比特币过程，或者提出一个过程的更改（或一个事件）。过程类BIP类似于标准类BIP，但适用于比特币协议本身以外的其他领域。他们可能会提出一个实现，但不是比特币的代码库;他们经常需要社区的共识;与信息类BIP不同，它们不仅仅是建议，用户通常也不能随意忽略它们。例如包括程序，指南，决策过程的变化以及对比特币开发中使用的工具或环境的更改。任何元BIP也被视为一个过程BIP。 BIP记录在GitHub上的版本化存储库中：https://github.com/bitcoin/bips。 下表BIP的快照显示在2017年4月BIP的快照。了解有关现有BIP及其内容的最新信息请咨询权威机构。 BIP# Title Owner Type Status BIP-1 BIP Purpose and Guidelines Amir Taaki Process Replaced BIP-2 BIP process, revised Luke Dashjr Process Active BIP-8 Version bits with guaranteed lock-in Shaolin Fry Informational Draft BIP-9 Version bits with timeout and delay Pieter Wuille, Peter Todd, Greg Maxwell, Rusty Russell Informational Final BIP-10 Multi-Sig Transaction Distribution Alan Reiner Informational Withdrawn BIP-11 M-of-N Standard Transactions Gavin Andresen Standard Final BIP-12 OP_EVAL Gavin Andresen Standard Withdrawn BIP-13 Address Format for pay-to-script-hash Gavin Andresen Standard Final BIP-14 Protocol Version and User Agent Amir Taaki, Patrick Strateman Standard Final BIP-15 Aliases Amir Taaki Standard Deferred BIP-16 Pay to Script Hash Gavin Andresen Standard Final BIP-17 OP_CHECKHASHVERIFY (CHV) Luke Dashjr Standard Withdrawn BIP-18 hashScriptCheck Luke Dashjr Standard Proposed BIP-19 M-of-N Standard Transactions (Low SigOp) Luke Dashjr Standard Draft BIP-20 URI Scheme Luke Dashjr Standard Replaced BIP-21 URI Scheme Nils Schneider, Matt Corallo Standard Final BIP-22 getblocktemplate - Fundamentals Luke Dashjr Standard Final BIP-23 getblocktemplate - Pooled Mining Luke Dashjr Standard Final BIP-30 Duplicate transactions Pieter Wuille Standard Final BIP-31 Pong message Mike Hearn Standard Final BIP-32 Hierarchical Deterministic Wallets Pieter Wuille Informational Final BIP-33 Stratized Nodes Amir Taaki Standard Draft BIP-34 Block v2, Height in Coinbase Gavin Andresen Standard Final BIP-35 mempool message Jeff Garzik Standard Final BIP-36 Custom Services Stefan Thomas Standard Draft BIP-37 Connection Bloom filtering Mike Hearn, Matt Corallo Standard Final BIP-39 Mnemonic code for generating deterministic keys Marek Palatinus, Pavol Rusnak, Aaron Voisine, Sean Bowe Standard Proposed BIP-40 Stratum wire protocol Marek Palatinus Standard BIP number allocated BIP-41 Stratum mining protocol Marek Palatinus Standard BIP number allocated BIP-42 A finite monetary supply for Bitcoin Pieter Wuille Standard Draft BIP-43 Purpose Field for Deterministic Wallets Marek Palatinus, Pavol Rusnak Informational Draft BIP-44 Multi-Account Hierarchy for Deterministic Wallets Marek Palatinus, Pavol Rusnak Standard Proposed BIP-45 Structure for Deterministic P2SH Multisignature Wallets Manuel Araoz, Ryan X. Charles, Matias Alejo Garcia Standard Proposed BIP-47 Reusable Payment Codes for Hierarchical Deterministic Wallets Justus Ranvier Informational Draft BIP-49 Derivation scheme for P2WPKH-nested-in-P2SH based accounts Daniel Weigl Informational Draft BIP-50 March 2013 Chain Fork Post-Mortem Gavin Andresen Informational Final BIP-60 Fixed Length \"version\" Message (Relay-Transactions Field) Amir Taaki Standard Draft BIP-61 Reject P2P message Gavin Andresen Standard Final BIP-62 Dealing with malleability Pieter Wuille Standard Withdrawn BIP-63 Stealth Addresses Peter Todd Standard BIP number allocated BIP-64 getutxo message Mike Hearn Standard Draft BIP-65 OP_CHECKLOCKTIMEVERIFY Peter Todd Standard Final BIP-66 Strict DER signatures Pieter Wuille Standard Final BIP-67 Deterministic Pay-to-script-hash multi-signature addresses through public key sorting Thomas Kerin, Jean-Pierre Rupp, Ruben de Vries Standard Proposed BIP-68 Relative lock-time using consensus-enforced sequence numbers Mark Friedenbach, BtcDrak, Nicolas Dorier, kinoshitajona Standard Final BIP-69 Lexicographical Indexing of Transaction Inputs and Outputs Kristov Atlas Informational Proposed BIP-70 Payment Protocol Gavin Andresen, Mike Hearn Standard Final BIP-71 Payment Protocol MIME types Gavin Andresen Standard Final BIP-72 bitcoin: uri extensions for Payment Protocol Gavin Andresen Standard Final BIP-73 Use \"Accept\" header for response type negotiation with Payment Request URLs Stephen Pair Standard Final BIP-74 Allow zero value OP_RETURN in Payment Protocol Toby Padilla Standard Draft BIP-75 Out of Band Address Exchange using Payment Protocol Encryption Justin Newton, Matt David, Aaron Voisine, James MacWhyte Standard Draft BIP-80 Hierarchy for Non-Colored Voting Pool Deterministic Multisig Wallets Justus Ranvier, Jimmy Song Informational Deferred BIP-81 Hierarchy for Colored Voting Pool Deterministic Multisig Wallets Justus Ranvier, Jimmy Song Informational Deferred BIP-83 Dynamic Hierarchical Deterministic Key Trees Eric Lombrozo Standard Draft BIP-90 Buried Deployments Suhas Daftuar Informational Draft BIP-99 Motivation and deployment of consensus rule changes ([soft/hard]forks) Jorge Timón Informational Draft BIP-101 Increase maximum block size Gavin Andresen Standard Withdrawn BIP-102 Block size increase to 2MB Jeff Garzik Standard Draft BIP-103 Block size following technological growth Pieter Wuille Standard Draft BIP-104 'Block75' - Max block size like difficulty t.khan Standard Draft BIP-105 Consensus based block size retargeting algorithm BtcDrak Standard Draft BIP-106 Dynamically Controlled Bitcoin Block Size Max Cap Upal Chakraborty Standard Draft BIP-107 Dynamic limit on the block size Washington Y. Sanchez Standard Draft BIP-109 Two million byte size limit with sigop and sighash limits Gavin Andresen Standard Rejected BIP-111 NODE_BLOOM service bit Matt Corallo, Peter Todd Standard Proposed BIP-112 CHECKSEQUENCEVERIFY BtcDrak, Mark Friedenbach, Eric Lombrozo Standard Final BIP-113 Median time-past as endpoint for lock-time calculations Thomas Kerin, Mark Friedenbach Standard Final BIP-114 Merkelized Abstract Syntax Tree Johnson Lau Standard Draft BIP-120 Proof of Payment Kalle Rosenbaum Standard Draft BIP-121 Proof of Payment URI scheme Kalle Rosenbaum Standard Draft BIP-122 URI scheme for Blockchain references / exploration Marco Pontello Standard Draft BIP-123 BIP Classification Eric Lombrozo Process Active BIP-124 Hierarchical Deterministic Script Templates Eric Lombrozo, William Swanson Informational Draft BIP-125 Opt-in Full Replace-by-Fee Signaling David A. Harding, Peter Todd Standard Proposed BIP-126 Best Practices for Heterogeneous Input Script Transactions Kristov Atlas Informational Draft BIP-130 sendheaders message Suhas Daftuar Standard Proposed BIP-131 \"Coalescing Transaction\" Specification (wildcard inputs) Chris Priest Standard Draft BIP-132 Committee-based BIP Acceptance Process Andy Chase Process Withdrawn BIP-133 feefilter message Alex Morcos Standard Draft BIP-134 Flexible Transactions Tom Zander Standard Draft BIP-140 Normalized TXID Christian Decker Standard Draft BIP-141 Segregated Witness (Consensus layer) Eric Lombrozo, Johnson Lau, Pieter Wuille Standard Draft BIP-142 Address Format for Segregated Witness Johnson Lau Standard Deferred BIP-143 Transaction Signature Verification for Version 0 Witness Program Johnson Lau, Pieter Wuille Standard Draft BIP-144 Segregated Witness (Peer Services) Eric Lombrozo, Pieter Wuille Standard Draft BIP-145 getblocktemplate Updates for Segregated Witness Luke Dashjr Standard Draft BIP-146 Dealing with signature encoding malleability Johnson Lau, Pieter Wuille Standard Draft BIP-147 Dealing with dummy stack element malleability Johnson Lau Standard Draft BIP-148 Mandatory activation of segwit deployment Shaolin Fry Standard Draft BIP-150 Peer Authentication Jonas Schnelli Standard Draft BIP-151 Peer-to-Peer Communication Encryption Jonas Schnelli Standard Draft BIP-152 Compact Block Relay Matt Corallo Standard Draft BIP-171 Currency/exchange rate information API Luke Dashjr Standard Draft BIP-180 Block size/weight fraud proof Luke Dashjr Standard Draft BIP-199 Hashed Time-Locked Contract transactions Sean Bowe, Daira Hopwood Standard Draft "},"appdx-bitcore.html":{"url":"appdx-bitcore.html","title":"附录D：Bitcore","keywords":"","body":"附录D Bitcore Bitcore是BitPay提供的一套工具。 其目标是为Bitcoin开发人员提供易于使用的工具。 几乎所有的Bitcore的代码都是用JavaScript编写的。 有一些专门为NodeJS编写的模块。 最后，Bitcore的“节点”模块包括Bitcoin Core的C ++代码。 有关详细信息，请参阅https://bitcore.io。 Bitcore的功能列表 Bitcoin full node (bitcore-node) Block explorer (insight) Block, transaction, and wallet utilities (bitcore-lib) Communicating directly with Bitcoin’s P2P network (bitcore-p2p) Seed entropy mnemonic generation（种子熵助记符） (bitcore-mnemonic) Payment protocol (bitcore-payment-protocol) Message verification and signing (bitcore-message) Elliptic curve Integrated Encryption Scheme（椭圆曲线综合加密方案） (bitcore-ecies) Wallet service (bitcore-wallet-service) Wallet client (bitcore-wallet-client) Integrating services directly with Bitcoin Core (bitcore-node) Bitcore库示例 先决条件 NodeJS >= 4.x 如果使用NodeJS和节点REPL： $ npm install -g bitcore-lib bitcore-p2p 使用bitcore-lib的钱包示例 使用关联的私钥创建新的比特币地址： > bitcore = require('bitcore-lib') > privateKey = new bitcore.PrivateKey() > address = privateKey.toAddress().toString() 创建分层确定性私钥和地址： > hdPrivateKey = bitcore.HDPrivateKey() > hdPublicKey = bitcore.HDPublicKey(hdPrivateKey) > hdAddress = new bitcore.Address(hdPublicKey.publicKey).toString() 从UTXO创建和签署交易： > utxo = { txId: transaction id containing an unspent output, outputIndex: output index e.g. 0, address: addressOfUtxo, script: bitcore.Script.buildPublicKeyHashOut(addressOfUtxo).toString(), satoshis: amount sent to the address } > fee = 3000 //set appropriately for conditions on the network > tx = new bitcore.Transaction() .from(utxo) .to(address, 35000) .fee(fee) .enableRBF() .sign(privateKeyOfUtxo) 替换mempool中的最后一个交易（替换费）： > rbfTx = new Transaction() .from(utxo) .to(address, 35000) .fee(fee*2) .enableRBF() .sign(privateKeyOfUtxo); > tx.serialize(); > rbfTx.serialize(); 将交易广播到比特币网络（注意：仅广播有效交易;请参阅https://bitnodes.21.co/nodes）：1.将以下代码复制到名为broadcast.js的文件中。2.tx和rbfTx变量分别是tx.serialize（）和rbfTx.serialize（）的输出。3.为了更换费用，对等端必须支持bitcoind选项mempoolreplace并将其设置为1。4.运行文件节点broadcast.js： var p2p = require('bitcore-p2p'); var bitcore = require('bitcore-lib'); var tx = new bitcore.Transaction('output from serialize function'); var rbfTx = new bitcore.Transaction('output from serialize function'); var host = 'ip address'; //use valid peer listening on tcp 8333 var peer = new p2p.Peer({host: host}); var messages = new p2p.Messages(); peer.on('ready', function() { var txs = [messages.Transaction(tx), messages.Transaction(rbfTx)]; var index = 0; var interval = setInterval(function() { peer.sendMessage(txs[index++]); console.log('tx: ' + index + ' sent'); if (index === txs.length) { clearInterval(interval); console.log('disconnecting from peer: ' + host); peer.disconnect(); } }, 2000); }); peer.connect(); "},"appdx-pycoin.html":{"url":"appdx-pycoin.html","title":"附录E：pycoin库、实用密钥程序ku和交易程序tx","keywords":"","body":"附录E、pycoin 最初由Richard Kiss编写和维护的Python库pycoin是一个基于Python的库，支持对比特币密钥和交易进行操作，甚至支持足够的脚本语言来适当地处理非标准交易。 pycoin库支持Python 2（2.7.x）和Python 3（3.3之后），并附带一些方便的命令行实用程序ku和tx。 1.实用工具（KU） 命令行实用程序ku（“密钥实用程序”）是用于操纵密钥的瑞士军刀。 它支持BIP-32键，WIF和地址（比特币和代币）。 以下是一些例子。 使用GPG和/ dev / random的默认熵源创建一个BIP-32密钥： $ ku create input : create network : Bitcoin wallet key : xprv9s21ZrQH143K3LU5ctPZTBnb9kTjA5Su9DcWHvXJemiJBsY7VqXUG7hipgdWaU m2nhnzdvxJf5KJo9vjP2nABX65c5sFsWsV8oXcbpehtJi public version : xpub661MyMwAqRbcFpYYiuvZpKjKhnJDZYAkWSY76JvvD7FH4fsG3Nqiov2CfxzxY8 DGcpfT56AMFeo8M8KPkFMfLUtvwjwb6WPv8rY65L2q8Hz tree depth : 0 fingerprint : 9d9c6092 parent f'print : 00000000 child index : 0 chain code : 80574fb260edaa4905bc86c9a47d30c697c50047ed466c0d4a5167f6821e8f3c private key : yes secret exponent : 112471538590155650688604752840386134637231974546906847202389294096567806844862 hex : f8a8a28b28a916e1043cc0aca52033a18a13cab1638d544006469bc171fddfbe wif : L5Z54xi6qJusQT42JHA44mfPVZGjyb4XBRWfxAzUWwRiGx1kV4sP uncompressed : 5KhoEavGNNH4GHKoy2Ptu4KfdNp4r56L5B5un8FP6RZnbsz5Nmb public pair x : 76460638240546478364843397478278468101877117767873462127021560368290114016034 public pair y : 59807879657469774102040120298272207730921291736633247737077406753676825777701 x as hex : a90b3008792432060fa04365941e09a8e4adf928bdbdb9dad41131274e379322 y as hex : 843a0f6ed9c0eb1962c74533795406914fe3f1957c5238951f4fe245a4fcd625 y parity : odd key pair as sec : 03a90b3008792432060fa04365941e09a8e4adf928bdbdb9dad41131274e379322 uncompressed : 04a90b3008792432060fa04365941e09a8e4adf928bdbdb9dad41131274e379322 843a0f6ed9c0eb1962c74533795406914fe3f1957c5238951f4fe245a4fcd625 hash160 : 9d9c609247174ae323acfc96c852753fe3c8819d uncompressed : 8870d869800c9b91ce1eb460f4c60540f87c15d7 Bitcoin address : 1FNNRQ5fSv1wBi5gyfVBs2rkNheMGt86sp uncompressed : 1DSS5isnH4FsVaLVjeVXewVSpfqktdiQAM 从密码短语创建一个BIP-32密钥： 警告 这个例子中的密码很容易猜到。 $ ku P:foo input : P:foo network : Bitcoin wallet key : xprv9s21ZrQH143K31AgNK5pyVvW23gHnkBq2wh5aEk6g1s496M8ZMjxncCKZKgb5j ZoY5eSJMJ2Vbyvi2hbmQnCuHBujZ2WXGTux1X2k9Krdtq public version : xpub661MyMwAqRbcFVF9ULcqLdsEa5WnCCugQAcgNd9iEMQ31tgH6u4DLQWoQayvtS VYFvXz2vPPpbXE1qpjoUFidhjFj82pVShWu9curWmb2zy tree depth : 0 fingerprint : 5d353a2e parent f'print : 00000000 child index : 0 chain code : 5eeb1023fd6dd1ae52a005ce0e73420821e1d90e08be980a85e9111fd7646bbc private key : yes secret exponent : 65825730547097305716057160437970790220123864299761908948746835886007793998275 hex : 91880b0e3017ba586b735fe7d04f1790f3c46b818a2151fb2def5f14dd2fd9c3 wif : L26c3H6jEPVSqAr1usXUp9qtQJw6NHgApq6Ls4ncyqtsvcq2MwKH uncompressed : 5JvNzA5vXDoKYJdw8SwwLHxUxaWvn9mDea6k1vRPCX7KLUVWa7W public pair x : 81821982719381104061777349269130419024493616650993589394553404347774393168191 public pair y : 58994218069605424278320703250689780154785099509277691723126325051200459038290 x as hex : b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f y as hex : 826d8b4d3010aea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52 y parity : even key pair as sec : 02b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f uncompressed : 04b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f 826d8b4d3010aea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52 hash160 : 5d353a2ecdb262477172852d57a3f11de0c19286 uncompressed : e5bd3a7e6cb62b4c820e51200fb1c148d79e67da Bitcoin address : 19Vqc8uLTfUonmxUEZac7fz1M5c5ZZbAii uncompressed : 1MwkRkogzBRMehBntgcq2aJhXCXStJTXHT 获取JSON信息： $ ku P:foo -P -j { \"y_parity\": \"even\", \"public_pair_y_hex\": \"826d8b4d3010aea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52\", \"private_key\": \"no\", \"parent_fingerprint\": \"00000000\", \"tree_depth\": \"0\", \"network\": \"Bitcoin\", \"btc_address_uncompressed\": \"1MwkRkogzBRMehBntgcq2aJhXCXStJTXHT\", \"key_pair_as_sec_uncompressed\": \"04b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f826d8b4d3010aea16ff4c1c1d3ae68541d9a04df54a2c48cc241c2983544de52\", \"public_pair_x_hex\": \"b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f\", \"wallet_key\": \"xpub661MyMwAqRbcFVF9ULcqLdsEa5WnCCugQAcgNd9iEMQ31tgH6u4DLQWoQayvtSVYFvXz2vPPpbXE1qpjoUFidhjFj82pVShWu9curWmb2zy\", \"chain_code\": \"5eeb1023fd6dd1ae52a005ce0e73420821e1d90e08be980a85e9111fd7646bbc\", \"child_index\": \"0\", \"hash160_uncompressed\": \"e5bd3a7e6cb62b4c820e51200fb1c148d79e67da\", \"btc_address\": \"19Vqc8uLTfUonmxUEZac7fz1M5c5ZZbAii\", \"fingerprint\": \"5d353a2e\", \"hash160\": \"5d353a2ecdb262477172852d57a3f11de0c19286\", \"input\": \"P:foo\", \"public_pair_x\": \"81821982719381104061777349269130419024493616650993589394553404347774393168191\", \"public_pair_y\": \"58994218069605424278320703250689780154785099509277691723126325051200459038290\", \"key_pair_as_sec\": \"02b4e599dfa44555a4ed38bcfff0071d5af676a86abf123c5b4b4e8e67a0b0b13f\" } 公共BIP32密钥： $ ku -w -P P:foo xpub661MyMwAqRbcFVF9ULcqLdsEa5WnCCugQAcgNd9iEMQ31tgH6u4DLQWoQayvtSVYFvXz2vPPpbXE1qpjoUFidhjFj82pVShWu9curWmb2zy 生成子项： $ ku -w -s3/2 P:foo xprv9wTErTSkjVyJa1v4cUTFMFkWMe5eu8ErbQcs9xajnsUzCBT7ykHAwdrxvG3g3f6BFk7ms5hHBvmbdutNmyg6iogWKxx6mefEw4M8EroLgKj 硬化子键： $ ku -w -s3/2H P:foo xprv9wTErTSu5AWGkDeUPmqBcbZWX1xq85ZNX9iQRQW9DXwygFp7iRGJo79dsVctcsCHsnZ3XU3DhsuaGZbDh8iDkBN45k67UKsJUXM1JfRCdn1 WIF: $ ku -W P:foo L26c3H6jEPVSqAr1usXUp9qtQJw6NHgApq6Ls4ncyqtsvcq2MwKH 地址： $ ku -a P:foo 19Vqc8uLTfUonmxUEZac7fz1M5c5ZZbAii 生成一堆子项： $ ku P:foo -s 0/0-5 -w xprv9xWkBDfyBXmZjBG9EiXBpy67KK72fphUp9utJokEBFtjsjiuKUUDF5V3TU8U8cDzytqYnSekc8bYuJS8G3bhXxKWB89Ggn2dzLcoJsuEdRK xprv9xWkBDfyBXmZnzKf3bAGifK593gT7WJZPnYAmvc77gUQVej5QHckc5Adtwxa28ACmANi9XhCrRvtFqQcUxt8rUgFz3souMiDdWxJDZnQxzx xprv9xWkBDfyBXmZqdXA8y4SWqfBdy71gSW9sjx9JpCiJEiBwSMQyRxan6srXUPBtj3PTxQFkZJAiwoUpmvtrxKZu4zfsnr3pqyy2vthpkwuoVq xprv9xWkBDfyBXmZsA85GyWj9uYPyoQv826YAadKWMaaEosNrFBKgj2TqWuiWY3zuqxYGpHfv9cnGj5P7e8EskpzKL1Y8Gk9aX6QbryA5raK73p xprv9xWkBDfyBXmZv2q3N66hhZ8DAcEnQDnXML1J62krJAcf7Xb1HJwuW2VMJQrCofY2jtFXdiEY8UsRNJfqK6DAdyZXoMvtaLHyWQx3FS4A9zw xprv9xWkBDfyBXmZw4jEYXUHYc9fT25k9irP87n2RqfJ5bqbjKdT84Mm7Wtc2xmzFuKg7iYf7XFHKkSsaYKWKJbR54bnyAD9GzjUYbAYTtN4ruo 生成相应的地址： $ ku P:foo -s 0/0-5 -a 1MrjE78H1R1rqdFrmkjdHnPUdLCJALbv3x 1AnYyVEcuqeoVzH96zj1eYKwoWfwte2pxu 1GXr1kZfxE1FcK6ZRD5sqqqs5YfvuzA1Lb 116AXZc4bDVQrqmcinzu4aaPdrYqvuiBEK 1Cz2rTLjRM6pMnxPNrRKp9ZSvRtj5dDUML 1WstdwPnU6HEUPme1DQayN9nm6j7nDVEM 生成相应的WIF： $ ku P:foo -s 0/0-5 -W L5a4iE5k9gcJKGqX3FWmxzBYQc29PvZ6pgBaePLVqT5YByEnBomx Kyjgne6GZwPGB6G6kJEhoPbmyjMP7D5d3zRbHVjwcq4iQXD9QqKQ L4B3ygQxK6zH2NQGxLDee2H9v4Lvwg14cLJW7QwWPzCtKHdWMaQz L2L2PZdorybUqkPjrmhem4Ax5EJvP7ijmxbNoQKnmTDMrqemY8UF L2oD6vA4TUyqPF8QG4vhUFSgwCyuuvFZ3v8SKHYFDwkbM765Nrfd KzChTbc3kZFxUSJ3Kt54cxsogeFAD9CCM4zGB22si8nfKcThQn8C 通过选择一个BIP32字符串（与子项0/3对应的字符串）来检查它是否工作： $ ku -W xprv9xWkBDfyBXmZsA85GyWj9uYPyoQv826YAadKWMaaEosNrFBKgj2TqWuiWY3zuqxYGpHfv9cnGj5P7e8EskpzKL1Y8Gk9aX6QbryA5raK73p L2L2PZdorybUqkPjrmhem4Ax5EJvP7ijmxbNoQKnmTDMrqemY8UF $ ku -a xprv9xWkBDfyBXmZsA85GyWj9uYPyoQv826YAadKWMaaEosNrFBKgj2TqWuiWY3zuqxYGpHfv9cnGj5P7e8EskpzKL1Y8Gk9aX6QbryA5raK73p 116AXZc4bDVQrqmcinzu4aaPdrYqvuiBEK 是的，看起来很熟悉 从秘密指数： $ ku 1 input : 1 network : Bitcoin secret exponent : 1 hex : 1 wif : KwDiBf89QgGbjEhKnhXJuH7LrciVrZi3qYjgd9M7rFU73sVHnoWn uncompressed : 5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAnchuDf public pair x : 55066263022277343669578718895168534326250603453777594175500187360389116729240 public pair y : 32670510020758816978083085130507043184471273380659243275938904335757337482424 x as hex : 79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 y as hex : 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 y parity : even key pair as sec : 0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 uncompressed : 0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 hash160 : 751e76e8199196d454941c45d1b3a323f1433bd6 uncompressed : 91b24bf9f5288532960ac687abb035127b1d28a5 Bitcoin address : 1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH uncompressed : 1EHNa6Q4Jz2uvNExL497mE43ikXhwF6kZm 莱特币版本： $ ku -nL 1 input : 1 network : Litecoin secret exponent : 1 hex : 1 wif : T33ydQRKp4FCW5LCLLUB7deioUMoveiwekdwUwyfRDeGZm76aUjV uncompressed : 6u823ozcyt2rjPH8Z2ErsSXJB5PPQwK7VVTwwN4mxLBFrao69XQ public pair x : 55066263022277343669578718895168534326250603453777594175500187360389116729240 public pair y : 32670510020758816978083085130507043184471273380659243275938904335757337482424 x as hex : 79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 y as hex : 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 y parity : even key pair as sec : 0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 uncompressed : 0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 hash160 : 751e76e8199196d454941c45d1b3a323f1433bd6 uncompressed : 91b24bf9f5288532960ac687abb035127b1d28a5 Litecoin address : LVuDpNCSSj6pQ7t9Pv6d6sUkLKoqDEVUnJ uncompressed : LYWKqJhtPeGyBAw7WC8R3F7ovxtzAiubdM 狗狗币WIF: $ ku -nD -W 1 QNcdLVw8fHkixm6NNyN6nVwxKek4u7qrioRbQmjxac5TVoTtZuot 从公共对（在Testnet）： $ ku -nT 55066263022277343669578718895168534326250603453777594175500187360389116729240,even input : 550662630222773436695787188951685343262506034537775941755001873603 89116729240,even network : Bitcoin testnet public pair x : 55066263022277343669578718895168534326250603453777594175500187360389116729240 public pair y : 32670510020758816978083085130507043184471273380659243275938904335757337482424 x as hex : 79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 y as hex : 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 y parity : even key pair as sec : 0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 uncompressed : 0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 hash160 : 751e76e8199196d454941c45d1b3a323f1433bd6 uncompressed : 91b24bf9f5288532960ac687abb035127b1d28a5 Bitcoin testnet address : mrCDrCybB6J1vRfbwM5hemdJz73FwDBC8r uncompressed : mtoKs9V381UAhUia3d7Vb9GNak8Qvmcsme 从hash160: $ ku 751e76e8199196d454941c45d1b3a323f1433bd6 input : 751e76e8199196d454941c45d1b3a323f1433bd6 network : Bitcoin hash160 : 751e76e8199196d454941c45d1b3a323f1433bd6 Bitcoin address : 1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH 作为狗狗币地址: $ ku -nD 751e76e8199196d454941c45d1b3a323f1433bd6 input : 751e76e8199196d454941c45d1b3a323f1433bd6 network : Dogecoin hash160 : 751e76e8199196d454941c45d1b3a323f1433bd6 Dogecoin address : DFpN6QqFfUm3gKNaxN6tNcab1FArL9cZLE 2.交易实用程序（TX） 命令行实用程序tx将以人类可读的形式显示交易，从pycoin的交易缓存或Web服务获取基础交易（当前支持blockchain.info和biteasy.com），合并交易，添加或删除输入或输出，以及签署交易。 以下是一些例子。 查看着名的“皮萨”交易： $ tx 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a warning: consider setting environment variable PYCOIN_CACHE_DIR=~/.pycoin_cache to cache transactions fetched via web services warning: no service providers found for get_tx; consider setting environment variable PYCOIN_SERVICE_PROVIDERS=BLOCKR_IO:BLOCKCHAIN_INFO:BITEASY:BLOCKEXPLORER usage: tx [-h] [-t TRANSACTION_VERSION] [-l LOCK_TIME] [-n NETWORK] [-a] [-i address] [-f path-to-private-keys] [-g GPG_ARGUMENT] [--remove-tx-in tx_in_index_to_delete] [--remove-tx-out tx_out_index_to_delete] [-F transaction-fee] [-u] [-b BITCOIND_URL] [-o path-to-output-file] argument [argument ...] tx: error: can't find Tx with id 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a 哎呀！ 我们没有设置Web服务。 现在我们来做： $ PYCOIN_CACHE_DIR=~/.pycoin_cache $ PYCOIN_SERVICE_PROVIDERS=BLOCKR_IO:BLOCKCHAIN_INFO:BITEASY:BLOCKEXPLORER $ export PYCOIN_CACHE_DIR PYCOIN_SERVICE_PROVIDERS 这不是自动完成的，所以命令行工具不会泄漏潜在的关于您对第三方网站感兴趣的交易的私人信息。 如果您不在乎，可以将这些行放入.profile。 让我们再试一次： $ tx 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a Version: 1 tx hash 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a 159 bytes TxIn count: 1; TxOut count: 1 Lock time: 0 (valid anytime) Input: 0: (unknown) from 1e133f7de73ac7d074e2746a3d6717dfc99ecaa8e9f9fade2cb8b0b20a5e0441:0 Output: 0: 1CZDM6oTttND6WPdt3D6bydo7DYKzd9Qik receives 10000000.00000 mBTC Total output 10000000.00000 mBTC including unspents in hex dump since transaction not fully signed 010000000141045e0ab2b0b82cdefaf9e9a8ca9ec9df17673d6a74e274d0c73ae77d3f131e000000004a493046022100a7f26eda874931999c90f87f01ff1ffc76bcd058fe16137e0e63fdb6a35c2d78022100a61e9199238eb73f07c8f209504c84b80f03e30ed8169edd44f80ed17ddf451901ffffffff010010a5d4e80000001976a9147ec1003336542cae8bded8909cdd6b5e48ba0ab688ac00000000 ** can't validate transaction as source transactions missing 出现最后一行是为了验证交易的签名，您技术上需要源代码交易。 所以我们来添加-a来增加源信息的交易： $ tx -a 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a warning: transaction fees recommendations casually calculated and estimates may be incorrect warning: transaction fee lower than (casually calculated) expected value of 0.1 mBTC, transaction might not propogate Version: 1 tx hash 49d2adb6e476fa46d8357babf78b1b501fd39e177ac7833124b3f67b17c40c2a 159 bytes TxIn count: 1; TxOut count: 1 Lock time: 0 (valid anytime) Input: 0: 17WFx2GQZUmh6Up2NDNCEDk3deYomdNCfk from 1e133f7de73ac7d074e2746a3d6717dfc99ecaa8e9f9fade2cb8b0b20a5e0441:0 10000000.00000 mBTC sig ok Output: 0: 1CZDM6oTttND6WPdt3D6bydo7DYKzd9Qik receives 10000000.00000 mBTC Total input 10000000.00000 mBTC Total output 10000000.00000 mBTC Total fees 0.00000 mBTC 010000000141045e0ab2b0b82cdefaf9e9a8ca9ec9df17673d6a74e274d0c73ae77d3f131e000000004a493046022100a7f26eda874931999c90f87f01ff1ffc76bcd058fe16137e0e63fdb6a35c2d78022100a61e9199238eb73f07c8f209504c84b80f03e30ed8169edd44f80ed17ddf451901ffffffff010010a5d4e80000001976a9147ec1003336542cae8bded8909cdd6b5e48ba0ab688ac00000000 all incoming transaction values validated 现在，我们来看一下特定地址（UTXO）的未使用输出。 在块＃1中，我们看到一个钱币交易到12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX。 让我们用fetch_unspent来查找这个地址中的所有钱币： $ fetch_unspent 12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX a3a6f902a51a2cbebede144e48a88c05e608c2cce28024041a5b9874013a1e2a/0/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/333000 cea36d008badf5c7866894b191d3239de9582d89b6b452b596f1f1b76347f8cb/31/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/10000 065ef6b1463f552f675622a5d1fd2c08d6324b4402049f68e767a719e2049e8d/86/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/10000 a66dddd42f9f2491d3c336ce5527d45cc5c2163aaed3158f81dc054447f447a2/0/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/10000 ffd901679de65d4398de90cefe68d2c3ef073c41f7e8dbec2fb5cd75fe71dfe7/0/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/100 d658ab87cc053b8dbcfd4aa2717fd23cc3edfe90ec75351fadd6a0f7993b461d/5/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/911 36ebe0ca3237002acb12e1474a3859bde0ac84b419ec4ae373e63363ebef731c/1/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/100000 fd87f9adebb17f4ebb1673da76ff48ad29e64b7afa02fda0f2c14e43d220fe24/0/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/1 dfdf0b375a987f17056e5e919ee6eadd87dad36c09c4016d4a03cea15e5c05e3/1/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/1337 cb2679bfd0a557b2dc0d8a6116822f3fcbe281ca3f3e18d3855aa7ea378fa373/0/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/1337 d6be34ccf6edddc3cf69842dce99fe503bf632ba2c2adb0f95c63f6706ae0c52/1/76a914119b098e2e980a229e139a9ed01a469e518e6f2688ac/2000000 0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098/0/410496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858eeac/5000000000 "},"appdx-bx.html":{"url":"appdx-bx.html","title":"附录F：Bitcoin Explorer（bx）命令","keywords":"","body":"附录F、比特币浏览器命令 Bitcoin Explorer（bx）是一个命令行工具，提供了各种用于密钥管理和交易构建的命令。 它是libbitcoin比特币库的一部分。 Usage: bx COMMAND [--help] Info: The bx commands are: address-decode address-embed address-encode address-validate base16-decode base16-encode base58-decode base58-encode base58check-decode base58check-encode base64-decode base64-encode bitcoin160 bitcoin256 btc-to-satoshi ec-add ec-add-secrets ec-multiply ec-multiply-secrets ec-new ec-to-address ec-to-public ec-to-wif fetch-balance fetch-header fetch-height fetch-history fetch-stealth fetch-tx fetch-tx-index hd-new hd-private hd-public hd-to-address hd-to-ec hd-to-public hd-to-wif help input-set input-sign input-validate message-sign message-validate mnemonic-decode mnemonic-encode ripemd160 satoshi-to-btc script-decode script-encode script-to-address seed send-tx send-tx-node send-tx-p2p settings sha160 sha256 sha512 stealth-decode stealth-encode stealth-public stealth-secret stealth-shared tx-decode tx-encode uri-decode uri-encode validate-tx watch-address wif-to-ec wif-to-public wrap-decode wrap-encode 更多信息参见Bitcoin Explorer homepage 和 Bitcoin Explorer user documentation bx命令使用示例 我们来看一些使用Bitcoin Explorer命令来测试密钥和地址的例子。 使用种子命令生成随机“种子”值，该种子命令使用操作系统的随机数生成器。 将种子传递到ec-new命令以生成新的私钥。 我们将标准输出保存到文件private_key中： $ bx seed | bx ec-new > private_key $ cat private_key 73096ed11ab9f1db6135857958ece7d73ea7c30862145bcc4bbc7649075de474 现在，使用ec-to-public命令从私钥生成公钥。 我们将private_key文件传递到标准输入并将命令的标准输出保存到新文件public_key中： $ bx ec-to-public public_key $ cat public_key 02fca46a6006a62dfdd2dbb2149359d0d97a04f430f12a7626dd409256c12be500 我们可以使用ec-to-address命令将public_key重新格式化为一个地址。 我们将public_key传递给标准输入： $ bx ec-to-address 以这种方式产生的密钥产生零型非确定性钱包。 这意味着每个密钥都是由一个独立的种子生成的。 Bitcoin Explorer命令也可以根据BIP-32确定性地生成密钥。 在这种情况下，从种子创建“主”键，然后确定性地扩展以产生一个子项的树，从而产生一个2类确定性钱包。 首先，我们使用seed和hd-new命令生成一个主密钥，该密钥将被用作导出密钥层次结构的基础： $ bx seed > seed $ cat seed eb68ee9f3df6bd4441a9feadec179ff1 $ bx hd-new master $ cat master xprv9s21ZrQH143K2BEhMYpNQoUvAgiEjArAVaZaCTgsaGe6LsAnwubeiTcDzd23mAoyizm9cApe51gNfLMkBqkYoWWMCRwzfuJk8RwF1SVEpAQ 我们现在使用hd-private命令在帐户中生成一个强化的“帐户”键和两个私钥序列： $ bx hd-private --hard account $ cat account xprv9vkDLt81dTKjwHB8fsVB5QK8cGnzveChzSrtCfvu3aMWvQaThp59ueufuyQ8Qi3qpjk4aKsbmbfxwcgS8PYbgoR2NWHeLyvg4DhoEE68A1n $ bx hd-private --index 0 接下来，我们使用hd-public命令来生成两个公钥的相应序列： $ bx hd-public --index 0 公钥也可以使用hd-to-public命令从其相应的私钥派生： $ bx hd-private --index 0 我们可以在确定性链中产生几乎无限数量的密钥，全部来源于单个种子。 这种技术用于许多钱包应用程序中以生成可以使用单个种子值进行备份和恢复的密钥。 每次创建一个新的密钥时，这比将其所有随机生成的密钥备份在一起更容易。 可以使用助记符编码命令对种子进行编码： $ bx hd-mnemonic words adore repeat vision worst especially veil inch woman cast recall dwell appreciate 然后可以使用mnemonic-decode命令对种子进行解码： $ bx mnemonic-decode 助记符编码可以使种子更容易记录甚至记住。 "}}